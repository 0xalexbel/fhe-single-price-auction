{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/auctions/factories/FHEAuctionERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {FHEAuctionEngineFactory} from \"../../engines/factories/FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionFactory} from \"./FHEAuctionFactory.sol\";\nimport {FHEAuctionERC20} from \"../FHEAuctionERC20.sol\";\nimport {FHEAuctionBase} from \"../FHEAuctionBase.sol\";\n\ncontract FHEAuctionERC20Factory is FHEAuctionFactory {\n    event FHEAuctionERC20Deployed(address indexed auction_, bytes32 indexed salt_, address beneficiary_, address auctionToken_, address paymentToken_);\n\n    constructor(FHEAuctionFactoryDetails memory details_) FHEAuctionFactory(details_) {\n    }\n\n    function isNative() public view virtual override returns (bool) {\n        return false;\n    }\n\n    function getAuction(bytes32 salt_, address beneficiary_, address auctionToken_, address paymentToken_) external view returns (address) {\n        return _getAuction(_hashSalt(salt_, beneficiary_, auctionToken_, paymentToken_));\n    }\n\n    function _getCode() internal view virtual override returns (bytes memory) {\n        return type(FHEAuctionERC20).creationCode;\n    }\n\n    function _hashSalt(bytes32 salt_, address beneficiary_, address auctionToken_, address paymentToken_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(salt_, beneficiary_, auctionToken_, paymentToken_));\n    }\n\n    function computeAuctionAddress(\n        bytes32 salt_,\n        address beneficiary_,\n        address auctionToken_,\n        address paymentToken_,\n        uint256 minimumPaymentDeposit_,\n        uint256 paymentPenalty_\n    ) public view returns (address) {\n        bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_, paymentToken_);\n        bytes memory code = _getCode();\n        bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_, paymentToken_);\n        bytes memory bytecode = abi.encodePacked(code, constructData);\n        return Create2.computeAddress(deploySalt, keccak256(bytecode));\n    }\n\n    function createNewAuction(\n        address auctionOwner_,\n        bytes32 salt_,\n        address beneficiary_,\n        uint256 auctionQuantity_,\n        address auctionToken_,\n        uint16 maxBidCount_,\n        uint8 tieBreakingRule_,\n        address paymentToken_,\n        uint256 minimumPaymentDeposit_,\n        uint256 paymentPenalty_\n    ) public returns (address) {\n        address auctionAddr;\n        {\n            bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_, paymentToken_);\n\n            require(_getAuction(deploySalt) == address(0), \"auction already deployed\");\n\n            bytes memory code = _getCode();\n            bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_, paymentToken_);\n            bytes memory bytecode = abi.encodePacked(code, constructData);\n\n            // Reentrancy\n            address computedAuctionAddr = Create2.computeAddress(deploySalt, keccak256(bytecode));\n            _setAuction(deploySalt, computedAuctionAddr);\n\n            auctionAddr = Create2.deploy(0, deploySalt, bytecode);\n\n            // Debug\n            require(auctionAddr == computedAuctionAddr, \"Panic: auctionAddr != computedAuctionAddr\");\n        }\n\n        address engine = _getEngineFactory(tieBreakingRule_).createNewEngine(auctionAddr);\n\n        FHEAuctionBase auction = FHEAuctionBase(auctionAddr);\n\n        auction.initialize(engine, beneficiary_, IERC20(auctionToken_), auctionQuantity_, maxBidCount_);\n        auction.transferOwnership(auctionOwner_);\n\n        emit FHEAuctionERC20Deployed(auctionAddr, salt_, beneficiary_, auctionToken_, paymentToken_);\n\n        return auctionAddr;\n    }\n}\n"
    },
    "contracts/auctions/factories/FHEAuctionFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {FHEAuctionEngineFactory} from \"../../engines/factories/FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionEngine} from \"../../engines/FHEAuctionEngine.sol\";\n\nabstract contract FHEAuctionFactory is Ownable2Step {\n    struct FHEAuctionFactoryDetails {\n        FHEAuctionEngineFactory enginePriceIdFactory;\n        FHEAuctionEngineFactory enginePriceQuantityIdFactory;\n        FHEAuctionEngineFactory enginePriceRandomFactory;\n        FHEAuctionEngineFactory engineProRataFactory;\n    }\n\n    mapping(uint8 => FHEAuctionEngineFactory) private _engineFactories;\n    mapping(bytes32 => address) private _auctionDeployed;\n\n    constructor(FHEAuctionFactoryDetails memory details_) Ownable(msg.sender) {\n        if (address(details_.enginePriceIdFactory) != address(0)) {\n            if (details_.enginePriceIdFactory.owner() != msg.sender) {\n                revert OwnableUnauthorizedAccount(_msgSender());\n            }\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceId)] = details_.enginePriceIdFactory;\n        }\n\n        if (address(details_.enginePriceQuantityIdFactory) != address(0)) {\n            if (details_.enginePriceQuantityIdFactory.owner() != msg.sender) {\n                revert OwnableUnauthorizedAccount(_msgSender());\n            }\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceQuantityId)] =\n                details_.enginePriceQuantityIdFactory;\n        }\n\n        if (address(details_.enginePriceRandomFactory) != address(0)) {\n            if (details_.enginePriceRandomFactory.owner() != msg.sender) {\n                revert OwnableUnauthorizedAccount(_msgSender());\n            }\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceRandom)] = details_.enginePriceRandomFactory;\n        }\n\n        if (address(details_.engineProRataFactory) != address(0)) {\n            if (details_.engineProRataFactory.owner() != msg.sender) {\n                revert OwnableUnauthorizedAccount(_msgSender());\n            }\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.ProRata)] = details_.engineProRataFactory;\n        }\n    }\n\n    function _getEngineFactory(uint8 tieBreakingRule) internal view returns(FHEAuctionEngineFactory) {\n        return _engineFactories[tieBreakingRule];\n    }\n\n    function _getAuction(bytes32 deploySalt) internal view returns(address) {\n        return _auctionDeployed[deploySalt];\n    }\n\n    function _setAuction(bytes32 deploySalt, address auctionAddr) internal {\n        require(_auctionDeployed[deploySalt] == address(0), \"Auction already deployed\");\n        _auctionDeployed[deploySalt] = auctionAddr;\n    }\n\n    function isNative() public view virtual returns (bool);\n    function _getCode() internal view virtual returns (bytes memory);\n}\n"
    },
    "contracts/auctions/factories/FHEAuctionNativeFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {FHEAuctionFactory} from \"./FHEAuctionFactory.sol\";\nimport {FHEAuctionNative} from \"../FHEAuctionNative.sol\";\nimport {FHEAuctionBase} from \"../FHEAuctionBase.sol\";\n\ncontract FHEAuctionNativeFactory is FHEAuctionFactory {\n    constructor(FHEAuctionFactoryDetails memory details_) FHEAuctionFactory(details_) {}\n\n    event FHEAuctionNativeDeployed(address indexed auction_, bytes32 indexed salt_, address beneficiary_, address auctionToken_);\n\n    function isNative() public view virtual override returns (bool) {\n        return true;\n    }\n\n    function getAuction(bytes32 salt_, address beneficiary_, address auctionToken_) external view returns (address) {\n        return _getAuction(_hashSalt(salt_, beneficiary_, auctionToken_));\n    }\n\n    function _getCode() internal view virtual override returns (bytes memory) {\n        return type(FHEAuctionNative).creationCode;\n    }\n\n    function _hashSalt(bytes32 salt_, address beneficiary_, address auctionToken_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(salt_, beneficiary_, auctionToken_));\n    }\n\n    function computeAuctionAddress(\n        bytes32 salt_,\n        address beneficiary_,\n        address auctionToken_,\n        uint256 minimumPaymentDeposit_,\n        uint256 paymentPenalty_\n    ) public view returns (address) {\n        bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_);\n        bytes memory code = _getCode();\n        bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_);\n        bytes memory bytecode = abi.encodePacked(code, constructData);\n        return Create2.computeAddress(deploySalt, keccak256(bytecode));\n    }\n\n    function createNewAuction(\n        address auctionOwner_,\n        bytes32 salt_,\n        address beneficiary_,\n        uint256 auctionQuantity_,\n        address auctionToken_,\n        uint16 maxBidCount_,\n        uint8 tieBreakingRule_,\n        uint256 minimumPaymentDeposit_,\n        uint256 paymentPenalty_\n    ) public returns (address) {\n        address auctionAddr;\n        {\n            bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_);\n\n            require(_getAuction(deploySalt) == address(0), \"auction already deployed\");\n\n            bytes memory code = _getCode();\n            bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_);\n            bytes memory bytecode = abi.encodePacked(code, constructData);\n            \n            // Reentrancy\n            address computedAuctionAddr = Create2.computeAddress(deploySalt, keccak256(bytecode));\n            _setAuction(deploySalt, computedAuctionAddr);\n\n            auctionAddr = Create2.deploy(0, deploySalt, bytecode);\n\n            // Debug\n            require(auctionAddr == computedAuctionAddr, \"Panic: auctionAddr != computedAuctionAddr\");\n        }\n\n        address engine = _getEngineFactory(tieBreakingRule_).createNewEngine(auctionAddr);\n\n        FHEAuctionBase auction = FHEAuctionBase(auctionAddr);\n\n        auction.initialize(engine, beneficiary_, IERC20(auctionToken_), auctionQuantity_, maxBidCount_);\n        auction.transferOwnership(auctionOwner_);\n\n        emit FHEAuctionNativeDeployed(auctionAddr, salt_, beneficiary_, address(auctionToken_) );\n\n        return auctionAddr;\n    }\n}\n"
    },
    "contracts/auctions/FHEAuction.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"fhevm/gateway/GatewayCaller.sol\";\nimport {FHEAuctionBase} from \"./FHEAuctionBase.sol\";\nimport {IFHEAuction} from \"./IFHEAuction.sol\";\n\n/**\n * @dev Base abstract contract for implementing a Single Price Auction using a non-encrypted payment token.\n *\n * This contract serves as the foundation for a Single Price Auction mechanism where bidders place bids\n * using non-encrypted payment tokens (e.g., Ether or ERC20 tokens).\n *\n * Derived contracts can further customize the logic for specific payment token operations.\n */\nabstract contract FHEAuction is FHEAuctionBase, IFHEAuction {\n    mapping(address account => uint256) private _balances;\n    mapping(uint256 requestID => address bidder) private _requestIDToBidder;\n    mapping(uint256 requestID => uint16 rank) private _requestIDToRank;\n\n    /**\n     * @notice Returns the value of payment tokens deposited by `bidder`\n     */\n    function balanceOf(address bidder) public view returns (uint256) {\n        return _balances[bidder];\n    }\n\n    /**\n     * @dev See {FHEAuctionBase-_canClaim}.\n     * @dev Additionnal conditions:\n     * - The final uniform price must have been decrypted.\n     */\n    function _canClaim(address bidder) internal view virtual override(FHEAuctionBase) returns (bool) {\n        if (clearUniformPrice() == 0) {\n            // the auction uniform price is not yet decrypted\n            return false;\n        }\n        return super._canClaim(bidder);\n    }\n\n    /**\n     * @dev See {FHEAuctionBase-_canBlindClaimRank}.\n     * @dev Additionnal conditions:\n     * - The final uniform price must have been decrypted.\n     */\n    function _canBlindClaimRank(uint16 rank) internal view virtual override(FHEAuctionBase) returns (bool) {\n        if (clearUniformPrice() == 0) {\n            // the auction uniform price is not yet decrypted\n            return false;\n        }\n        return super._canBlindClaimRank(rank);\n    }\n\n    /**\n     * @dev See {FHEAuctionBase-_claim}.\n     */\n    function _claim(address bidder, uint16, /*id*/ euint256 validatedPrice, euint256 wonQuantity)\n        internal\n        virtual\n        override\n    {\n        uint256[] memory cts = new uint256[](2);\n        cts[0] = Gateway.toUint256(validatedPrice);\n        cts[1] = Gateway.toUint256(wonQuantity);\n        uint256 requestID =\n            Gateway.requestDecryption(cts, this.callbackDecryptWonQuantity.selector, 0, block.timestamp + 100, false);\n\n        _requestIDToBidder[requestID] = bidder;\n    }\n\n    /**\n     * @dev see {_callbackDecrypt}\n     * @dev This function can only be called by the fhEVM Gateway.\n     */\n    function callbackDecryptWonQuantity(uint256 requestID, uint256 clearValidatedPrice, uint256 clearWonQuantity)\n        external\n        onlyGateway\n    {\n        _callbackDecrypt(_requestIDToBidder[requestID], clearValidatedPrice, clearWonQuantity);\n    }\n\n    /**\n     * @dev See {FHEAuctionBase-_claimRank}.\n     */\n    function _claimRank(uint16 rank, euint16 id, euint256 validatedPrice, euint256 wonQuantity)\n        internal\n        virtual\n        override\n    {\n        uint256[] memory cts = new uint256[](3);\n        cts[0] = Gateway.toUint256(id);\n        cts[1] = Gateway.toUint256(validatedPrice);\n        cts[2] = Gateway.toUint256(wonQuantity);\n        uint256 requestID = Gateway.requestDecryption(\n            cts, this.callbackDecryptRankedWonQuantity.selector, 0, block.timestamp + 100, false\n        );\n\n        _requestIDToRank[requestID] = rank;\n    }\n\n    /**\n     * @dev see {_callbackDecrypt}\n     * @dev This function can only be called by the fhEVM Gateway.\n     */\n    function callbackDecryptRankedWonQuantity(\n        uint256 requestID,\n        uint16 clearId,\n        uint256 clearValidatedPrice,\n        uint256 clearWonQuantity\n    ) external onlyGateway {\n        // reverts if already completed\n        _markBlindClaimRankCompleted(_requestIDToRank[requestID]);\n\n        _callbackDecrypt(_getBidderById(clearId), clearValidatedPrice, clearWonQuantity);\n    }\n\n    /**\n     * @dev Callback function to process the results of a requested claim.\n     * It handles the transfer of payments as follows:\n     * - Transfers the payment (including any penalty fees for invalid bids) to the auction beneficiary.\n     * - Transfers any remaining payment token balance to the bidder.\n     *\n     * @param bidder The bidder address.\n     * @param clearValidatedPrice The decrypted validated price of the auction provided by the Gateway. If this value is\n     * zero, the bid is considered invalid and subject to a penalty fee.\n     * @param clearWonQuantity The decrypted final quantity won by the bidder in the auction, provided by the Gateway.\n     */\n    function _callbackDecrypt(address bidder, uint256 clearValidatedPrice, uint256 clearWonQuantity) internal {\n        // Debug\n        require(bidder != address(0), \"Panic: bidder == 0\");\n\n        // reverts if already completed\n        _markClaimCompleted(bidder);\n\n        uint256 uniformPrice = clearUniformPrice();\n\n        // Debug\n        require(uniformPrice > 0, \"Panic: uniformPrice == 0\");\n\n        if (clearValidatedPrice == 0) {\n            // Debug\n            require(clearWonQuantity == 0, \"Panic: clearValidatedPrice == 0 && clearWonQuantity != 0\");\n        }\n\n        if (clearWonQuantity > 0) {\n            uint256 bidderDueAmount = uniformPrice * clearWonQuantity;\n\n            // Debug\n            require(bidderDueAmount > 0, \"Panic: bidderDueAmount == 0\");\n\n            // Debug\n            require(_balances[bidder] >= bidderDueAmount, \"Panic: _balances[bidder] < bidderDueAmount\");\n\n            // Pay beneficiary\n            _withdrawPaymentTo(bidder, beneficiary(), bidderDueAmount);\n        } else {\n            // if the bid was invalid, transfer a penalty fee.\n            if (clearValidatedPrice == 0) {\n                uint256 penalty = paymentPenalty();\n                if (penalty > 0) {\n                    // Pay penalty to beneficiary\n                    _withdrawPaymentTo(bidder, beneficiary(), penalty);\n                }\n            }\n        }\n\n        uint256 remaining = _balances[bidder];\n        if (remaining > 0) {\n            // Give back remaining balance to bidder (minus penalty)\n            _withdrawPayment(bidder, remaining);\n        }\n\n        // Debug\n        require(_balances[bidder] == 0, \"Panic: _balances[bidder] > 0\");\n\n        if (clearWonQuantity > 0) {\n            // Transfer auction tokens to winner\n            _transferAuctionTokenTo(bidder, clearWonQuantity);\n        }\n    }\n\n    /**\n     * @notice Overrides the `FHEAuctionBase._bid` function to enforce a minimum deposit requirement before placing a bid.\n     * The function reverts if the caller's deposit balance is insufficient to meet the auction's minimum required amount.\n     *\n     * @dev See {FHEAuctionBase-_bid}\n     */\n    function _bid(address bidder, einput inPrice, einput inQuantity, bytes calldata inputProof)\n        internal\n        virtual\n        override\n    {\n        _requireSufficientBalance(_balances[bidder]);\n        super._bid(bidder, inPrice, inQuantity, inputProof);\n    }\n\n    /**\n     * @dev See {FHEAuctionBase-_cancelBid}.\n     */\n    function _cancelBid(address bidder) internal virtual override {\n        _withdrawPayment(bidder, _balances[bidder]);\n        super._cancelBid(bidder);\n    }\n\n    /**\n     * @notice Allows the caller to withdraw `amount` of payment tokens previously deposited into the auction contract\n     * as collateral for placing bids. If the withdrawal causes the caller's bid value (`price * quantity`) to fall\n     * below the required balance at the end of the auction, a penalty fee will be applied\n     * (see {FHEAuctionBase-paymentPenalty}).\n     *\n     * @dev Requirements:\n     * - If the caller has already placed a bid, the auction must be open and currently accepting bids.\n     * - If the caller has not placed any bid, the auction must have started.\n     * - The function reverts if the withdrawal causes the caller's remaining deposit balance to fall below the minimum\n     *   deposit required by the auction.\n     *\n     * @param amount The amount of payment tokens to withdraw.\n     */\n    function withdraw(uint256 amount) public nonReentrant whenStarted {\n        address bidder = msg.sender;\n        bool registered = _registered(bidder);\n\n        uint256 balance = _balances[bidder];\n        uint256 maxWithdrawAmount = balance;\n        uint256 minDeposit = minimumDeposit();\n\n        if (registered) {\n            _requireIsOpen();\n\n            if (balance < minDeposit) {\n                // Debug\n                require(balance == 0, \"Panic: balance > 0 && balance < minDeposit\");\n                return;\n            }\n\n            maxWithdrawAmount -= minDeposit;\n        }\n\n        if (amount > maxWithdrawAmount) {\n            amount = maxWithdrawAmount;\n        }\n\n        if (amount == 0) {\n            return;\n        }\n\n        _withdrawPayment(bidder, amount);\n\n        // Debug\n        if (registered) {\n            require(_balances[bidder] >= minDeposit, \"Panic: _balances[bidder] < minDeposit\");\n        }\n    }\n\n    /**\n     * @notice Transfers `amount` of payment tokens from the bidder's deposit in the auction contract to the bidder's\n     * own address.\n     *\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\n     * @param amount The amount of payment tokens to withdraw and transfer back to the bidder.\n     */\n    function _withdrawPayment(address bidder, uint256 amount) internal {\n        _withdrawPaymentTo(bidder, bidder, amount);\n    }\n\n    /**\n     * @dev Internal function without access restriction. Transfers `amount` of payment tokens from the bidder's\n     * deposit in the auction contract to the specified address `to`.\n     *\n     * @dev This function updates the bidder's deposit balance before performing the transfer and handles the token\n     * transfer to the specified recipient.\n     *\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\n     * @param to The address to which the payment tokens will be sent.\n     * @param amount The amount of payment tokens to withdraw and transfer.\n     */\n    function _withdrawPaymentTo(address bidder, address to, uint256 amount) internal {\n        _updatePaymentTokenBeforeWithdraw(bidder, amount);\n        _transferPaymentTokenTo(to, amount);\n    }\n\n    /**\n     * @notice Updates the bidder's balance before a withdraw operation.\n     * This is an internal function with no access restrictions.\n     *\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\n     * @param amount The amount of payment tokens to withdraw and transfer.\n     */\n    function _updatePaymentTokenBeforeWithdraw(address bidder, uint256 amount) internal {\n        _balances[bidder] -= amount;\n    }\n\n    /**\n     * @notice Updates the bidder's balance after a deposit operation.\n     * This is an internal function with no access restrictions.\n     *\n     * @param bidder The address of the bidder whose balance is being updated.\n     * @param amount The amount of payment tokens deposited.\n     */\n    function _updatePaymentTokenAfterDeposit(address bidder, uint256 amount) internal {\n        _balances[bidder] += amount;\n    }\n\n    /**\n     * @dev Abstract function to be implemented by derived contracts.\n     * It allows for the inclusion of custom logic for transferring payment tokens to a specified address.\n     * Derived contracts should provide the specific implementation for how the transfer should be handled\n     * (e.g., native Eth or ERC20 token transfer).\n     *\n     * @param to The address receiving the transferred payment tokens.\n     * @param amount The amount of payment tokens to be transferred.\n     */\n    function _transferPaymentTokenTo(address to, uint256 amount) internal virtual;\n\n    /**\n     * @dev Abstract function to be implemented by derived contracts.\n     * This function should return the balance of payment tokens owned by a specified address (`account`).\n     * @param account The address for which the payment token balance is being queried.\n     * @return The balance of payment tokens owned by the `account`.\n     */\n    function _paymentTokenBalanceOf(address account) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/auctions/FHEAuctionBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint16, euint256, einput} from \"fhevm/lib/TFHE.sol\";\nimport {SepoliaZamaFHEVMConfig} from \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport {SepoliaZamaGatewayConfig} from \"fhevm/config/ZamaGatewayConfig.sol\";\nimport {Gateway, GatewayCaller} from \"fhevm/gateway/GatewayCaller.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {TimedAuction} from \"../TimedAuction.sol\";\nimport {IFHEAuctionEngine} from \"../engines/IFHEAuctionEngine.sol\";\nimport {FHEAuctionEngineIterator} from \"../engines/FHEAuctionEngineIterator.sol\";\n\n/**\n * @dev Abstract contract for implementing a Single Price Auction.\n * This implementation is payment-agnostic, supporting various types of payments such as Ether, ERC20 tokens, \n * or encrypted ERC20 tokens. As a result, a payment or deposit locking mechanism must be implemented in a derived \n * contract.\n *\n * Provides fundamental auction functionality, including:\n * - Initialization\n * - Auction timing (open/close states)\n * - Bid placement and canceling\n * - Prize claiming by bidders\n * - Auction termination\n *\n * The contract interacts with a separate `TFHEAuctionEngine` contract, which is responsible for:\n * - Validating bids\n * - Ranking bids\n * - Computing the final prize for each bidder\n */\nabstract contract FHEAuctionBase is\n    SepoliaZamaFHEVMConfig,\n    SepoliaZamaGatewayConfig,\n    TimedAuction,\n    Ownable,\n    ReentrancyGuard,\n    GatewayCaller\n{\n    uint8 constant CLAIMED = 1;\n\n    struct Bid {\n        euint256 price;\n        euint256 quantity;\n    }\n\n    uint256 private immutable _paymentPenalty;\n    uint256 private immutable _minimumPaymentDeposit;\n\n    address private _engine;\n    ///@dev _iterator == _engine.iterator(). \n    ///@dev We keep a copy in order to minimize contract loading when calling progress-related view functions.\n    address private _iterator;\n    address private _beneficiary;\n    IERC20 private _auctionToken;\n    uint256 private _clearUniformPrice;\n\n    uint16 private _blindClaimRequestCount;\n    uint16 private _claimCompletedCount;\n    uint16 private _blindClaimCompletedCount;\n\n    mapping(address bidder => uint16) private _bidderToBlindClaimRankPlusOne;\n    mapping(address bidder => uint8) private _claimCompleted;\n    mapping(uint16 rank => uint8) private _blindClaimCompleted;\n    mapping(address bidder => Bid) private _bidderToBid;\n\n    error BidderNotRegistered(address bidder);\n    error DepositFailed(address token, address from, uint256 amount);\n    error WithdrawFailed();\n    error InvalidEngine(address engine);\n    error InvalidBeneficiary(address beneficiary);\n    error InvalidAuctionToken(address token);\n    error InvalidAuctionQuantity(uint256 quantity);\n    error InvalidTieBreakingRule(uint8 tieBreakingRule);\n    error AlreadyClaimed(address bidder);\n    error NotReadyToClaim(address bidder);\n    error RankAlreadyClaimed(uint16 rank);\n    error NotReadyToClaimRank();\n    error UniformPriceNotReadyToDecrypt();\n\n    /**\n     * @notice Thrown when the account's payment token balance is insufficient to perform the operation.\n     *\n     * @param balance The current payment token balance of the account.\n     * @param needed The required payment token balance to complete the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @notice Thrown when the payment penalty exceeds the requested minimum payment token balance.\n     *\n     * @param minimumBalance The required minimum payment token balance.\n     * @param penalty The payment penalty that triggered the error.\n     */\n    error PaymentPenaltyTooHigh(uint256 minimumBalance, uint256 penalty);\n\n    /**\n     * @notice Emitted when a batch of auction computation cycles has been processed.\n     *\n     * @param requestedIter The number of computation cycles requested.\n     * @param statusCode A status code indicating the result of the computation.\n     * @param startIterProgress The total number of computation cycles completed before this function call.\n     * @param endIterProgress The total number of computation cycles completed after this function call.\n     */\n    event ComputeAuctionCycles(\n        uint64 requestedIter, uint8 statusCode, uint64 startIterProgress, uint64 endIterProgress\n    );\n\n    /**\n     * @notice Reverts if `paymentPenalty_` exceeds `minimumPaymentDeposit_`.\n     * Ensures the auction retains sufficient payment tokens to cover any penalty fees.\n     *\n     * @param minimumPaymentDeposit_ The minimum amount of payment tokens a bidder must deposit before placing any bid.\n     * @param paymentPenalty_ The amount of payment tokens transferred to the auction's {beneficiary} for each invalid bid.\n     */\n    constructor(uint256 minimumPaymentDeposit_, uint256 paymentPenalty_) Ownable(msg.sender) {\n        if (paymentPenalty_ > minimumPaymentDeposit_) {\n            revert PaymentPenaltyTooHigh(minimumPaymentDeposit_, paymentPenalty_);\n        }\n        _minimumPaymentDeposit = minimumPaymentDeposit_;\n        _paymentPenalty = paymentPenalty_;\n    }\n\n    /**\n     * @notice Returns `true` if the auction's payment token is the native EVM token\n     */\n    function isNative() public virtual pure returns (bool);\n\n    /**\n     * @notice Initializes the auction with a specified auction engine and parameters.\n     *\n     * @notice Requirements:\n     * - The auction must not already be initialized (see `_initialize`).\n     * - The caller must be the contract owner.\n     * - The `engine_`'s owner must be the current contract.\n     * - The `beneficiary_` must not be the zero address.\n     * - The `auctionToken_` must not be the zero address.\n     * - The `auctionQuantity_` must be strictly positive.\n     *\n     * @param engine_ Address of the auction engine used to compute auction prizes.\n     * @param beneficiary_ Address of the auction beneficiary who will receive the proceeds.\n     * @param auctionToken_ Address of the {IERC20} token being auctioned.\n     * @param auctionQuantity_ Total quantity of tokens to be auctioned.\n     * @param maxBidCount_ Maximum number of bids.\n     */\n    function initialize(address engine_, address beneficiary_, IERC20 auctionToken_, uint256 auctionQuantity_, uint16 maxBidCount_)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        if (engine_ == address(0) || Ownable(engine_).owner() != address(this)) {\n            revert InvalidEngine(engine_);\n        }\n        if (address(beneficiary_) == address(0)) {\n            revert InvalidBeneficiary(beneficiary_);\n        }\n        if (address(auctionToken_) == address(0)) {\n            revert InvalidAuctionToken(address(auctionToken_));\n        }\n        if (auctionQuantity_ == 0) {\n            revert InvalidAuctionQuantity(auctionQuantity_);\n        }\n\n        // reverts if the auction is already initialized.\n        _initialize();\n\n        _engine = engine_;\n        _beneficiary = beneficiary_;\n        _auctionToken = auctionToken_;\n\n        IFHEAuctionEngine(engine_).initialize(auctionQuantity_, maxBidCount_);\n\n        // Keep a copy of the iterator\n        _iterator = IFHEAuctionEngine(engine_).iterator();\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the caller is a registered bidder.\n     *\n     * @notice Requirements:\n     * - The auction must have started.\n     * - Must be used as a final modifier as it is not checking if the auction is initialized\n     */\n    modifier onlyBidder() {\n        _checkBidder();\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not a registered bidder\n     */\n    function _checkBidder() internal view virtual {\n        if (!_registered(msg.sender)) {\n            revert BidderNotRegistered(msg.sender);\n        }\n    }\n\n    /**\n     * @notice Returns true if `bidder` is a registered bidder\n     */\n    function _registered(address bidder) internal view returns (bool) {\n        return IFHEAuctionEngine(_engine).bidderId(bidder) != 0;\n    }\n\n    /**\n     * @notice Starts the auction. (see `TimedAuction._start`).\n     * At start, {auctionQuantity} tokens will be transferred from the {beneficiary} to the current auction contract as\n     * a deposit. If the auction contract is unable to execute the transfer operation, the function will revert.\n     *\n     * @notice Requirements:\n     * - The auction must be initialized.\n     * - The auction must not have already started.\n     * - The caller must be the auction contract owner.\n     * - The {beneficiary} must have approved the transfer of at least {auctionQuantity} tokens to\n     * the current auction contract.\n     *\n     * @param durationInSeconds The duration of the auction in seconds.\n     * @param stoppable Indicates whether the auction can be manually stopped.\n     */\n    function start(uint256 durationInSeconds, bool stoppable) external onlyOwner nonReentrant {\n        _start(durationInSeconds, stoppable);\n        _transferAuctionTokenFrom(_beneficiary, auctionQuantity());\n    }\n\n    /**\n     * @notice Closes the auction\n     *\n     * @notice Requirements:\n     * - The auction must be open (ie. accepting bids)\n     * - The auction must be `stoppable`\n     * - The caller must be the auction contract owner.\n     */\n    function stop() external onlyOwner nonReentrant {\n        _stop();\n        IFHEAuctionEngine(_engine).close();\n    }\n\n    /**\n     * @notice Performs a partial computation of the auction results, processing up to `iter` iterations.\n     * This function incrementally contributes to finalizing the auction outcome and is publicly accessible\n     * with no access restrictions.\n     *\n     * @dev Requirements:\n     * - The auction must be closed before computation can proceed.\n     *\n     * @param iter The maximum number of computation iterations to execute in this call.\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\n     * @return code A status code indicating the result of the computation:\n     *      - `0`: Additional iterations are required to complete the computation.\n     *      - `1`: The auction computation has successfully completed.\n     *      - `2`: Insufficient gas to continue processing.\n     * @return startIterProgress The total number of iterations completed before this function call.\n     * @return endIterProgress The total number of iterations completed after this function call.\n     *\n     * @dev The total number of iterations executed in this call is given by:\n     *      `endIterProgress - startIterProgress`.\n     */\n    function computeAuction(uint64 iter, bool stopIfReadyForBlindClaim)\n        external\n        whenClosed\n        nonReentrant\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\n    {\n        (code, startIterProgress, endIterProgress) =\n            IFHEAuctionEngine(_engine).computeAuctionIterations(iter, stopIfReadyForBlindClaim);\n        emit ComputeAuctionCycles(iter, code, startIterProgress, endIterProgress);\n    }\n\n    /**\n     * @notice Returns the auction computation iterations progress. \n     */\n    function computedIterations() external view returns (uint64) {\n        return FHEAuctionEngineIterator(_iterator).iterProgress();\n    }\n\n    /**\n     * @notice Returns the minimum number of computation iterations required to execute a blind claim.\n     * `minIterationsForBlindClaim()` < `minIterationsForClaim()`\n     */\n    function minIterationsForBlindClaim() external view returns (uint64) {\n        return FHEAuctionEngineIterator(_iterator).minIterationsForBlindClaim();\n    }\n\n    /**\n     * @notice Returns the minimum number of computation iterations required to execute a claim.\n     * `minIterationsForClaim()` > `minIterationsForBlindClaim()`\n     */\n    function minIterationsForClaim() external view returns (uint64) {\n        return FHEAuctionEngineIterator(_iterator).iterProgressMax();\n    }\n\n    /**\n     * @notice Reverts if `balance` is less than the required minimum deposit amount of payment tokens.\n     */\n    function _requireSufficientBalance(uint256 balance) internal view virtual {\n        if (balance < _minimumPaymentDeposit) {\n            revert InsufficientBalance(balance, _minimumPaymentDeposit);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the auction engine used to compute auction prizes. Returns the zero address if\n     * the auction is not yet initialized.\n     */\n    function engine() public view returns (address) {\n        return _engine;\n    }\n\n    /**\n     * @notice Returns the minimum amount of payment tokens a bidder must deposit before placing any bid.\n     */\n    function minimumDeposit() public view returns (uint256) {\n        return _minimumPaymentDeposit;\n    }\n\n    /**\n     * @notice Returns the penalty fee (in payment tokens) charged to a bidder for insufficient balance\n     * to pay their auction prize at the end of the auction.\n     */\n    function paymentPenalty() public view returns (uint256) {\n        return _paymentPenalty;\n    }\n\n    /**\n     * @notice Returns the address of the {IERC20} token being auctioned.\n     */\n    function auctionToken() public view returns (address) {\n        return address(_auctionToken);\n    }\n\n    /**\n     * @notice Returns the address of the auction beneficiary, who will receive the proceeds of the auction.\n     */\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @notice Returns the total amount of `auctionToken` available for auction.\n     */\n    function auctionQuantity() public view returns (uint256) {\n        return IFHEAuctionEngine(_engine).totalQuantity();\n    }\n\n    /**\n     * @notice Returns the maximum allowable price for each bid.\n     */\n    function maximumPrice() public view returns (uint256) {\n        return IFHEAuctionEngine(_engine).maximumPrice();\n    }\n\n    /**\n     * @notice Returns the total number of bidders.\n     */\n    function bidCount() public view returns (uint16) {\n        return IFHEAuctionEngine(_engine).getBidCount();\n    }\n\n    /**\n     * @notice Returns the maximum number of bidders\n     */\n    function maximumBidCount() public view returns (uint16) {\n        return IFHEAuctionEngine(_engine).getMaximumBidCount();\n    }\n\n    /**\n     * @notice Returns the encrypted bid of the caller.\n     * @return price The unit price (encrypted) that the caller has offered to pay per token being auctioned.\n     * @return quantity The total quantity (encrypted) of tokens the caller has bidded for.\n     */\n    function getBid() public view returns (euint256 price, euint256 quantity) {\n        price = _bidderToBid[msg.sender].price;\n        quantity = _bidderToBid[msg.sender].quantity;\n    }\n\n    /**\n     * @notice Returns `true` if the caller is a registered bidder, `false` othewise.\n     */\n    function registered() public view returns (bool) {\n        return _registered(msg.sender);\n    }\n\n    /**\n     * @notice Retrieves the bidder address associated with the specified bid ID.\n     * @param id The ID of the bid to retrieve.\n     * @return bidder The address of the bidder.\n     */\n    function _getBidderById(uint16 id) internal view returns (address) {\n        return IFHEAuctionEngine(_engine).getBidderById(id);\n    }\n\n    /**\n     * @notice Places a bid with encrypted values.\n     * @param inPrice The encrypted unit price the caller offers to pay per token being auctioned.\n     * @param inQuantity The encrypted total quantity of tokens the caller is bidding for.\n     * @param inputProof The fhEVM proof for the encrypted input.\n     *\n     * Requirements:\n     * - The auction must be open and accepting bids.\n     * - The caller must not have already placed a bid.\n     */\n    function bid(einput inPrice, einput inQuantity, bytes calldata inputProof) external nonReentrant whenIsOpen {\n        _bid(msg.sender, inPrice, inQuantity, inputProof);\n    }\n\n    /**\n     * @notice Internal function without access restriction.\n     * @param bidder address of the bidder\n     * @param inPrice The encrypted unit price the `bidder` offers to pay per token being auctioned.\n     * @param inQuantity The encrypted total quantity of tokens the `bidder` is bidding for.\n     * @param inputProof The fhEVM proof for the encrypted input.\n     *\n     * Requirements:\n     * - The caller must not have already placed a bid.\n     *\n     * Gas cost: max 865_000, min 815_000\n     */\n    function _bid(address bidder, einput inPrice, einput inQuantity, bytes calldata inputProof) internal virtual {\n        Bid memory newBid =\n            Bid({price: TFHE.asEuint256(inPrice, inputProof), quantity: TFHE.asEuint256(inQuantity, inputProof)});\n\n        address engineAddr = _engine;\n        TFHE.allowTransient(newBid.price, engineAddr);\n        TFHE.allowTransient(newBid.quantity, engineAddr);\n\n        // will revert if `bidder` has already placed a bid\n        IFHEAuctionEngine(_engine).addBid(bidder, newBid.price, newBid.quantity);\n\n        TFHE.allow(newBid.price, bidder);\n        TFHE.allow(newBid.quantity, bidder);\n        TFHE.allowThis(newBid.price);\n        TFHE.allowThis(newBid.quantity);\n\n        _bidderToBid[bidder] = newBid;\n    }\n\n    /**\n     * @notice Returns `true` if the caller's auction prize is ready to be claimed, `false` otherwise.\n     *\n     * @notice Requirements:\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\n     * - The caller must be a registered bidder.\n     * - see {_canClaim} for additional requirements.\n     */\n    function canClaim() public view whenClosed onlyBidder returns (bool) {\n        return _canClaim(msg.sender);\n    }\n\n    /**\n     * @notice Returns `true` if the bidder can claim their auction prize, `false` otherwise.\n     * Internal function without access restriction.\n     * This function is meant to be overriden to add extra conditions for a successfull claim.\n     *\n     * @notice Conditions for a successful claim:\n     * - All bidders' won quantities have been computed by the auction `_engine`.\n     * - The `bidder` has not yet claimed their prize.\n     *\n     * @param bidder address of the bidder\n     */\n    function _canClaim(address bidder) internal view virtual returns (bool) {\n        if (claimCompleted(bidder)) {\n            // Cannot claim twice\n            return false;\n        }\n\n        if (!IFHEAuctionEngine(_engine).canClaim()) {\n            // Computation is not complete\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Claim the caller's won quantity of token sold in the auction at the final uniform price\n     *\n     * @notice Requirements:\n     * - The auction must be closed.\n     * - All bidders won quantities must have been computed by the auction engine.\n     * - The caller sould not have already successfully claimed its price.\n     */\n    function claim() external nonReentrant whenClosed {\n        address bidder = msg.sender;\n\n        uint16 id = IFHEAuctionEngine(_engine).bidderId(bidder);\n        if (id == 0) {\n            revert BidderNotRegistered(bidder);\n        }\n\n        if (claimCompleted(bidder)) {\n            // the prize has already been claimed successfully\n            revert AlreadyClaimed(bidder);\n        }\n\n        (euint256 validatedPrice, euint256 wonQuantity) =\n            IFHEAuctionEngine(_engine).validatedPriceAndWonQuantityById(id);\n        if (euint256.unwrap(wonQuantity) == 0) {\n            revert NotReadyToClaim(bidder);\n        }\n\n        _claim(bidder, id, validatedPrice, wonQuantity);\n    }\n\n    /**\n     * @dev Abstract internal function to process a claim for the bid placed by bidder `bidder`.\n     * Must be implemented by derived contracts to handle claims based on the bidder address, clear ID,\n     * encrypted validated price, and encrypted won quantity.\n     */\n    function _claim(address bidder, uint16 id, euint256 validatedPrice, euint256 wonQuantity) internal virtual;\n\n    /**\n     * @notice Returns `true` if the `bidder` has successfully claimed their auction prize, `false` otherwise.\n     * @param bidder The address of the bidder whose claim status is being checked.\n     * @return completed A boolean indicating whether the bidder's auction prize has been successfully claimed.\n     */\n    function claimCompleted(address bidder) public view returns (bool) {\n        return _claimCompleted[bidder] == CLAIMED;\n    }\n\n    /**\n     * @notice Returns the number of completed claims.\n     */\n    function totalClaimsCompleted() public view returns(uint16) {\n        return _claimCompletedCount; \n    }\n\n    /**\n     * @notice Returns the total number of blind claim requests made so far.\n     *\n     * The number of remaining bidders who have not yet performed a blind claim can be calculated as:\n     * `bidCount() - totalBlindClaimsRequested()`.\n     */\n    function totalBlindClaimsRequested() public view returns(uint16) {\n        return _blindClaimRequestCount; \n    }\n\n    /**\n     * @notice Marks the claim as completed for the specified bidder.\n     *\n     * This function updates the internal state to reflect that the bidder has successfully claimed\n     * their auction prize. It will revert if the bidder has already claimed their prize.\n     *\n     * @notice Requirements:\n     * - The bidder must not have already completed the claim.\n     *\n     * @param bidder The address of the bidder whose claim is being marked as completed.\n     */\n    function _markClaimCompleted(address bidder) internal {\n        if (claimCompleted(bidder)) {\n            revert AlreadyClaimed(bidder);\n        }\n        _claimCompleted[bidder] = CLAIMED;\n        _claimCompletedCount++;\n    }\n\n    /**\n     * @notice Returns `true` if the auction is ready for blind claim, `false` otherwise.\n     *\n     * @notice Conditions for a successful blind claim:\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\n     * - The engine must be ready for blind claim.\n     * - The caller must be a registered bidder.\n     */\n    function canBlindClaim() public view whenClosed onlyBidder returns (bool) {\n        return IFHEAuctionEngine(_engine).canBlindClaim();\n    }\n\n    /**\n     * @notice Returns `true` if the auction prize ranked at position `rank` is ready to be claimed, `false` otherwise.\n     *\n     * @notice Requirements:\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\n     * - see {_canBlindClaimRank} for additional requirements.\n     *\n     * @param rank The zero-based rank of the unidentified bidder for whom the prize is being claimed.\n     */\n    function canBlindClaimRank(uint16 rank) public view whenClosed returns (bool) {\n        return _canBlindClaimRank(rank);\n    }\n\n    /**\n     * @notice Returns `true` the auction prize ranked at position `rank` is ready to be claimed, `false` otherwise.\n     * Internal function without access restriction.\n     * This function is meant to be overriden to add extra conditions for a successfull claim.\n     *\n     * @notice Conditions for a successful claim:\n     * - All ranked won quantities have been computed by the auction `_engine`.\n     * - The prize at rank position `rank` has not yet been claimed.\n     *\n     * @param rank The zero-based rank of the unidentified bidder for whom the prize is being claimed.\n     */\n    function _canBlindClaimRank(uint16 rank) internal view virtual returns (bool) {\n        if (blindClaimRankCompleted(rank)) {\n            // Cannot claim rank twice\n            return false;\n        }\n\n        if (!IFHEAuctionEngine(_engine).canBlindClaim()) {\n            // Computation is not complete\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Allows a registered bidder to claim the auction prize on behalf of an anonymous bidder ranked at \n     * position `rank`. The prize is awarded to the unidentified bidder at the final uniform price determined \n     * by the auction. The caller acts as an intermediary and does not directly receive the prize.  \n     *\n     * @dev Requirements:\n     * - The caller must be a registered bidder.\n     * - The auction must be closed.\n     * - The auction engine must have finalized the computation of winning quantities for all bidders.\n     * - The specified rank must not have already been claimed.\n     *\n     * @dev Each bidder is assigned a unique and constant claim rank. A bidder can claim the same rank multiple times. \n     * If the bidder has not yet requested a blind claim, they are assigned the next available claim rank.  \n     */\n    function blindClaim() external nonReentrant whenClosed {\n        address bidder = msg.sender;\n\n        uint16 blindRankPlusOne = _bidderToBlindClaimRankPlusOne[bidder];\n\n        if (blindRankPlusOne == 0) {\n            uint16 id = IFHEAuctionEngine(_engine).bidderId(bidder);\n            if (id == 0) {\n                revert BidderNotRegistered(bidder);\n            }\n\n            blindRankPlusOne = _blindClaimRequestCount + 1;\n            _bidderToBlindClaimRankPlusOne[bidder] = blindRankPlusOne;\n            _blindClaimRequestCount = blindRankPlusOne;\n        }\n\n        if (blindClaimRankCompleted(blindRankPlusOne - 1)) {\n            return;\n        }\n\n        _blindClaimRank(blindRankPlusOne - 1);\n    }\n\n    /**\n     * @notice Returns `true` if the caller has already executed a blind claim, `false` otherwise.\n     */\n    function hasBlindClaimed() external view returns(bool) {\n        return _bidderToBlindClaimRankPlusOne[msg.sender] != 0;\n    }\n\n    /**\n     * @notice Returns `true` if the prize for the unidentified bidder assigned to the caller has been successfully\n     * claimed via {blindClaim}, `false` otherwise.\n     * @return completed `true` if the prize has been successfully claimed, `false` otherwise.\n     */\n    function blindClaimCompleted() external view returns(bool) {\n        uint16 blindRankPlusOne = _bidderToBlindClaimRankPlusOne[msg.sender];\n        if (blindRankPlusOne == 0) {\n            return false;\n        }\n        return blindClaimRankCompleted(blindRankPlusOne - 1);\n    }\n\n    /**\n     * @notice Blindly claims the auction prize on behalf of the unidentified bidder ranked at position `rank`.\n     * The prize is awarded to the bidder at the final uniform price determined by the auction.\n     * The caller acts as an intermediary and does not directly receive the prize.\n     *\n     * @dev Requirements:\n     * - The auction must be closed.\n     * - The auction engine must have computed the final won quantities for all bidders.\n     * - The specified rank must not have already been claimed.\n     *\n     * @param rank The zero-based rank of the bidder for whom the prize is being claimed.\n     */\n    function blindClaimRank(uint16 rank) external nonReentrant whenClosed {\n        if (blindClaimRankCompleted(rank)) {\n            revert RankAlreadyClaimed(rank);\n        }\n\n        _blindClaimRank(rank);\n    }\n\n    /**\n     * @dev Internal function to process a claim for the bid ranked at `rank`. This function is shared between\n     * {blindClaimRank} and {blindClaim}\n     */\n    function _blindClaimRank(uint16 rank) internal {\n        (euint16 id, euint256 validatedPrice, euint256 wonQuantity) = IFHEAuctionEngine(_engine).getWonBidByRank(rank);\n        if (euint256.unwrap(wonQuantity) == 0) {\n            revert NotReadyToClaimRank();\n        }\n\n        _claimRank(rank, id, validatedPrice, wonQuantity);\n    }\n\n    /**\n     * @dev Abstract internal function to process a claim for the bid ranked at `rank`.\n     * Must be implemented by derived contracts to handle claims based on the clear rank, encrypted ID,\n     * encrypted validated price, and encrypted won quantity.\n     */\n    function _claimRank(uint16 rank, euint16 id, euint256 validatedPrice, euint256 wonQuantity) internal virtual;\n\n    /**\n     * @notice Returns `true` if the prize for the unidentified bidder at the specified `rank` has been successfully\n     * claimed via {blindClaimRank}, `false` otherwise.\n     * @param rank The zero-based rank of the unidentified bidder.\n     * @return completed `true` if the prize has been successfully claimed, `false` otherwise.\n     */\n    function blindClaimRankCompleted(uint16 rank) public view returns (bool) {\n        return _blindClaimCompleted[rank] == CLAIMED;\n    }\n\n    function _markBlindClaimRankCompleted(uint16 rank) internal {\n        if (blindClaimRankCompleted(rank)) {\n            revert RankAlreadyClaimed(rank);\n        }\n        _blindClaimCompleted[rank] = CLAIMED;\n        _blindClaimCompletedCount++;\n    }\n\n    /**\n     * @dev See {TimedAuction-_canTerminateAfterStart}.\n     */\n    function _canTerminateAfterStart() internal view override returns (bool) {\n        return _claimCompletedCount == bidCount() || _blindClaimCompletedCount == bidCount();\n    }\n\n    /**\n     * @notice Terminates the auction.\n     * An auction can be terminated if it has not yet started, `bidCount` is zero, or all bids have been claimed.\n     * When terminated, all tokens being auctioned are transferred back to the `beneficiary`.\n     *\n     * @notice Requirements:\n     * - The caller must be the auction contract owner.\n     * - The auction must be in a terminable state (see `whenTerminable`).\n     */\n    function terminate() external onlyOwner nonReentrant {\n        _terminate();\n        _transferAuctionTokenTo(_beneficiary, _auctionToken.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Internal function with no access restrictions.\n     * Transfers `amount` of the auctioned tokens from the auction's contract account to the `to` address.\n     *\n     * @param to The recipient's address.\n     * @param amount The amount of auctioned tokens to transfer to the `to` address.\n     */\n    function _transferAuctionTokenTo(address to, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 balanceBefore = _auctionToken.balanceOf(to);\n        _auctionToken.transfer(to, amount);\n        uint256 balanceAfter = _auctionToken.balanceOf(to);\n\n        // Debug\n        require((balanceAfter - balanceBefore) == amount, \"Panic:(balanceAfter - balanceBefore) != amount\");\n    }\n\n    /**\n     * @dev Internal function with no access restrictions. Handles the transfer of `amount` ERC20 auction tokens\n     * from the `from`'s account into the auction contract.\n     *\n     * This function utilizes the ERC20 allowance mechanism and calls {IERC20-transferFrom} to transfer tokens\n     * from the source address to the auction contract. It assumes that the source address has approved the auction\n     * contract to spend the specified `amount` of tokens in advance.\n     *\n     * @param from The address of the source account.\n     * @param amount The amount of ERC20 tokens to be transferred.\n     */\n    function _transferAuctionTokenFrom(address from, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        IERC20 aToken = _auctionToken;\n        uint256 balanceBefore = aToken.balanceOf(address(this));\n        bool succeeded = aToken.transferFrom(from, address(this), amount);\n        if (!succeeded) {\n            revert DepositFailed(address(aToken), from, amount);\n        }\n        uint256 balanceAfter = aToken.balanceOf(address(this));\n\n        if (balanceAfter - balanceBefore != amount) {\n            revert DepositFailed(address(aToken), from, amount);\n        }\n    }\n\n    /**\n     * @notice Cancels the caller's bid.\n     *\n     * @notice Requirements:\n     * - The caller must be a registered bidder.\n     * - The auction must be open, meaning it is currently accepting bids.\n     */\n    function cancelBid() external nonReentrant whenIsOpen onlyBidder {\n        _cancelBid(msg.sender);\n    }\n\n    /**\n     * @notice Internal function without access restrictions.\n     * @dev This function is intended to be overridden in derived contracts to implement\n     * additional operations that should occur when a bid is canceled.\n     *\n     * @param bidder The address of the bidder whose bid is being canceled.\n     */\n    function _cancelBid(address bidder) internal virtual {\n        _bidderToBid[bidder] = Bid({price: euint256.wrap(0), quantity: euint256.wrap(0)});\n        IFHEAuctionEngine(_engine).removeBid(bidder);\n    }\n\n    /**\n     * @notice Returns the decrypted final uniform auction price. The function returns `0` if\n     * the auction is not completed and the price is not yet available. Non zero otherwise.\n     */\n    function clearUniformPrice() public view returns (uint256) {\n        return _clearUniformPrice;\n    }\n\n    /**\n     * @notice Returns `true` if the auction is ready to decrypt the final auction uniform price\n     *\n     * @notice Requirements:\n     * - The auction contract must be initialized.\n     */\n    function canDecryptUniformPrice() public view whenInitialized returns (bool) {\n        return IFHEAuctionEngine(_engine).canDecryptUniformPrice();\n    }\n\n    /**\n     * @notice Initiate the decryption of the auction final uniform price.\n     * @notice Requirements:\n     * - Can only be called after the auction ends and the uniform price has been computed by the engine\n     */\n    function decryptUniformPrice() public onlyOwner nonReentrant whenInitialized {\n        euint256 pu = IFHEAuctionEngine(_engine).getUniformPrice();\n        if (!TFHE.isInitialized(pu)) {\n            revert UniformPriceNotReadyToDecrypt();\n        }\n\n        // Debug\n        require(TFHE.isAllowed(pu, address(this)), \"Panic: TFHE.isAllowed(pu, address(this)) == false\");\n\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(pu);\n        Gateway.requestDecryption(cts, this.callbackDecryptUniformPrice.selector, 0, block.timestamp + 100, false);\n    }\n\n    /**\n     * @notice Callback function to set the decrypted auction final uniform price.\n     * @notice Can only be called by the Gateway\n     * @param resultDecryption The decrypted auction final uniform price\n     */\n    function callbackDecryptUniformPrice(uint256, /*requestID*/ uint256 resultDecryption) external onlyGateway {\n        _clearUniformPrice = resultDecryption;\n    }\n}\n"
    },
    "contracts/auctions/FHEAuctionERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {einput} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuction} from \"./FHEAuction.sol\";\nimport {FHEAuctionBase} from \"./FHEAuctionBase.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract FHEAuctionERC20 is FHEAuction {\n    IERC20 private immutable _paymentToken;\n\n    /**\n     * @dev See {FHEAuctionBase-constructor}\n     * @param paymentToken_ Address of the ERC20 payment token used for all auction deposits\n     */\n    constructor(uint256 minimumPaymentBalance_, uint256 paymentPenalty_, IERC20 paymentToken_)\n        FHEAuctionBase(minimumPaymentBalance_, paymentPenalty_)\n    {\n        require(address(paymentToken_) != address(0));\n        _paymentToken = paymentToken_;\n    }\n\n    /**\n     * @notice See {FHEAuctionBase-isNative}.\n     */\n    function isNative() public override pure returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Returns the ERC20 payment token used for all auction deposits\n     */\n    function paymentToken() public view returns (IERC20) {\n        return _paymentToken;\n    }\n\n    /**\n     * @notice Deposits a specified amount of payment tokens and places a bid with encrypted values in a single\n     * transaction.\n     *\n     * This function is designed to prevent scenarios where a bidder successfully deposits funds in one transaction but\n     * is unable to place a bid in a subsequent transaction because the auction has closed in the interim. By combining\n     * the deposit and bid actions, the function ensures seamless participation in the auction within a single\n     * operation.\n     *\n     * @notice Requirements:\n     * - The auction should be open (meaning accepting new bids)\n     * - See {FHEAuctionBase-bid} for bidding requirements.\n     *\n     * @param inPrice Encrypted input representing the bid price.\n     * @param inQuantity Encrypted input representing the bid quantity.\n     * @param inputProof Proof data required to validate the encrypted bid.\n     * @param depositAmount The clear amount of payment tokens to deposit.\n     */\n    function bidWithDeposit(einput inPrice, einput inQuantity, bytes calldata inputProof, uint256 depositAmount)\n        external\n        whenIsOpen\n        nonReentrant\n    {\n        address bidder = msg.sender;\n        _depositFrom(bidder, depositAmount);\n        _bid(bidder, inPrice, inQuantity, inputProof);\n    }\n\n    /**\n     * @notice Deposits a specified amount of ERC20 payment tokens to the caller's account into the auction contract.\n     * @notice Requirements:\n     * - The auction should be open (meaning accepting new bids)\n     */\n    function deposit(uint256 amount) external whenIsOpen nonReentrant {\n        _depositFrom(msg.sender, amount);\n    }\n\n    /**\n     * @dev Internal function with no access restrictions. Deposits `amount` of ERC20 payment tokens from the\n     * `bidder`'s ERC20 external account into their deposit balance within the auction contract.\n     *\n     * @param bidder The address of the bidder initiating the deposit.\n     * @param amount The amount of ERC20 payment tokens to be transferred and credited.\n     */\n    function _depositFrom(address bidder, uint256 amount) internal {\n        _transferPaymentTokenFrom(bidder, amount);\n        _updatePaymentTokenAfterDeposit(bidder, amount);\n    }\n\n    /**\n     * @dev Internal function with no access restrictions. Handles the transfer of `amount` ERC20 payment tokens\n     * from the `bidder`'s account into the auction contract.\n     *\n     * This function utilizes the ERC20 allowance mechanism and calls {IERC20-transferFrom} to transfer tokens\n     * from the bidder's address to the auction contract. It assumes that the bidder has approved the auction\n     * contract to spend the specified `amount` of tokens in advance.\n     *\n     * @param bidder The address of the bidder initiating the deposit.\n     * @param amount The amount of ERC20 tokens to be transferred.\n     */\n    function _transferPaymentTokenFrom(address bidder, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n        IERC20 pToken = _paymentToken;\n        uint256 balanceBefore = pToken.balanceOf(address(this));\n        bool succeeded = pToken.transferFrom(bidder, address(this), amount);\n        if (!succeeded) {\n            revert DepositFailed(address(pToken), bidder, amount);\n        }\n        uint256 balanceAfter = pToken.balanceOf(address(this));\n\n        if (balanceAfter - balanceBefore != amount) {\n            revert DepositFailed(address(pToken), bidder, amount);\n        }\n    }\n\n    /**\n     * @dev Transfers `amount` of ERC20 payment token to account `to`.\n     * @dev See {FHEAuction-_transferPaymentTokenTo}.\n     */\n    function _transferPaymentTokenTo(address to, uint256 amount) internal override {\n        uint256 balanceBefore = _paymentToken.balanceOf(address(this));\n        _paymentToken.transfer(to, amount);\n        uint256 balanceAfter = _paymentToken.balanceOf(address(this));\n\n        if (balanceBefore - balanceAfter != amount) {\n            revert WithdrawFailed();\n        }\n    }\n\n    /**\n     * @dev Returns the balance of ERC20 payment tokens owned by a specified address (`account`).\n     * @dev See {FHEAuction-_paymentTokenBalanceOf}.\n     */\n    function _paymentTokenBalanceOf(address account) internal view override returns (uint256) {\n        return _paymentToken.balanceOf(account);\n    }\n}\n"
    },
    "contracts/auctions/FHEAuctionNative.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {einput} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuction} from \"./FHEAuction.sol\";\nimport {FHEAuctionBase} from \"./FHEAuctionBase.sol\";\n\n//import {console} from \"hardhat/console.sol\";\n\ncontract FHEAuctionNative is FHEAuction {\n    /**\n     * @dev See {FHEAuctionBase-constructor}\n     */\n    constructor(uint256 minimumPaymentBalance, uint256 paymentPenalty)\n        FHEAuctionBase(minimumPaymentBalance, paymentPenalty)\n    {}\n\n    /**\n     * @dev See {FHEAuctionBase-isNative}.\n     */\n    function isNative() public override pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Deposits a specified amount of ETH and places a bid with encrypted values in a single\n     * transaction.\n     *\n     * @notice See {FHEAuctionERC20-bidWithDeposit}\n     */\n    function bidWithDeposit(einput inPrice, einput inQuantity, bytes calldata inputProof)\n        external\n        payable\n        whenIsOpen\n        nonReentrant\n    {\n        address bidder = msg.sender;\n        uint256 newBalance = balanceOf(bidder) + msg.value;\n        _requireSufficientBalance(newBalance);\n        _updatePaymentTokenAfterDeposit(bidder, msg.value);\n\n        _bid(bidder, inPrice, inQuantity, inputProof);\n    }\n\n    /**\n     * @notice Deposits a specified amount of ETH to the caller's account into the auction contract.\n     * @notice Requirements:\n     * - The auction should be open (meaning accepting new bids)\n     */\n    function deposit() external payable whenIsOpen nonReentrant {\n        _updatePaymentTokenAfterDeposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Transfers `amount` of ETH from the auction contract account to account `to`.\n     * @dev See {FHEAuction-_transferPaymentTokenTo}.\n     */\n    function _transferPaymentTokenTo(address to, uint256 amount) internal override {\n        // Native withdraw\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) {\n            revert WithdrawFailed();\n        }\n    }\n\n    /**\n     * @dev Returns the balance of ETH owned by a specified address (`account`).\n     * @dev See {FHEAuction-_paymentTokenBalanceOf}.\n     */\n    function _paymentTokenBalanceOf(address account) internal view override returns (uint256) {\n        return account.balance;\n    }\n}\n"
    },
    "contracts/auctions/IFHEAuction.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {IFHEAuctionBase} from \"./IFHEAuctionBase.sol\";\n\ninterface IFHEAuction is IFHEAuctionBase {\n    function balanceOf(address bidder) external view returns (uint256);\n}\n"
    },
    "contracts/auctions/IFHEAuctionBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {ITimedAuction} from \"../ITimedAuction.sol\";\n\ninterface IFHEAuctionBase is ITimedAuction {}\n"
    },
    "contracts/engines/factories/FHEAuctionEngineFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIterator} from \"../FHEAuctionEngineIterator.sol\";\nimport {FHEAuctionEngineIteratorFactory} from \"./FHEAuctionEngineIteratorFactory.sol\";\n\nabstract contract FHEAuctionEngineFactory is Ownable2Step {\n    FHEAuctionEngineIteratorFactory _iteratorFactory;\n\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) Ownable(msg.sender) {\n        _iteratorFactory = iteratorFactory_;\n    }\n\n    /**\n     * @dev Deploys a new FHEAuctionEngine contract.\n     * - engine.owner() == `auctionAddr`\n     */\n    function createNewEngine(address auctionAddr) public returns (address) {\n        // Constructor requirements:\n        // - iterator.owner() == engine.owner()\n        // Runtime requirements:\n        // - iterator.owner() == address(engine)\n        // - engine.owner() == auctionAddr\n        address iteratorAddr = _iteratorFactory.createNewIterator(address(this));\n        address engineAddr = _createNewEngine(address(this), iteratorAddr);\n        Ownable(iteratorAddr).transferOwnership(engineAddr);\n        Ownable(engineAddr).transferOwnership(auctionAddr);\n        return engineAddr;\n    }\n\n    /**\n     * @dev Abstract function, should be implemented by derived contracts\n     */\n    function _createNewEngine(address auction_, address iterator_) internal virtual returns (address);\n}\n"
    },
    "contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIterator} from \"../FHEAuctionEngineIterator.sol\";\nimport {FHEAuctionEngine} from \"../FHEAuctionEngine.sol\";\n\ncontract FHEAuctionEngineIteratorFactory is Ownable2Step {\n    constructor() Ownable(msg.sender) {}\n\n    function createNewIterator(address initialOwner) public virtual returns (address) {\n        FHEAuctionEngineIterator iterator = new FHEAuctionEngineIterator(initialOwner);\n        return address(iterator);\n    }\n}\n"
    },
    "contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"./FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEngineFactory} from \"./FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionEnginePriceId} from \"../FHEAuctionEnginePriceId.sol\";\n\ncontract FHEAuctionEnginePriceIdFactory is FHEAuctionEngineFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal virtual override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceId engine = new FHEAuctionEnginePriceId(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/engines/factories/FHEAuctionEnginePriceQuantityIdFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"./FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEngineFactory} from \"./FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionEnginePriceQuantityId} from \"../FHEAuctionEnginePriceQuantityId.sol\";\n\ncontract FHEAuctionEnginePriceQuantityIdFactory is FHEAuctionEngineFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal virtual override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceQuantityId engine = new FHEAuctionEnginePriceQuantityId(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/engines/factories/FHEAuctionEnginePriceRandomFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"./FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEngineFactory} from \"./FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionEnginePriceRandom} from \"../FHEAuctionEnginePriceRandom.sol\";\n\ncontract FHEAuctionEnginePriceRandomFactory is FHEAuctionEngineFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal virtual override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceRandom engine = new FHEAuctionEnginePriceRandom(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/engines/factories/FHEAuctionEngineProRataFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"./FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEngineFactory} from \"./FHEAuctionEngineFactory.sol\";\nimport {FHEAuctionEngineProRata} from \"../FHEAuctionEngineProRata.sol\";\n\ncontract FHEAuctionEngineProRataFactory is FHEAuctionEngineFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal virtual override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEngineProRata engine = new FHEAuctionEngineProRata(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEngine.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IFHEAuctionEngine} from \"./IFHEAuctionEngine.sol\";\nimport {IFHEAuction} from \"../auctions/IFHEAuction.sol\";\nimport {FHEAuctionEngineIterator} from \"./FHEAuctionEngineIterator.sol\";\nimport {\n    FourStepsIterator,\n    IFourStepsIterable,\n    S_FINISHED,\n    S_NOT_FINISHED,\n    E_NOT_ENOUGH_GAS\n} from \"../FourStepsIterator.sol\";\n\n/**\n * @notice ## Engine Architecture\n *\n * ### Incremental Computation\n *\n * - A uniform price auction requires an FHE-based sorting operation, which has a computational complexity\n *   of O(N^2), where N is the number of bidders. As a result, the overall auction computation consumes\n *   a significant amount of both native and FHE gas.\n *\n * - To overcome these gas cost limitations, the implementation adopts an incremental batch-processing mechanism,\n *   allowing the full computation to be executed iteratively across multiple smaller transactions, rather\n *   than in a single execution. This ensures computations remain gas-efficient and\n *   prevents exceeding blockchain transaction limits as well as fhEVM limits.\n *\n * - Since the auction results cannot be determined in a single transaction, a dedicated contract,\n *   {FHEAuctionEngineIterator}, is responsible for managing the paging mechanism. It orchestrates the\n *   progressive execution of auction computation cycles until completion.\n *\n * - A drawback of such iterative approach is the extra native gas cost required to read/write additional state \n *   variables required to save the computation status between two consecutive computation transactions.\n *\n * ### Contract Size Limit\n *\n * Due to the maximum contract size restrictions, the auction engine is modularized across multiple contracts:\n *\n * - Core Engine: `FHEAuctionEngine`, the base contract.\n * - Tie-Breaking Implementations: Four specialized contracts inherit from `FHEAuctionEngine`, each\n *   implementing a different tie-breaking rule:\n *      - `FHEAuctionEnginePriceId`\n *      - `FHEAuctionEnginePriceQuantityId`\n *      - `FHEAuctionEnginePriceRandom`\n *      - `FHEAuctionEngineProRata`\n * - Computation Manager: `FHEAuctionEngineIterator`, responsible for orchestrating the incremental\n *   computation process.\n *\n * @notice ## Algorithm for Bid Validation and Ranking\n *\n * ### Approach\n *\n * A bit-level strategy would have been optimal in terms of FHE cost; however, the resulting native gas cost \n * would be overwhelming. The primary reason is that the current version of TFHE library lacks batch functions \n * or high-level bitwise operations (such as array manipulations or tensor operations). \n * As a result, a more \"brute force\" approach manipulating encrypted integers is necessary.\n *\n * The algorithm consists in 4 steps, with the last one beeing optional. \n *\n *  |  Steps                     |  Cost    | \n *  |----------------------------|----------|\n *  |  1. Bid validation         |  O(N)    |\n *  |  2. Bid ranking            |  O(N^2)  |\n *  |  3. Won Quantities by rank |  O(N)    | \n *  |  4. Won Quantities by id   |  O(N^2)  |\n *   \n * ### Step 1: Bid validation. O(N)\n *\n * The first step is to sanitize the list of registered bids by evaluating each one individually. If a bid fails to meet\n * the engine's validation criteria, it is marked as invalid, with both the price and quantity set to zero\n * (i.e., `price = 0` and `quantity = 0`).\n *\n * Registered bids are indexed starting from `1` up to `bidCount`. Therefore, an index of `0` indicates that no bid\n * exists. For each valid bid at index `i` (where `1 <= i <= bidCount`), the following two conditions must always hold:\n *\n * 1. `0 < price(i) <= Maximum Price`\n * 2. `0 < quantity(i) <= Total Quantity`\n *\n * ### Step 2: Bid ranking (sort). O(N^2)\n *\n * - In this step, we determine the price and quantity of the bid ranked at position `k`, where `k` ranges from `0` to\n * `bidCount - 1`. The bid ranked at position `0` is the highest-ranked bid, which is determined based on the selected\n * ranking criteria. The ranking is strict, meaning no two bids can share the same rank. To achieve this, the bid\n * set is provided with a strict order relation, ensuring a clear distinction between each bid's position in the ranking.\n *\n * - The final list of ranked bids is constructed through an iterative process. Specifically, the bid at index `k+1` is\n * inserted into an existing list of ranked bids of length `k`, resulting in a new list of length `k+1`. During each\n * insertion, the bid is placed in its correct position, ensuring that the relationship `Bid(k) > Bid(k+1)` holds true\n * according to the selected comparison criteria.\n *\n * - The comparison function used to rank bids depends on two factors: the bid price and the auction engine's specified\n * tie-breaking rule. This ensures that bids are ranked in a consistent and predictable manner.\n *\n * - Finally, the computational complexity of this bid ranking operation is `N(N-1)/2 = O(N^2)`, where `N` represents the\n * total number of bids. This complexity arises from the need to perform pairwise comparisons and insert each bid into the\n * correct position within the sorted list.\n *\n * ### Step 3: Ranked bid won quantities and uniform price calculation. O(N)\n *\n * - In the third step, we determine the final quantity for the bid ranked at position `k`, where `k` ranges from `0` to\n * `bidCount - 1`, as well as the auction's final uniform price. A winning bid will have a strictly positive quantity,\n * while a losing bid will have a quantity of zero.\n *\n * - Since the bids are ranked in strict order, the quantity for each winning bid can be determined deterministically,\n * without the need for tie-breaking.\n *\n * - The uniform price is calculated as the price of the lowest winning bid.\n *\n * - The computational complexity O(N), linear in the number of bids.\n *\n * ### Step 4 (Optional): Inverting ranking to index vector. O(N^2)\n *\n * - This step generates an index vector that maps the ranking of bids back to their original positions in the\n * ranked list. Each position in the index vector corresponds to the original index of a bid in the ranked list.\n *\n * - The purpose of this step is to facilitate lookup or processing based on the original bid order.\n *\n * - This step is optional and can be skipped to minimize computation cost and if auction prizes can delivered directly\n * based on ranking positions rather than requiring bidder addresses.\n */\nabstract contract FHEAuctionEngine is SepoliaZamaFHEVMConfig, Ownable, IFourStepsIterable, IFHEAuctionEngine {\n    uint256 public constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    uint256 public constant MIN_GAS_PER_BV_CYCLE = 165_000;\n    uint256 public constant MIN_GAS_PER_RB_CYCLE = 420_000;\n    uint256 public constant MIN_GAS_PER_RWQ_CYCLE = 250_000;\n    uint256 public constant MIN_GAS_PER_WQ_CYCLE = 160_000;\n\n    euint256 constant DUMMY_EUINT256_MEMORY = euint256.wrap(uint32(0xdeadbeef));\n    euint16 constant DUMMY_EUINT16_MEMORY = euint16.wrap(uint32(0xdeadbeef));\n\n    enum TieBreakingRule {\n        PriceId,\n        PriceQuantityId,\n        PriceRandom,\n        ProRata\n    }\n\n    struct ABid {\n        euint256 price;\n        euint256 quantity;\n        euint256 rand;\n        euint16 id;\n    }\n\n    FHEAuctionEngineIterator _iterator;\n\n    uint256 private _totalQuantity;\n    TieBreakingRule private _tieBreakingRule;\n    bool private _auctionIsClosed;\n\n    uint16 private _maxBidCount;\n    uint16 private _bidCount;\n    uint16 private _nextId;\n\n    // 1 <= id < _nextId\n    mapping(address bidder => uint16 id) private _bidderToId;\n    mapping(uint16 id => address bidder) private _idToBidder;\n\n    // 1 <= idxPlusOne <= _bidCount\n    mapping(uint16 idxPlusOne => uint16 id) private _indexPlusOneToId;\n    mapping(uint16 id => uint16 idxPlusOne) private _idToIndexPlusOne;\n\n    // 1 <= id < _nextId\n    mapping(uint16 id => ABid bid) private _idToBid;\n\n    euint256 private _cumulativeQuantity;\n    euint256 private _uniformPrice;\n\n    ///@dev A precomputed zero euint256 to minimize the `TFHE.asEuint256(0)` calls \n    euint256 private immutable _eZeroU256;\n\n    // Step 2: Bid ranking. O(N^2)\n    // ===========================\n\n    ///@dev Index from which the computation of step #2 should resume.\n    uint16 private _resumeIdxRB;\n\n    ///@dev Temporary saved did data required when the computation of step #2 should resume.\n    ABid private _cursorRB;\n\n    ///@dev Total number of ranked bids that have been computed so far.\n    ///@dev 0 <= _rankedBidCount <= _bidCount\n    uint16 private _rankedBidCount;\n\n    ///@dev Array of bids sorted by rank order, where entry k contains the bid placed by bidder ranked at position k.\n    ///@dev 0 <= rank < _rankedBidCount\n    ABid[] private _rankedBids;\n\n    // Step 3: Ranked bid won quantity and uniform price calculation. O(N)\n    // ===================================================================\n\n    ///@dev Array of final won quantities sorted by rank order, where entry k contains the won quantity for bidder\n    /// ranked at position k.\n    euint256[] private _rankedWonQuantities;\n\n    // Step 4: Inverting ranking to index vector. O(N)\n    // ===============================================\n\n    ///@dev Index of the bidder whose final won quantity is being computed\n    uint16 private _idxWQ;\n\n    ///@dev Index from which the computation of the final won quantity should resume\n    uint16 private _resumeIdxWQ;\n\n    ///@dev `true` if all won quantities have been computed\n    bool private _wonQuantitiesByIdReady;\n\n    ///@dev `true` if all ranked won quantities have been computed\n    bool private _wonQuantitiesByRankReady;\n\n    ///@dev Current computed final won quantity for the bidder at index `_idxWQ`\n    euint256 private _quantityWQ;\n\n    ///@dev Array of final won quantities, where entry k contains the won quantity for bidder with index = k + 1\n    euint256[] private _wonQuantities;\n\n    error ExpectedNotClosed();\n    error ExpectedClosed();\n    error IndexOutOfBounds(uint16 idx, uint16 count);\n    error RankOutOfBounds(uint16 rank, uint16 rankCount);\n    error InvalidIterator();\n    error InvalidId(uint16 id);\n    error BidderAlreadyRegistered(address bidder);\n    error TooManyBids();\n    error WonQuantitiesByRankNotReady();\n    error WonQuantitiesByIdNotReady();\n    error NotEnoughGas(uint256 gasLeft, uint256 gasNeeded);\n    error UnauthorizedIterator();\n    // Debug\n    error DebugEngineError(uint16 code);\n\n    /**\n     * @dev Ensures the auction engine not closed before executing the function.\n     */\n    modifier whenNotClosed() {\n        if (_auctionIsClosed) revert ExpectedNotClosed();\n        _;\n    }\n\n    /**\n     * @dev Ensures the auction engine is closed before executing the function.\n     */\n    modifier whenClosed() {\n        if (!_auctionIsClosed) revert ExpectedClosed();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the iterator.\n     */\n    modifier onlyIterator() {\n        if (address(_iterator) != msg.sender) {\n            revert UnauthorizedIterator();\n        }\n        _;\n    }\n\n    /**\n     * @param auctionOrInitialOwner_ The address of the `FHEAuctionBase` contract that owns this auction engine or the \n     * address of the initial owner. If the engine initial owner is not the auction contract, a transfer ownership must\n     * be performed to give ownership to the auction contract.\n     * @param tieBreakingRule_ The tie-breaking rule used by the auction engine to resolve ties. \n     * @param iterator_ The addre.\n     */\n    constructor(address auctionOrInitialOwner_, uint8 tieBreakingRule_, address iterator_) Ownable(auctionOrInitialOwner_) {\n        if (iterator_ == address(0) || Ownable(iterator_).owner() != auctionOrInitialOwner_) {\n            revert InvalidIterator();\n        }\n\n        _iterator = FHEAuctionEngineIterator(iterator_);\n        _tieBreakingRule = TieBreakingRule(tieBreakingRule_);\n\n        euint256 eZero = TFHE.asEuint256(0);\n        TFHE.allowThis(eZero);\n\n        _eZeroU256 = eZero;\n        _cumulativeQuantity = eZero;\n        _uniformPrice = eZero;\n\n        // A bit counter intuitive.\n        // Mainly to ensure that computation iterations have a constant gas cost\n        _cursorRB.price = DUMMY_EUINT256_MEMORY;\n        _cursorRB.quantity = DUMMY_EUINT256_MEMORY;\n        _cursorRB.id = DUMMY_EUINT16_MEMORY;\n        _resumeIdxRB = uint16(0xdead);\n\n        _quantityWQ = eZero;\n        _nextId = 1;\n        _maxBidCount = type(uint16).max;\n    }\n\n    /**\n     * @notice Initializes the auction engine with a specified quantity of items.\n     * The `FHEAuctionEngine` contract is intended for internal use by its owner and is not designed to be\n     * used by other contracts. It does not include protections against reentrancy or multiple initializations.\n     *\n     * @dev Requirements:\n     * - The caller must be the engine owner (a contract of type `FHEAuctionBase`).\n     * - The engine must not be in a closed state.\n     *\n     * @param totalQuantity_ The total quantity of items to be auctioned.\n     */\n    function initialize(uint256 totalQuantity_, uint16 maxBidCount_) external onlyOwner whenNotClosed {\n        _totalQuantity = totalQuantity_;\n        _maxBidCount = maxBidCount_;\n    }\n\n    /**\n     * @notice Returns the auction contract associated with this engine.\n     * @dev The auction contract is required to be the owner of the engine.\n     * @return The auction contract interface.\n     */\n    function _auction() internal view returns (IFHEAuction) {\n        return IFHEAuction(owner());\n    }\n\n    /**\n     * @notice Returns the engine iterator address. The iterator's owner is the engine itself.\n     */\n    function iterator() public view returns (address) {\n        return address(_iterator);\n    }\n\n    /**\n     * @notice Returns total quantity of items to be auctioned.\n     */\n    function totalQuantity() external view returns (uint256) {\n        return _totalQuantity;\n    }\n\n    /**\n     * @notice Returns the maximum allowable price for each bid.\n     * This value ensures that subsequent TFHE arithmetic operations will not overflow.\n     */\n    function maximumPrice() public view returns (uint256) {\n        return MAX_UINT256 / _totalQuantity;\n    }\n\n    /**\n     * @notice Returns the tie-breaking rule used to resolve winning ties.\n     */\n    function tieBreakingRule() external view returns (uint8) {\n        return uint8(_tieBreakingRule);\n    }\n\n    /**\n     * @notice Returns the total number of bids.\n     */\n    function getBidCount() public view returns (uint16) {\n        return _bidCount;\n    }\n\n    /**\n     * @notice Returns the maximum number of bids.\n     */\n    function getMaximumBidCount() public view returns (uint16) {\n        return _maxBidCount;\n    }\n\n    /**\n     * @notice Retrieves the bid associated with the specified bid index. Reverts if the index is out of bounds.\n     * @param index The zero-based index of the bid to retrieve.\n     * @return id The encrypted ID of the bid.\n     * @return price The encrypted price of the bid.\n     * @return quantity The encrypted quantity of the bid.\n     */\n    function getBidByIndex(uint16 index) public view returns (uint16 id, euint256 price, euint256 quantity) {\n        if (index >= _bidCount) {\n            revert IndexOutOfBounds(index, _bidCount);\n        }\n\n        id = _indexPlusOneToId[index + 1];\n        price = _idToBid[id].price;\n        quantity = _idToBid[id].quantity;\n    }\n\n    /**\n     * @notice Retrieves the bid associated with the specified bidder address.\n     * @param bidder The address of the bidder whose bid is being retrieved.\n     * @return id The clear ID of the bid.\n     * @return price The encrypted price of the bid.\n     * @return quantity The encrypted quantity of the bid.\n     */\n    function getBidByBidder(address bidder) public view returns (uint16 id, euint256 price, euint256 quantity) {\n        id = _bidderToId[bidder];\n        price = _idToBid[id].price;\n        quantity = _idToBid[id].quantity;\n    }\n\n    /**\n     * @notice Returns the bid ranked at the specified position `rank`.\n     * The bid at rank `0` is the highest-ranked (winning) bid. Reverts if `rank` is out of bounds.\n     * @param rank The zero-based rank position of the bid to retrieve.\n     * @return id The encrypted ID of the bid.\n     * @return price The encrypted price of the bid.\n     * @return quantity The encrypted quantity of the bid.\n     */\n    function getBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\n        if (rank >= _rankedBidCount) {\n            revert RankOutOfBounds(rank, _rankedBidCount);\n        }\n\n        id = _rankedBids[rank].id;\n        price = _rankedBids[rank].price;\n        quantity = _rankedBids[rank].quantity;\n    }\n\n    /**\n     * @notice Retrieves the bid ranked at the specified position `rank`.\n     * The bid at rank `0` represents the highest-ranked (winning) bid.\n     * The function reverts if:\n     * - The ranked won quantities computation is not complete.\n     * - The provided `rank` is out of bounds.\n     *\n     * @param rank The zero-based rank position of the bid to retrieve.\n     * @return id The encrypted ID of the bid at the specified rank.\n     * @return price The encrypted price of the bid at the specified rank.\n     * @return quantity The encrypted quantity won by the bid at the specified rank.\n     */\n    function getWonBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\n        if (!_wonQuantitiesByRankReady) {\n            // step #3 is not yet completed\n            revert WonQuantitiesByRankNotReady();\n        }\n\n        if (rank >= _rankedBidCount) {\n            revert IndexOutOfBounds(rank, _rankedBidCount);\n        }\n\n        id = _rankedBids[rank].id;\n        price = _rankedBids[rank].price;\n        quantity = _rankedWonQuantities[rank];\n    }\n\n    /**\n     * @notice Returns `true` if the uniform price is ready for decryption.\n     */\n    function canDecryptUniformPrice() external view returns (bool) {\n        // uniformPrice is computed during step #3\n        return _wonQuantitiesByRankReady;\n    }\n\n    /**\n     * @notice Returns the encrypted uniform price if computations are complete;\n     * otherwise, returns zero (uninitialized `euint256`).\n     * @return price the encrypted uniform price. The engine owner has TFHE permissions to access `price`.\n     */\n    function getUniformPrice() public view returns (euint256 price) {\n        // uniformPrice is computed during step #3\n        if (_wonQuantitiesByRankReady) {\n            price = _uniformPrice;\n        }\n    }\n\n    /**\n     * @notice Returns `true` if the computation of all won quantities is complete (step #4),\n     * allowing bidders to claim their auction prizes.\n     */\n    function canClaim() external view returns (bool) {\n        return _wonQuantitiesByIdReady;\n    }\n\n    /**\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\n     */\n    function canBlindClaim() external view returns (bool) {\n        return _wonQuantitiesByRankReady;\n    }\n\n    /**\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\n     */\n    function wonQuantitiesByRankReady() external view returns (bool) {\n        return _wonQuantitiesByRankReady;\n    }\n\n    /**\n     * @notice Returns `true` if all ranked won quantities have been computed (step #4),\n     */\n    function wonQuantitiesByIdReady() external view returns (bool) {\n        return _wonQuantitiesByIdReady;\n    }\n\n    /**\n     * @notice Returns the validated price and the encrypted won quantity associated with the bid identified by `id`.\n     *\n     * @notice Requirements:\n     * - The computation of all won quantities must be complete (step #4).\n     * - `id` must be a valid ID.\n     *\n     * @param id The bid ID.\n     * @return validatedPrice The encrypted validated price of the bid.\n     * @return wonQuantity The encrypted won quantity of the bid.\n     *\n     * @dev The owning auction contract has TFHE access permissions on both `wonQuantity` and `validatedPrice`.\n     */\n    function validatedPriceAndWonQuantityById(uint16 id)\n        external\n        view\n        returns (euint256 validatedPrice, euint256 wonQuantity)\n    {\n        if (_wonQuantitiesByIdReady) {\n            uint16 idxPlusOne = _idToIndexPlusOne[id];\n\n            if (idxPlusOne == 0 || idxPlusOne > _bidCount) {\n                revert InvalidId(id);\n            }\n\n            // owner has TFHE permissions.\n            validatedPrice = _idToBid[id].price;\n            wonQuantity = _wonQuantities[idxPlusOne - 1];\n        }\n    }\n\n    /**\n     * @notice Returns the bid ID associated with the specified `bidder` address.\n     */\n    function bidderId(address bidder) external view returns (uint16) {\n        return _bidderToId[bidder];\n    }\n\n    /**\n     * @notice Returns the bidder address associated with the specified `id`.\n     */\n    function getBidderById(uint16 id) external view returns (address) {\n        return _idToBidder[id];\n    }\n\n    /**\n     * @notice Removes a bidder's bid from the list of bids\n     *\n     * @notice Requirements:\n     * - The caller must be the engine owner.\n     * - The auction engine should not be closed. (ie still accepting new bids)\n     */\n    function removeBid(address bidder) external onlyOwner whenNotClosed {\n        uint16 id = _bidderToId[bidder];\n        if (id == 0) {\n            return;\n        }\n\n        // Debug\n        if (!(_bidCount > 0)) revert DebugEngineError(4);\n\n        uint16 idxPlusOne = _idToIndexPlusOne[id];\n\n        // Debug\n        if (!(idxPlusOne > 0)) revert DebugEngineError(5);\n\n        // remove bidder address\n        _bidderToId[bidder] = 0;\n        _idToBidder[id] = address(0);\n\n        // swap id with last id\n        if (idxPlusOne < _bidCount) {\n            uint16 lastId = _indexPlusOneToId[_bidCount];\n\n            // Debug\n            if (!(lastId > 0)) revert DebugEngineError(6);\n\n            _indexPlusOneToId[idxPlusOne] = lastId;\n            _idToIndexPlusOne[lastId] = idxPlusOne;\n        }\n\n        // remove id\n        _indexPlusOneToId[_bidCount] = 0;\n        _idToIndexPlusOne[id] = 0;\n        _idToBid[id] =\n            ABid({price: euint256.wrap(0), quantity: euint256.wrap(0), id: euint16.wrap(0), rand: euint256.wrap(0)});\n\n        _bidCount--;\n    }\n\n    /**\n     * @notice Mark the auction engine as closed. When the engine is closed, it can no more accept new bids.\n     *\n     * @notice Requirements:\n     * - The caller must be the engine owner.\n     * - The auction engine should not already be closed.\n     */\n    function close() external onlyOwner whenNotClosed {\n        _close(false);\n    }\n\n    function _close(bool onlyBlindClaim) internal {\n        _auctionIsClosed = true;\n        _iterator.initializeFourSteps(_bidCount, 2_456_000, _rankFheGasCostPerIdx(), 1_469_000, 101_000, onlyBlindClaim);\n    }\n\n    /**\n     * @notice Executes a batch of auction computation cycles, processing up to `iter` cycles in a single call.\n     * This function allows incremental processing of the auction results until completion.\n     *\n     * @dev If the auction is not yet closed, it will be closed before starting the computation.\n     *\n     * @notice Requirements:\n     * - Only the contract owner can call this function.\n     *\n     * @param iter The maximum number of computation cycles to execute in this call.\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\n     * @return code A status code indicating the outcome of the computation:\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\n     * @return startIterProgress The total number of computation cycles completed before this function call.\n     * @return endIterProgress The total number of computation cycles completed after this function call.\n     */\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\n        external\n        onlyOwner\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\n    {\n        if (!_auctionIsClosed) {\n            _close(false);\n        }\n        (code, startIterProgress, endIterProgress) = _iterator.computeAuctionIterations(iter, stopIfReadyForBlindClaim);\n    }\n\n    /**\n     * @notice Adds a new bid to the list of bids.\n     *\n     * @dev Requirements:\n     * - The caller must be the engine owner.\n     * - The auction engine must not be closed.\n     *\n     * @param bidder The address of the bidder placing the new bid.\n     * @param ePrice The encrypted price of the bid.\n     * @param eQuantity The encrypted quantity of the bid.\n     */\n    function addBid(address bidder, euint256 ePrice, euint256 eQuantity) external onlyOwner whenNotClosed {\n        if (_bidderToId[bidder] != 0) {\n            revert BidderAlreadyRegistered(bidder);\n        }\n\n        if (_bidCount == _maxBidCount) {\n            revert TooManyBids();\n        }\n\n        uint16 nextId = _nextId;\n        _nextId = nextId + 1;\n\n        uint16 nextIdxPlusOne = _bidCount + 1;\n        _bidCount = nextIdxPlusOne;\n\n        euint256 zero = _eZeroU256;\n        ebool priceTooHigh = TFHE.gt(ePrice, maximumPrice());\n        ePrice = TFHE.select(priceTooHigh, zero, ePrice);\n        eQuantity = TFHE.min(eQuantity, _totalQuantity);\n\n        ebool ePriceIsZero = TFHE.eq(ePrice, zero);\n        ebool eQuantityIsZero = TFHE.eq(eQuantity, zero);\n\n        ePrice = TFHE.select(eQuantityIsZero, zero, ePrice);\n        eQuantity = TFHE.select(ePriceIsZero, zero, eQuantity);\n\n        euint256 eRand = euint256.wrap(0);\n        euint16 eId = TFHE.asEuint16(nextId);\n\n        if (_tieBreakingRule == TieBreakingRule.PriceRandom) {\n            eRand = TFHE.randEuint256();\n            TFHE.allowThis(eRand);\n        }\n\n        TFHE.allowThis(ePrice);\n        TFHE.allowThis(eQuantity);\n        TFHE.allowThis(eId);\n\n        _indexPlusOneToId[nextIdxPlusOne] = nextId;\n        _idToIndexPlusOne[nextId] = nextIdxPlusOne;\n\n        _bidderToId[bidder] = nextId;\n        _idToBidder[nextId] = bidder;\n\n        _idToBid[nextId] = ABid({price: ePrice, quantity: eQuantity, rand: eRand, id: eId});\n\n        // Bidder pays for memory allocation\n        ABid memory _emptySortedBid;\n        _emptySortedBid.price = DUMMY_EUINT256_MEMORY;\n        _emptySortedBid.quantity = DUMMY_EUINT256_MEMORY;\n        _emptySortedBid.rand = DUMMY_EUINT256_MEMORY;\n        _emptySortedBid.id = eId;\n\n        _rankedBids.push(_emptySortedBid);\n        _rankedWonQuantities.push(DUMMY_EUINT256_MEMORY);\n        _wonQuantities.push(DUMMY_EUINT256_MEMORY);\n    }\n\n    // ====================================================================== //\n    //\n    //                  ⭐️ Step 1/4: Bid Validation O(N) ⭐️\n    //\n    // ====================================================================== //\n\n    /**\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #1.\n     *\n     * - Returns `E_NOT_ENOUGH_GAS` if the `chunckSize` iterations could not be completed due to insufficient gas.\n     * - Returns `S_NOT_FINISHED` if the iterations were completed but the computation step is not yet finished.\n     * - Returns `S_FINISHED` if the iterations were completed (or fewer iterations were needed) and the bid ranking step has been completed.\n     * @param progress The current step progress.\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\n     * @param progressMax The max progress value for the step #1. (`progress` + `iter` <= `progressMax`)\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 1x mul(euint256, euint256) : 1 x 2_045_000\n     * - 1x le(euint256, uint256)   : 1 x   231_000\n     * - 2x select(euint256)        : 2 x    90_000\n     *\n     * Total FHE Gas Cost per iteration : 2_456_000\n     */\n    function _runStep1(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\n        if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\n            return (E_NOT_ENOUGH_GAS, 0);\n        }\n\n        // Gas cost ~= 2_400\n        uint16 toIdx = uint16(progress + iter);\n\n        euint256 ePrice;\n        euint256 eQuantity;\n\n        IFHEAuction auction = _auction();\n\n        // From start to beginning of the loop : Gas cost ~= 2_600\n        // 1x loop iter ~= 153_000 gas\n        // After loop ~= 3_000 gas\n        uint16 count = 0;\n        uint8 code = S_NOT_FINISHED;\n\n        for (uint16 idx = uint16(progress); idx < toIdx; ++idx) {\n            uint16 bidId = _indexPlusOneToId[idx + 1];\n\n            // Debug\n            if (!(bidId > 0)) revert DebugEngineError(7);\n\n            ABid storage b = _idToBid[bidId];\n            ePrice = b.price;\n            eQuantity = b.quantity;\n            // ePrice = _idToBid[bidId].price;\n            // eQuantity = _idToBid[bidId].quantity;\n\n            // Cannot overflow\n            euint256 minBalance = TFHE.mul(ePrice, eQuantity);\n\n            ebool enoughBalance = TFHE.le(minBalance, auction.balanceOf(_idToBidder[bidId]));\n\n            ePrice = TFHE.select(enoughBalance, ePrice, _eZeroU256);\n            eQuantity = TFHE.select(enoughBalance, eQuantity, _eZeroU256);\n\n            // _idToBid[bidId].price = ePrice;\n            // _idToBid[bidId].quantity = eQuantity;\n            b.price = ePrice;\n            b.quantity = eQuantity;\n\n            TFHE.allowThis(ePrice);\n            TFHE.allowThis(eQuantity);\n            TFHE.allow(ePrice, address(auction));\n            TFHE.allow(eQuantity, address(auction));\n\n            count++;\n\n            if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\n                // Not enough gas to iter one more time and be sure to complete\n                // the function without beeing out-of-gas\n                code = E_NOT_ENOUGH_GAS;\n                break;\n            }\n        }\n\n        if (progress + count == progressMax) {\n            code = S_FINISHED;\n        }\n\n        return (code, count);\n    }\n\n    // ====================================================================== //\n    //\n    //             ⭐️ Step 2/4: Sort Bids by Rank Order O(N^2) ⭐️\n    //\n    // ====================================================================== //\n\n    /**\n     * @dev Returns the FHE Gas cost per iteration consumed by the `_rankFromIdxToIdx` function.\n     */\n    function _rankFheGasCostPerIdx() internal pure virtual returns (uint32);\n\n    /**\n     * @dev Performs a ranking pass from index `fromIdx` to index `toIdx`. The FHE Gas cost can be evaluated using the\n     * `_rankFheGasCostPerIdx` function.\n     */\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual;\n\n    /**\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #2.\n     * see function {computeValidation}\n     * @param progress The current step progress.\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\n     * @param progressMax The max progress value for the step #2. (`progress` + `iter` <= `progressMax`)\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\n     *\n     * @dev Total FHE Gas Cost per iteration : `_rankFheGasCostPerIdx()`\n     */\n    function _runStep2(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\n        if (gasleft() < 2 * MIN_GAS_PER_RB_CYCLE) {\n            // If we do not have enough gas left to perform `one TFHE cycle` + `one sort completion`\n            // it is probably safe to interrupt at this point to avoid any accidental revert due to insufficient gas\n            return (E_NOT_ENOUGH_GAS, 0);\n        }\n\n        uint16 rankedBidCount = _rankedBidCount;\n        uint16 resumeIdx;\n\n        // We want to optimize the following calls:\n        // - TFHE.allow(...) which cost about 25_000 gas\n        // - SSTORE operations\n        // We use the following 2 flags to minimize those calls.\n        bool cursorAllowNeeded = false;\n        bool cursorUpdateNeeded = false;\n\n        ABid memory cursor;\n\n        // We pick the first registered bid and store it at the first place of\n        // the sorted bid list.\n        if (rankedBidCount == 0) {\n            // The first bid id is equal to `1`\n            // (See the bid() function and the above remark (3))\n            _rankedBids[0] = _idToBid[_indexPlusOneToId[1]];\n\n            // if there is only one single bidder, the sort is over\n            if (_bidCount == 1) {\n                _rankedBidCount = 1;\n                return (S_FINISHED, 1);\n            }\n\n            // if there are more than one bidder,\n            // load the second unsorted bid into the cursor and setup the cursor position to zero\n            rankedBidCount = 1;\n            resumeIdx = 0;\n            cursor = _idToBid[_indexPlusOneToId[2]];\n            cursorUpdateNeeded = true;\n        } else {\n            // If the function is called to resume the sort operation, then\n            // start from the last position stored in the cursor.\n            resumeIdx = _resumeIdxRB;\n            cursor = _cursorRB;\n        }\n\n        uint8 code = S_NOT_FINISHED;\n        uint32 count = 0;\n\n        while (count < iter) {\n            uint32 toIdx = resumeIdx + uint16(iter - count);\n            if (toIdx > rankedBidCount) {\n                toIdx = rankedBidCount;\n            }\n\n            // We want to make sure we have enough gas to compute the following:\n            // - `toIdx - resumeIdxRB` cycles of TFHE operations\n            // - 1 extra gas quantity to finish the current sort pass.\n            if (gasleft() < (toIdx - resumeIdx + 1) * MIN_GAS_PER_RB_CYCLE) {\n                code = E_NOT_ENOUGH_GAS;\n                break;\n            }\n\n            // since resumeIdx < toIdx, the cursor will always be modified\n            // therefore we must invalidate the storage `_cursorRB` struct.\n            _rankFromIdxToIdx(resumeIdx, uint16(toIdx), cursor);\n\n            count += (toIdx - resumeIdx);\n\n            // invalidate the storage `_cursorRB`\n            cursorUpdateNeeded = true;\n\n            // We have reached the end of the currently sorted bids.\n            // We must do the following:\n            // 1. append the bid cursor to end of the sorted list.\n            // 2. load the cursor with the next unsorted bid\n            // 3. set the cursor position to zero.\n            if (toIdx == rankedBidCount) {\n                _rankedBids[rankedBidCount] = cursor;\n                rankedBidCount++;\n\n                _allowBid(cursor);\n\n                // If all the registered bids have been sorted, then the sort operation\n                // is completed.\n                if (rankedBidCount == _bidCount) {\n                    // Debug\n                    if (!(progress + count == progressMax)) revert DebugEngineError(8);\n\n                    _rankedBidCount = rankedBidCount;\n                    return (S_FINISHED, count);\n                }\n\n                // restart from the beginning with the next unsorted bid.\n                // The next unsorted bid index is equal to `rankedBidCount`\n                resumeIdx = 0;\n                cursor = _idToBid[_indexPlusOneToId[rankedBidCount + 1]];\n\n                // since the values stored in the cursor are already allowed, there\n                // will be no need to perform any TFHE.allow() call.\n                cursorAllowNeeded = false;\n            } else {\n                // Debug\n                if (!(count == iter)) revert DebugEngineError(9);\n\n                resumeIdx = uint16(toIdx);\n\n                // a TFHE.allow call must be executed on the new cursor values\n                cursorAllowNeeded = true;\n            }\n        }\n\n        // Debug\n        if (!(progress + count < progressMax)) revert DebugEngineError(10);\n\n        // Perform TFHE.allow if needed\n        if (cursorAllowNeeded) {\n            _allowBid(cursor);\n        }\n\n        // Save the new cursor if needed\n        if (cursorUpdateNeeded) {\n            _cursorRB = cursor;\n        }\n\n        // Save the new _rankedBidCount value\n        _rankedBidCount = rankedBidCount;\n\n        // Save the new cursor position\n        _resumeIdxRB = resumeIdx;\n\n        return (code, count);\n    }\n\n    // ====================================================================== //\n    //\n    //            ⭐️ Step 3/4: Compute Ranked Won Quantities O(N) ⭐️\n    //\n    // ====================================================================== //\n\n    /**\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #3.\n     * see function {computeValidation}\n     * @param progress The current step progress.\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\n     * @param progressMax The maximum progress value for the step #3 which is equal to `_bidCount`.\n     * (`progress` + `iter` <= `progressMax`)\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 1x lt(euint256, euint256)  : 1 x 231_000\n     * - 1x gt(euint256, euint256)  : 1 x 231_000\n     * - 1x and                     : 1 x  44_000\n     * - 1x sub(euint256, euint256) : 1 x 253_000\n     * - 1x min(euint256, euint256) : 1 x 277_000\n     * - 1x add(euint256, euint256) : 1 x 253_000\n     * - 2x select(euint256)        : 2 x  90_000\n     *\n     * Total FHE Gas Cost per iteration : 1_469_000\n     */\n    function _runStep3(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\n        // Average gas cost:\n        // - first iteration : 113_000 gas\n        // - single iteration : 225_000 gas\n        if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\n            return (E_NOT_ENOUGH_GAS, 0);\n        }\n\n        // Debug\n        if (!(_rankedBidCount == _bidCount && _rankedBids.length >= _bidCount)) revert DebugEngineError(11);\n\n        uint16 from = uint16(progress);\n        uint16 to = uint16(from + iter);\n\n        address auctionAddr = address(_auction());\n        euint256 cumulativeQuantity;\n        euint256 uniformPrice;\n\n        uint16 count = 0;\n        uint8 code = S_NOT_FINISHED;\n\n        if (from == 0) {\n            cumulativeQuantity = _rankedBids[0].quantity;\n            uniformPrice = _rankedBids[0].price;\n\n            euint256 wonQuantity = TFHE.min(cumulativeQuantity, _totalQuantity);\n            TFHE.allowThis(wonQuantity);\n\n            // Additional allowance, required when using blind claim\n            TFHE.allow(wonQuantity, auctionAddr);\n            TFHE.allow(_rankedBids[0].id, auctionAddr);\n            TFHE.allow(_rankedBids[0].price, auctionAddr);\n\n            _rankedWonQuantities[0] = wonQuantity;\n\n            if (to == 1) {\n                _cumulativeQuantity = cumulativeQuantity;\n                _uniformPrice = uniformPrice;\n\n                if (to == progressMax) {\n                    TFHE.allow(uniformPrice, auctionAddr);\n                    code = S_FINISHED;\n                    _wonQuantitiesByRankReady = true;\n                }\n\n                return (code, 1);\n            }\n\n            from = 1;\n            count = 1;\n        } else {\n            // Gas cost ~= 4_000\n            cumulativeQuantity = _cumulativeQuantity;\n            uniformPrice = _uniformPrice;\n        }\n\n        // Here: 1 <= from < to\n\n        // Possible gas cost from start up to this point:\n        //   - Branch #1 : 13_000 gas (from != 0)\n        //   - Branch #2 : 73_000 gas (from == 0 && to != 1)\n        //\n        // 1x loop iter ~= 155_000 gas\n        // After loop ~= 60_000 gas\n        for (uint16 k = from; k < to; ++k) {\n            if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\n                // Not enough gas to iter one more time and be sure to complete\n                // the function without beeing out-of-gas\n                code = E_NOT_ENOUGH_GAS;\n                break;\n            }\n\n            euint256 bidQuantity = _rankedBids[k].quantity;\n            euint256 bidPrice = _rankedBids[k].price;\n\n            // Formula:\n            // Wk = (C(k-1) < Q) ? min(Q - C(k-1), q_k) : 0\n            ebool isValid = TFHE.lt(cumulativeQuantity, _totalQuantity);\n\n            // Price = 0 means the bid is invalid\n            // pk = 0 => qk = 0\n            isValid = TFHE.and(isValid, TFHE.gt(bidPrice, _eZeroU256));\n\n            euint256 remainingQuantity = TFHE.sub(_totalQuantity, cumulativeQuantity);\n            euint256 wonQuantity = TFHE.select(isValid, TFHE.min(remainingQuantity, bidQuantity), _eZeroU256);\n\n            cumulativeQuantity = TFHE.add(cumulativeQuantity, bidQuantity);\n\n            uniformPrice = TFHE.select(isValid, bidPrice, uniformPrice);\n\n            TFHE.allowThis(wonQuantity);\n\n            // Additional allowance, required when using blind claim\n            TFHE.allow(wonQuantity, auctionAddr);\n            TFHE.allow(_rankedBids[k].id, auctionAddr);\n            TFHE.allow(_rankedBids[k].price, auctionAddr);\n\n            _rankedWonQuantities[k] = wonQuantity;\n\n            count++;\n        }\n\n        // Allow cost ~= 48_000 gas\n        if (count > 0) {\n            TFHE.allowThis(cumulativeQuantity);\n            TFHE.allowThis(uniformPrice);\n        }\n\n        // Storage cost ~= 9_000 gas\n        _cumulativeQuantity = cumulativeQuantity;\n        _uniformPrice = uniformPrice;\n\n        // Debug\n        if (!(progress + count <= progressMax)) revert DebugEngineError(13);\n\n        if (progress + count == progressMax) {\n            TFHE.allow(uniformPrice, auctionAddr);\n            code = S_FINISHED;\n            _wonQuantitiesByRankReady = true;\n        }\n\n        return (code, count);\n    }\n\n    // ====================================================================== //\n    //\n    //        ⭐️ Step 4/4: Compute Won Quantities O(N^2) (Optional) ⭐️\n    //\n    // ====================================================================== //\n \n    /**\n     * @notice Computes a set of `iter` iteration cycles for the step #4.\n     * see function {computeValidation}\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 1x eq(euint16, euint16)  : 1 x 54_000\n     * - 1x select(euint16)       : 1 x 47_000\n     *\n     * Total FHE Gas Cost per iteration : 101_000\n     */\n    function _runStep4(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\n        if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\n            return (E_NOT_ENOUGH_GAS, 0);\n        }\n\n        uint16 idxWQ = _idxWQ;\n        uint16 resumeIdxWQ = _resumeIdxWQ;\n        euint256 quantity = _quantityWQ;\n\n        // Debug\n        if (!(idxWQ < _bidCount && resumeIdxWQ < _bidCount && (idxWQ * _bidCount + resumeIdxWQ + iter <= _bidCount * _bidCount))) {\n            revert DebugEngineError(14);\n        }\n        // Debug\n        if (!(progress == idxWQ * _bidCount + resumeIdxWQ)) revert DebugEngineError(15);\n\n        uint16 idx = idxWQ;\n        uint16 resumeIdx = resumeIdxWQ;\n        uint32 count = 0;\n        uint8 code = S_NOT_FINISHED;\n        address auctionAddr = address(_auction());\n\n        while (count < iter) {\n            ebool eq_id = TFHE.eq(_rankedBids[resumeIdx].id, _indexPlusOneToId[idx + 1]);\n            quantity = TFHE.select(eq_id, _rankedWonQuantities[resumeIdx], quantity);\n\n            resumeIdx++;\n\n            if (resumeIdx == _bidCount) {\n                // store won quantity\n                _wonQuantities[idx] = quantity;\n                TFHE.allowThis(quantity);\n                TFHE.allow(quantity, auctionAddr);\n\n                // reset cursor\n                idx += 1;\n                resumeIdx = 0;\n                quantity = _eZeroU256;\n            }\n\n            count++;\n\n            if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\n                code = E_NOT_ENOUGH_GAS;\n                break;\n            }\n        }\n\n        if (progress + count == progressMax) {\n            // Debug\n            if (!(idx == _bidCount && resumeIdx == 0)) revert DebugEngineError(18);\n\n            //could be removed\n            _idxWQ = _bidCount;\n            //not necessary ?\n            //_resumeIdxWQ = 0;\n            _wonQuantitiesByIdReady = true;\n\n            return (S_FINISHED, count);\n        }\n\n        // Debug\n        if (!(idx < _bidCount)) revert DebugEngineError(19);\n\n        if (resumeIdx != resumeIdxWQ) {\n            _resumeIdxWQ = resumeIdx;\n        }\n\n        if (idx != idxWQ) {\n            _idxWQ = idx;\n        }\n\n        _quantityWQ = quantity;\n        TFHE.allowThis(quantity);\n\n        return (code, count);\n    }\n\n    /**\n     * @dev Returns the encrypted bid ranked at position `rank`.\n     * This function is meant be called by derived contracts.\n     */\n    function _rankedBidAt(uint16 rank) internal view returns (ABid storage bid) {\n        bid = _rankedBids[rank];\n    }\n\n    /**\n     * @dev Sets the encrypted bid ranked at position `rank`\n     * This function is meant be called by derived contracts.\n     */\n    function _setRankedBidAt(uint16 rank, ABid memory newBid) internal {\n        _rankedBids[rank] = newBid;\n        _allowBid(newBid);\n    }\n\n    /**\n     * @dev Grants the engine permission to access the encrypted bid values (`price`, `quantity`, `id`, `rand`).\n     */\n    function _allowBid(ABid memory bid_) private {\n        TFHE.allowThis(bid_.price);\n        TFHE.allowThis(bid_.quantity);\n        TFHE.allowThis(bid_.id);\n        if (TFHE.isInitialized(bid_.rand)) {\n            TFHE.allowThis(bid_.rand);\n        }\n    }\n\n    // ====================================================================== //\n    //\n    //               ⭐️ IFourStepsIterable implementation ⭐️\n    //\n    // ====================================================================== //\n\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax)\n        external\n        virtual\n        override\n        onlyIterator\n        returns (uint8, uint32)\n    {\n        return _runStep1(progress, iter, progressMax);\n    }\n\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax)\n        external\n        virtual\n        override\n        onlyIterator\n        returns (uint8, uint32)\n    {\n        return _runStep2(progress, iter, progressMax);\n    }\n\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax)\n        external\n        virtual\n        override\n        onlyIterator\n        returns (uint8, uint32)\n    {\n        return _runStep3(progress, iter, progressMax);\n    }\n\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax)\n        external\n        virtual\n        override\n        onlyIterator\n        returns (uint8, uint32)\n    {\n        return _runStep4(progress, iter, progressMax);\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEngineIterator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FourStepsIterator, IFourStepsIterable} from \"../FourStepsIterator.sol\";\nimport {FHEAuctionEngine} from \"./FHEAuctionEngine.sol\";\n\n// For better readability, steps are named using a one-based index.\nuint8 constant STEP_1_VALIDATION = 0;\nuint8 constant STEP_2_SORT = 1;\nuint8 constant STEP_3_WON_QUANTITIES_BY_RANK = 2;\nuint8 constant STEP_4_WON_QUANTITIES_BY_ID = 3;\n\ncontract FHEAuctionEngineIterator is FourStepsIterator {\n    constructor(address initialOwner) FourStepsIterator(initialOwner) {}\n\n    function initializeFourSteps(\n        uint16 bidCount,\n        uint32 step1UnitFheGasCost,\n        uint32 step2UnitFheGasCost,\n        uint32 step3UnitFheGasCost,\n        uint32 step4UnitFheGasCost,\n        bool onlyBlindClaim\n    ) external onlyOwner {\n        FourStepsIterator.Step[] memory fourSteps = new FourStepsIterator.Step[](4);\n\n        fourSteps[0].size = bidCount;\n        fourSteps[0].nativeGasWeight = 1;\n        fourSteps[0].unitFheGasCost = step1UnitFheGasCost;\n\n        fourSteps[1].size = (bidCount == 0) ? 0 : ((bidCount < 3) ? 1 : bidCount * (bidCount - 1) / 2);\n        fourSteps[1].nativeGasWeight = 2;\n        fourSteps[1].unitFheGasCost = step2UnitFheGasCost;\n\n        fourSteps[2].size = bidCount;\n        fourSteps[2].nativeGasWeight = 1;\n        fourSteps[2].unitFheGasCost = step3UnitFheGasCost;\n\n        if (!onlyBlindClaim) {\n            fourSteps[3].size = bidCount * bidCount;\n            fourSteps[3].nativeGasWeight = 1;\n            fourSteps[3].unitFheGasCost = step4UnitFheGasCost;\n        }\n\n        _initializeFourSteps(fourSteps);\n    }\n\n    /**\n     * @notice Returns the minimum number of computation iterations required to execute a blind claim.\n     */\n    function minIterationsForBlindClaim() external view returns (uint64) {\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\n    }\n\n    /**\n     * @notice Returns the minimum number of computation iterations required to finalize the auction uniform price.\n     */\n    function minIterationsForUniformPrice() external view returns (uint64) {\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\n    }\n\n    /**\n     * @notice see {FHEAuctionEngine-computeAuctionIterations}\n     */\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\n        external\n        onlyOwner\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\n    {\n        (code, startIterProgress, endIterProgress) =\n            _next(iter, (stopIfReadyForBlindClaim) ? STEP_3_WON_QUANTITIES_BY_RANK : STEP_4_WON_QUANTITIES_BY_ID);\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEnginePriceId.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint256, euint16, ebool} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionEngine} from \"./FHEAuctionEngine.sol\";\n\ncontract FHEAuctionEnginePriceId is FHEAuctionEngine {\n    constructor(address auction_, address iterator_)\n        FHEAuctionEngine(auction_, uint8(TieBreakingRule.PriceId), iterator_)\n    {}\n\n    /**\n     * @dev Returns the fixed FHE gas cost per iteration for executing {_rankFromIdxToIdx}.\n     */\n    function _rankFheGasCostPerIdx() internal pure virtual override returns (uint32) {\n        return 978_000;\n    }\n\n    /**\n     * @notice Performs a ranking operation from index `fromIdx` to index `toIdx` using the following comparison function:\n     *\n     * It returns `true` if the bid at `idx` is ranked higher, otherwise returns `false`.\n     *\n     * The comparison follows these rules:\n     * - If `price(idx) > price(bid)`, return `true`\n     * - If `price(idx) < price(bid)`, return `false`\n     * - If `price(idx) == price(bid)`, return `true` if `id(idx) < id(bid)`, otherwise return `false`\n     *\n     * @notice A lower `id` indicates that the bid was placed earlier.\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 1x gt(euint256, uint256)   : 1 x   231_000\n     * - 1x eq(euint256, uint256)   : 1 x   100_000\n     * - 1x lt(euint16, uint16)     : 1 x   105_000\n     * - 1x and                     : 1 x    44_000\n     * - 1x or                      : 1 x    44_000\n     * - 4x select(euint256)        : 4 x    90_000\n     * - 2x select(euint16)         : 2 x    47_000\n     *\n     * Total FHE Gas Cost per iteration : 978_000\n     */\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual override {\n        ABid memory newBid;\n        for (uint16 idx = fromIdx; idx < toIdx; ++idx) {\n            ABid storage b = _rankedBidAt(idx);\n            euint256 p_i = b.price;\n            euint256 q_i = b.quantity;\n            euint16 id_i = b.id;\n\n            ebool i_gt_c;\n            {\n                ebool p_gt = TFHE.gt(p_i, cursor.price);\n                ebool p_eq = TFHE.eq(p_i, cursor.price);\n\n                ebool id_lt = TFHE.lt(id_i, cursor.id);\n\n                i_gt_c = TFHE.or(p_gt, TFHE.and(p_eq, id_lt));\n            }\n\n            newBid.price = TFHE.select(i_gt_c, p_i, cursor.price);\n            newBid.quantity = TFHE.select(i_gt_c, q_i, cursor.quantity);\n            newBid.id = TFHE.select(i_gt_c, id_i, cursor.id);\n\n            cursor.price = TFHE.select(i_gt_c, cursor.price, p_i);\n            cursor.quantity = TFHE.select(i_gt_c, cursor.quantity, q_i);\n            cursor.id = TFHE.select(i_gt_c, cursor.id, id_i);\n\n            _setRankedBidAt(idx, newBid);\n        }\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEnginePriceQuantityId.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint256, euint16, ebool} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionEngine} from \"./FHEAuctionEngine.sol\";\n\ncontract FHEAuctionEnginePriceQuantityId is FHEAuctionEngine {\n    constructor(address auction_, address iterator_)\n        FHEAuctionEngine(auction_, uint8(TieBreakingRule.PriceQuantityId), iterator_)\n    {}\n\n    /**\n     * @dev Returns the fixed FHE gas cost per iteration for executing {_rankFromIdxToIdx}.\n     */\n    function _rankFheGasCostPerIdx() internal pure virtual override returns (uint32) {\n        return 1_397_000;\n    }\n\n    /**\n     * @notice Performs a ranking operation from index `fromIdx` to index `toIdx` using the following comparison function:\n     *\n     * It returns `true` if the bid at `idx` is ranked higher, otherwise returns `false`.\n     *\n     * The comparison follows these rules:\n     * - If `price(idx) > price(bid)`, return `true`\n     * - If `price(idx) < price(bid)`, return `false`\n     * - If `price(idx) == price(bid)`,\n     *      . If `quantity(idx) > quantity(bid)`, return `true`\n     *      . If `quantity(idx) < quantity(bid)`, return `false`\n     *      . If `quantity(idx) == quantity(bid)`, return `true` if `id(idx) < id(bid)`, otherwise return `false`\n     *\n     * @notice A lower `id` indicates that the bid was placed earlier.\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 2x gt(euint256, uint256)   : 2 x   231_000\n     * - 2x eq(euint256, uint256)   : 2 x   100_000\n     * - 1x lt(euint16, uint16)     : 1 x   105_000\n     * - 2x and                     : 2 x    44_000\n     * - 2x or                      : 2 x    44_000\n     * - 4x select(euint256)        : 4 x    90_000\n     * - 2x select(euint16)         : 2 x    47_000\n     *\n     * Total FHE Gas Cost per iteration : 1_397_000\n     */\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual override {\n        ABid memory newBid;\n        for (uint16 idx = fromIdx; idx < toIdx; ++idx) {\n            ABid storage b = _rankedBidAt(idx);\n            euint256 p_i = b.price;\n            euint256 q_i = b.quantity;\n            euint16 id_i = b.id;\n\n            ebool i_gt_c;\n            {\n                ebool p_gt = TFHE.gt(p_i, cursor.price);\n                ebool p_eq = TFHE.eq(p_i, cursor.price);\n\n                ebool q_gt = TFHE.gt(q_i, cursor.quantity);\n                ebool q_eq = TFHE.eq(q_i, cursor.quantity);\n\n                ebool id_lt = TFHE.lt(id_i, cursor.id);\n\n                i_gt_c = TFHE.or(p_gt, TFHE.and(p_eq, TFHE.or(q_gt, TFHE.and(q_eq, id_lt))));\n            }\n\n            newBid.price = TFHE.select(i_gt_c, p_i, cursor.price);\n            newBid.quantity = TFHE.select(i_gt_c, q_i, cursor.quantity);\n            newBid.id = TFHE.select(i_gt_c, id_i, cursor.id);\n\n            cursor.price = TFHE.select(i_gt_c, cursor.price, p_i);\n            cursor.quantity = TFHE.select(i_gt_c, cursor.quantity, q_i);\n            cursor.id = TFHE.select(i_gt_c, cursor.id, id_i);\n\n            _setRankedBidAt(idx, newBid);\n        }\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEnginePriceRandom.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint256, euint16, ebool} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionEngine} from \"./FHEAuctionEngine.sol\";\n\ncontract FHEAuctionEnginePriceRandom is FHEAuctionEngine {\n    constructor(address auction_, address iterator_)\n        FHEAuctionEngine(auction_, uint8(TieBreakingRule.PriceRandom), iterator_)\n    {}\n\n    /**\n     * @dev Returns the fixed FHE gas cost per iteration for executing {_rankFromIdxToIdx}.\n     */\n    function _rankFheGasCostPerIdx() internal pure virtual override returns (uint32) {\n        return 1_104_000;\n    }\n\n    /**\n     * @notice Performs a ranking operation from index `fromIdx` to index `toIdx` using the following comparison function:\n     *\n     * It returns `true` if the bid at `idx` is ranked higher, otherwise returns `false`.\n     *\n     * The comparison follows these rules:\n     * - If `price(idx) > price(bid)`, return `true`\n     * - If `price(idx) < price(bid)`, return `false`\n     * - If `price(idx) == price(bid)`, return `true` if `rand(idx) < rand(bid)`, otherwise return `false`\n     *\n     * @notice A lower `id` indicates that the bid was placed earlier.\n     *\n     * @dev FHE Gas Cost per iteration:\n     * - 1x gt(euint256, uint256)   : 1 x   231_000\n     * - 1x eq(euint256, uint256)   : 1 x   100_000\n     * - 1x lt(euint256, uint256)   : 1 x   231_000\n     * - 1x and                     : 1 x    44_000\n     * - 1x or                      : 1 x    44_000\n     * - 4x select(euint256)        : 4 x    90_000\n     * - 2x select(euint16)         : 2 x    47_000\n     *\n     * Total FHE Gas Cost per iteration : 1_104_000\n     */\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual override {\n        ABid memory newBid;\n        for (uint16 idx = fromIdx; idx < toIdx; ++idx) {\n            ABid storage b = _rankedBidAt(idx);\n            euint256 p_i = b.price;\n            euint256 q_i = b.quantity;\n            euint16 id_i = b.id;\n            euint256 rand_i = b.rand;\n\n            ebool i_gt_c;\n            {\n                ebool p_gt = TFHE.gt(p_i, cursor.price);\n                ebool p_eq = TFHE.eq(p_i, cursor.price);\n\n                ebool rand_lt = TFHE.lt(rand_i, cursor.rand);\n\n                i_gt_c = TFHE.or(p_gt, TFHE.and(p_eq, rand_lt));\n            }\n\n            newBid.price = TFHE.select(i_gt_c, p_i, cursor.price);\n            newBid.quantity = TFHE.select(i_gt_c, q_i, cursor.quantity);\n            newBid.id = TFHE.select(i_gt_c, id_i, cursor.id);\n            newBid.rand = TFHE.select(i_gt_c, rand_i, cursor.rand);\n\n            cursor.price = TFHE.select(i_gt_c, cursor.price, p_i);\n            cursor.quantity = TFHE.select(i_gt_c, cursor.quantity, q_i);\n            cursor.id = TFHE.select(i_gt_c, cursor.id, id_i);\n            cursor.rand = TFHE.select(i_gt_c, cursor.rand, rand_i);\n\n            _setRankedBidAt(idx, newBid);\n        }\n    }\n}\n"
    },
    "contracts/engines/FHEAuctionEngineProRata.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionEngine} from \"./FHEAuctionEngine.sol\";\n\ncontract FHEAuctionEngineProRata is FHEAuctionEngine {\n    constructor(address auction_, address iterator_)\n        FHEAuctionEngine(auction_, uint8(TieBreakingRule.ProRata), iterator_)\n    {}\n\n    /**\n     * @dev Returns the fixed FHE gas cost per iteration for executing {_rankFromIdxToIdx}.\n     */\n    function _rankFheGasCostPerIdx() internal pure virtual override returns (uint32) {\n        return 0;\n    }\n\n    function _rankFromIdxToIdx(uint16, /*fromIdx*/ uint16, /*toIdx*/ ABid memory /*cursor*/ )\n        internal\n        virtual\n        override\n    {\n        if (true) {\n            revert(\"Not yet implemented\");\n        }\n    }\n}\n"
    },
    "contracts/engines/IFHEAuctionEngine.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {euint16, euint256} from \"fhevm/lib/TFHE.sol\";\n\ninterface IFHEAuctionEngine {\n    function canClaim() external view returns (bool);\n    function canBlindClaim() external view returns (bool);\n    function initialize(uint256 totalQuantity, uint16 maxBidCount) external;\n    function close() external;\n    function bidderId(address bidder) external view returns (uint16);\n    function getBidderById(uint16 id) external view returns (address);\n    function addBid(address bidder, euint256 inPrice, euint256 inQuantity) external;\n    function removeBid(address bidder) external;\n    function canDecryptUniformPrice() external view returns (bool);\n    function getUniformPrice() external view returns (euint256);\n    function validatedPriceAndWonQuantityById(uint16 id) external view returns (euint256, euint256);\n    function totalQuantity() external view returns (uint256);\n    function maximumPrice() external view returns (uint256);\n    function getBidCount() external view returns (uint16);\n    function getMaximumBidCount() external view returns (uint16);\n    function getBidByBidder(address bidder) external view returns (uint16 id, euint256 price, euint256 quantity);\n    function getWonBidByRank(uint16 rank) external view returns (euint16 id, euint256 price, euint256 quantity);\n    function iterator() external view returns (address);\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\n        external\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress);\n}\n"
    },
    "contracts/FourStepsIterator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n//import {console} from \"hardhat/console.sol\";\n\ninterface IFourStepsIterable {\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\n}\n\n/*\n * Return code, iterations were completed but the computation step is not finished\n */\nuint8 constant S_NOT_FINISHED = 0;\n\n/*\n * Return code, iterations were completed and the computation step is finished \n */\nuint8 constant S_FINISHED = 1;\n\n/*\n * Return code, iterations could not be completed due to insufficient gas.\n */\nuint8 constant E_NOT_ENOUGH_GAS = 2;\n\nabstract contract FourStepsIterator is Ownable {\n    struct Step {\n        uint32 size;\n        uint8 nativeGasWeight;\n        uint32 unitFheGasCost;\n    }\n\n    uint64[] _cumulatives;\n    Step[] _steps; // len = (4+1)\n    uint8 _step; // 0 <= _step <= 4\n    uint32 _stepProgress;\n    uint64 _iterProgress;\n\n    error NullWeight();\n    error UnauthorizedIterable();\n    //18,992           | 21,952\n\n    constructor(address initialOwner) Ownable(initialOwner) {\n        // _steps[4] should exist\n        for (uint8 i = 0; i < 5; ++i) {\n            _steps.push(Step({size: 0, nativeGasWeight: 0, unitFheGasCost: 0}));\n            _cumulatives.push(0);\n        }\n    }\n\n    function _initializeFourSteps(Step[] memory fourSteps) internal {\n        //Debug\n        require(fourSteps.length <= 4);\n\n        uint64 max = 0;\n        uint8 i;\n        for (i = 0; i < fourSteps.length; ++i) {\n            if (fourSteps[i].size > 0 && fourSteps[i].nativeGasWeight == 0) {\n                revert NullWeight();\n            }\n            max += fourSteps[i].size * fourSteps[i].nativeGasWeight;\n            Step storage s = _steps[i];\n            s.size = fourSteps[i].size;\n            s.nativeGasWeight = fourSteps[i].nativeGasWeight;\n            s.unitFheGasCost = fourSteps[i].unitFheGasCost;\n            _cumulatives[i] = max;\n        }\n\n        while (i < 4) {\n            _cumulatives[i] = max;\n            i++;\n        }\n    }\n\n    /**\n     * @dev Returns the minimum number of completed iterations needed in order to complete step `s`\n     */\n    function _minIterProgressForStep(uint8 s) internal view returns (uint64) {\n        return _cumulatives[s];\n    }\n\n    /**\n     * @dev Returns the minimum number of completed iterations needed in order to complete the four steps\n     */\n    function iterProgressMax() public view returns (uint64) {\n        return _cumulatives[3];\n    }\n\n    /**\n     * @dev Returns the number of completed iterations (`iterProgress()` <= `iterProgressMax()`).\n     */\n    function iterProgress() public view returns (uint64) {\n        return _iterProgress;\n    }\n\n    function getStepProgress(uint8 s) public view returns (uint32) {\n        uint8 cur = _step;\n        if (cur == s) {\n            return _stepProgress;\n        } else if (cur > s) {\n            return _steps[s].size;\n        }\n        return 0;\n    }\n\n    function getStepProgressMax(uint8 s) public view returns (uint32) {\n        return _steps[s].size;\n    }\n\n    function getStepIterProgressMax(uint8 s) public view returns (uint64) {\n        return _steps[s].size * _steps[s].nativeGasWeight;\n    }\n\n    function step() public view returns (uint8) {\n        return _step;\n    }\n\n    function stepProgress() public view returns (uint32) {\n        return _stepProgress;\n    }\n\n    function finished() public view returns (bool) {\n        return _step == 4;\n    }\n\n    /**\n     * @dev Executes up to `iter` computation iterations, stopping early if step `maxStepCompleted` is fully processed.\n     *\n     * @param iter The maximum number of computation iterations to execute.\n     * @param stopAfterStep The computation step at which execution should stop if it has been fully completed.\n     * @return code A status code indicating the outcome of the computation:\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\n     * @return startIterProgress The total number of iterations completed before this function call.\n     * @return endIterProgress The total number of iterations completed after this function call.\n     *         The difference `(endIterProgress - startIterProgress)` represents the number of iterations executed in this call.\n     */\n    function _next(uint64 iter, uint8 stopAfterStep)\n        internal\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\n    {\n        //uint8 s0 = _step;\n        //uint8 s = s0;\n        uint8 s = _step;\n\n        startIterProgress = _iterProgress;\n        endIterProgress = startIterProgress;\n\n        code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\n\n        if (s > stopAfterStep) {\n            return (code, startIterProgress, endIterProgress);\n        }\n\n        //uint32 p0 = _stepProgress;\n        //uint32 p = p0;\n        uint32 fheGasLeft = 10_000_000;\n        uint32 p = _stepProgress;\n        uint64 actualIter = 0;\n        IFourStepsIterable iterable = IFourStepsIterable(owner());\n\n        while (s < 4 && s <= stopAfterStep && fheGasLeft > 0) {\n            Step memory theStep = _steps[s];\n\n            uint32 r = theStep.size - p;\n\n            // skip empty steps first.\n            if (r == 0) {\n                p = 0;\n                s += 1;\n                continue;\n            }\n\n            // after having skipped empty steps\n            if (iter == 0) {\n                break;\n            }\n\n            uint32 w = uint32(theStep.nativeGasWeight);\n            uint32 i;\n            if (iter < w) {\n                // align\n                i = 1;\n                iter = w;\n            } else {\n                if (iter >= r * w) {\n                    i = r;\n                } else {\n                    i = uint32(iter / w);\n                }\n            }\n\n            if (i * theStep.unitFheGasCost > fheGasLeft) {\n                i = uint32(fheGasLeft / theStep.unitFheGasCost);\n\n                if (i == 0) {\n                    fheGasLeft = 0;\n                    break;\n                }\n            }\n\n            fheGasLeft -= uint32(i * theStep.unitFheGasCost);\n\n            uint32 j;\n\n            if (s == 0) {\n                (code, j) = iterable.runStep1(p, i, theStep.size);\n            } else if (s == 1) {\n                (code, j) = iterable.runStep2(p, i, theStep.size);\n            } else if (s == 2) {\n                (code, j) = iterable.runStep3(p, i, theStep.size);\n            } else if (s == 3) {\n                (code, j) = iterable.runStep4(p, i, theStep.size);\n            }\n\n            actualIter += j * w;\n            iter -= j * w;\n            p += j;\n\n            if (code == S_FINISHED) {\n                //Debug\n                require(p == theStep.size, \"Panic: p != theStep.size\");\n                p = 0;\n                s += 1;\n            } else {\n                //Debug\n                require(p < theStep.size, \"Panic: p >= theStep.size\");\n                if (code != S_NOT_FINISHED) {\n                    //Debug\n                    require(code == E_NOT_ENOUGH_GAS, \"Panic: code != E_NOT_ENOUGH_GAS\");\n                    break;\n                }\n            }\n        }\n\n        if (iter > 0 && fheGasLeft == 0) {\n            code = E_NOT_ENOUGH_GAS;\n        }\n\n        if (actualIter > 0) {\n            endIterProgress = startIterProgress + actualIter;\n            _iterProgress = endIterProgress;\n        }\n\n        _stepProgress = p;\n        _step = s;\n\n        if (code != E_NOT_ENOUGH_GAS) {\n            code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\n        }\n    }\n}\n"
    },
    "contracts/ITimedAuction.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\ninterface ITimedAuction {\n    function closed() external view returns (bool);\n}\n"
    },
    "contracts/mocks/auctions/factories/FHEAuctionERC20MockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionERC20Factory} from \"../../../auctions/factories/FHEAuctionERC20Factory.sol\";\nimport {FHEAuctionERC20Mock} from \"../FHEAuctionERC20Mock.sol\";\n\ncontract FHEAuctionERC20MockFactory is FHEAuctionERC20Factory {\n    constructor(FHEAuctionFactoryDetails memory details_)\n        FHEAuctionERC20Factory(details_)\n    {}\n\n    function _getCode() internal view virtual override returns (bytes memory) {\n        return type(FHEAuctionERC20Mock).creationCode;\n    }\n}\n"
    },
    "contracts/mocks/auctions/factories/FHEAuctionNativeMockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionNativeFactory} from \"../../../auctions/factories/FHEAuctionNativeFactory.sol\";\nimport {FHEAuctionNativeMock} from \"../FHEAuctionNativeMock.sol\";\n\ncontract FHEAuctionNativeMockFactory is FHEAuctionNativeFactory {\n    constructor(FHEAuctionFactoryDetails memory details_) FHEAuctionNativeFactory(details_) {}\n\n    function _getCode() internal view virtual override returns (bytes memory) {\n        return type(FHEAuctionNativeMock).creationCode;\n    }\n}\n"
    },
    "contracts/mocks/auctions/FHEAuctionERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint16, euint256} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionERC20} from \"../../auctions/FHEAuctionERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract FHEAuctionERC20Mock is FHEAuctionERC20 {\n    constructor(uint256 minimumPaymentDeposit_, uint256 paymentPenalty_, IERC20 paymentToken_)\n        FHEAuctionERC20(minimumPaymentDeposit_, paymentPenalty_, paymentToken_)\n    {}\n}\n"
    },
    "contracts/mocks/auctions/FHEAuctionNativeMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint16, euint256} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionNative} from \"../../auctions/FHEAuctionNative.sol\";\n\ncontract FHEAuctionNativeMock is FHEAuctionNative {\n    constructor(uint256 minimumPaymentBalance, uint256 paymentPenalty)\n        FHEAuctionNative(minimumPaymentBalance, paymentPenalty)\n    {}\n}\n"
    },
    "contracts/mocks/engines/factories/FHEAuctionEnginePriceIdMockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"../../../engines/factories/FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEnginePriceIdFactory} from \"../../../engines/factories/FHEAuctionEnginePriceIdFactory.sol\";\nimport {FHEAuctionEnginePriceIdMock} from \"../FHEAuctionEnginePriceIdMock.sol\";\n\ncontract FHEAuctionEnginePriceIdMockFactory is FHEAuctionEnginePriceIdFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEnginePriceIdFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceIdMock engine = new FHEAuctionEnginePriceIdMock(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/mocks/engines/factories/FHEAuctionEnginePriceQuantityIdMockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"../../../engines/factories/FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEnginePriceQuantityIdFactory} from\n    \"../../../engines/factories/FHEAuctionEnginePriceQuantityIdFactory.sol\";\nimport {FHEAuctionEnginePriceQuantityIdMock} from \"../FHEAuctionEnginePriceQuantityIdMock.sol\";\n\ncontract FHEAuctionEnginePriceQuantityIdMockFactory is FHEAuctionEnginePriceQuantityIdFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_)\n        FHEAuctionEnginePriceQuantityIdFactory(iteratorFactory_)\n    {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceQuantityIdMock engine = new FHEAuctionEnginePriceQuantityIdMock(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/mocks/engines/factories/FHEAuctionEnginePriceRandomMockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineIteratorFactory} from \"../../../engines/factories/FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEnginePriceRandomFactory} from \"../../../engines/factories/FHEAuctionEnginePriceRandomFactory.sol\";\nimport {FHEAuctionEnginePriceRandomMock} from \"../FHEAuctionEnginePriceRandomMock.sol\";\n\ncontract FHEAuctionEnginePriceRandomMockFactory is FHEAuctionEnginePriceRandomFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_)\n        FHEAuctionEnginePriceRandomFactory(iteratorFactory_)\n    {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEnginePriceRandomMock engine = new FHEAuctionEnginePriceRandomMock(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/mocks/engines/factories/FHEAuctionEngineProRataMockFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {FHEAuctionEngineProRataFactory} from \"../../../engines/factories/FHEAuctionEngineProRataFactory.sol\";\nimport {FHEAuctionEngineIteratorFactory} from \"../../../engines/factories/FHEAuctionEngineIteratorFactory.sol\";\nimport {FHEAuctionEngineProRataMock} from \"../FHEAuctionEngineProRataMock.sol\";\n\ncontract FHEAuctionEngineProRataMockFactory is FHEAuctionEngineProRataFactory {\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineProRataFactory(iteratorFactory_) {}\n\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal override returns (address) {\n        require(Ownable(iteratorAddr).owner() == initialOwner, \"Wrong owner\");\n        FHEAuctionEngineProRataMock engine = new FHEAuctionEngineProRataMock(initialOwner, iteratorAddr);\n        return address(engine);\n    }\n}\n"
    },
    "contracts/mocks/engines/FHEAuctionEngineBaseMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE, euint16, euint256} from \"fhevm/lib/TFHE.sol\";\nimport {FHEAuctionEngine} from \"../../engines/FHEAuctionEngine.sol\";\nimport {\n    FHEAuctionEngineIterator,\n    STEP_1_VALIDATION,\n    STEP_2_SORT,\n    STEP_3_WON_QUANTITIES_BY_RANK,\n    STEP_4_WON_QUANTITIES_BY_ID\n} from \"../../engines/FHEAuctionEngineIterator.sol\";\nimport {FourStepsIterator, IFourStepsIterable, S_FINISHED} from \"../../FourStepsIterator.sol\";\n\nabstract contract FHEAuctionEngineBaseMock is FHEAuctionEngine {\n    function allowBids() external {\n        uint16 n = getBidCount();\n        for (uint16 i = 0; i < n; ++i) {\n            // external call is better for coprocessorUtils.ts\n            this.allowAccountToAccessBidByIndex(i, msg.sender);\n        }\n    }\n\n    function allowRankedBids() external {\n        uint16 n = getBidCount();\n        for (uint16 i = 0; i < n; ++i) {\n            // external call is better for coprocessorUtils.ts\n            this.allowAccountToAccessBidByRank(i, msg.sender);\n        }\n    }\n\n    function allowUniformPrice() external {\n        // external call is better for coprocessorUtils.ts\n        this.allowAccountToAccessUniformPrice(msg.sender);\n    }\n\n    function allowAccountToAccessUniformPrice(address account) public {\n        euint256 pu = getUniformPrice();\n\n        require(TFHE.isAllowed(pu, address(this)), \"This is not allowed to access uniform price\");\n\n        TFHE.allow(pu, account);\n    }\n\n    function allowAccountToAccessBidByRank(uint16 rank, address account) public {\n        require(address(this) == msg.sender, \"Sender is not this\");\n        (euint16 id, euint256 price, euint256 quantity) = getBidByRank(rank);\n\n        // require(TFHE.isAllowed(price, address(this)), \"This is not allowed to access price\");\n        // require(TFHE.isAllowed(quantity, address(this)), \"This is not allowed to access quantity\");\n        // require(TFHE.isAllowed(id, address(this)), \"This is not allowed to access id\");\n\n        TFHE.allow(id, account);\n        TFHE.allow(price, account);\n        TFHE.allow(quantity, account);\n    }\n\n    function allowAccountToAccessBidByIndex(uint16 idx, address account) public {\n        require(address(this) == msg.sender, \"Sender is not this\");\n        (, euint256 price, euint256 quantity) = getBidByIndex(idx);\n\n        // require(TFHE.isAllowed(price, address(this)), \"This is not allowed to access price\");\n        // require(TFHE.isAllowed(quantity, address(this)), \"This is not allowed to access quantity\");\n\n        TFHE.allow(price, account);\n        TFHE.allow(quantity, account);\n    }\n\n    function _computeAuctionStepIterations(uint8 step, uint64 chunckSize) internal returns (uint8) {\n        FHEAuctionEngineIterator aei = FHEAuctionEngineIterator(iterator());\n\n        uint8 s = aei.step();\n        if (s > step) {\n            return S_FINISHED;\n        }\n        require(s == step, \"s != step\");\n\n        uint64 mx = aei.getStepIterProgressMax(s);\n        chunckSize = (chunckSize > mx) ? mx : chunckSize;\n\n        (uint8 code,,) = aei.computeAuctionIterations(chunckSize, false);\n        return code;\n    }\n\n    // ====================================================================== //\n    //\n    //                    ⭐️ Step 1/4: Bid Validation ⭐️\n    //\n    // ====================================================================== //\n\n    function validationCompleted() public view returns (bool) {\n        return FHEAuctionEngineIterator(iterator()).step() > STEP_1_VALIDATION;\n    }\n\n    function validationProgress() external view returns (uint32) {\n        return FHEAuctionEngineIterator(iterator()).getStepProgress(STEP_1_VALIDATION);\n    }\n\n    function validationProgressMax() external view returns (uint32) {\n        return FHEAuctionEngineIterator(iterator()).getStepProgressMax(STEP_1_VALIDATION);\n    }\n\n    function computeValidation(uint64 chunckSize) external whenClosed returns (uint8) {\n        return _computeAuctionStepIterations(STEP_1_VALIDATION, chunckSize);\n    }\n\n    // ====================================================================== //\n    //\n    //                ⭐️ Step 2/4: Sort Bids by Rank Order ⭐️\n    //\n    // ====================================================================== //\n\n    function sortCompleted() public view returns (bool) {\n        //return _rankedBidCount == _bidCount && _bidCount > 0;\n        return FHEAuctionEngineIterator(iterator()).step() > STEP_2_SORT;\n    }\n\n    function sortProgress() external view returns (uint32) {\n        return FHEAuctionEngineIterator(iterator()).getStepProgress(STEP_2_SORT);\n    }\n\n    function sortProgressMax() external view returns (uint32) {\n        //return _rankedBidsProgressMax(_bidCount);\n        return FHEAuctionEngineIterator(iterator()).getStepProgressMax(STEP_2_SORT);\n    }\n\n    function computeSort(uint64 chunckSize) external whenClosed returns (uint8) {\n        return _computeAuctionStepIterations(STEP_2_SORT, chunckSize);\n    }\n\n    // ====================================================================== //\n    //\n    //              ⭐️ Step 3/4: Compute Ranked Won Quantities ⭐️\n    //\n    // ====================================================================== //\n\n    function wonQuantitiesByRankProgress() external view returns (uint32) {\n        //return _resumeIdxRWQ;\n        return FHEAuctionEngineIterator(iterator()).getStepProgress(STEP_3_WON_QUANTITIES_BY_RANK);\n    }\n\n    function wonQuantitiesByRankProgressMax() external view returns (uint32) {\n        //return _bidCount;\n        return FHEAuctionEngineIterator(iterator()).getStepProgressMax(STEP_3_WON_QUANTITIES_BY_RANK);\n    }\n\n    function computeWonQuantitiesByRank(uint64 chunckSize) external returns (uint8) {\n        return _computeAuctionStepIterations(STEP_3_WON_QUANTITIES_BY_RANK, chunckSize);\n    }\n\n    // ====================================================================== //\n    //\n    //                ⭐️ Step 4/4: Compute Won Quantities ⭐️\n    //\n    // ====================================================================== //\n\n    function wonQuantitiesByIdProgress() external view returns (uint32) {\n        //return _idxWQ * _bidCount + _resumeIdxWQ;\n        return FHEAuctionEngineIterator(iterator()).getStepProgress(STEP_4_WON_QUANTITIES_BY_ID);\n    }\n\n    function wonQuantitiesByIdProgressMax() external view returns (uint32) {\n        //return _bidCount * _bidCount;\n        return FHEAuctionEngineIterator(iterator()).getStepProgressMax(STEP_4_WON_QUANTITIES_BY_ID);\n    }\n\n    function computeWonQuantitiesById(uint64 chunckSize) external returns (uint8) {\n        return _computeAuctionStepIterations(STEP_4_WON_QUANTITIES_BY_ID, chunckSize);\n    }\n}\n"
    },
    "contracts/mocks/engines/FHEAuctionEnginePriceIdMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionEngineBaseMock} from \"./FHEAuctionEngineBaseMock.sol\";\nimport {FHEAuctionEnginePriceId} from \"../../engines/FHEAuctionEnginePriceId.sol\";\n\ncontract FHEAuctionEnginePriceIdMock is FHEAuctionEngineBaseMock, FHEAuctionEnginePriceId {\n    constructor(address auction_, address iterator_) FHEAuctionEnginePriceId(auction_, iterator_) {}\n}\n"
    },
    "contracts/mocks/engines/FHEAuctionEnginePriceQuantityIdMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionEngineBaseMock} from \"./FHEAuctionEngineBaseMock.sol\";\nimport {FHEAuctionEnginePriceQuantityId} from \"../../engines/FHEAuctionEnginePriceQuantityId.sol\";\n\ncontract FHEAuctionEnginePriceQuantityIdMock is FHEAuctionEngineBaseMock, FHEAuctionEnginePriceQuantityId {\n    constructor(address auction_, address iterator_) FHEAuctionEnginePriceQuantityId(auction_, iterator_) {}\n}\n"
    },
    "contracts/mocks/engines/FHEAuctionEnginePriceRandomMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionEngineBaseMock} from \"./FHEAuctionEngineBaseMock.sol\";\nimport {FHEAuctionEnginePriceRandom} from \"../../engines/FHEAuctionEnginePriceRandom.sol\";\n\ncontract FHEAuctionEnginePriceRandomMock is FHEAuctionEngineBaseMock, FHEAuctionEnginePriceRandom {\n    constructor(address auction_, address iterator_) FHEAuctionEnginePriceRandom(auction_, iterator_) {}\n}\n"
    },
    "contracts/mocks/engines/FHEAuctionEngineProRataMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FHEAuctionEngineBaseMock} from \"./FHEAuctionEngineBaseMock.sol\";\nimport {FHEAuctionEngineProRata} from \"../../engines/FHEAuctionEngineProRata.sol\";\n\ncontract FHEAuctionEngineProRataMock is FHEAuctionEngineBaseMock, FHEAuctionEngineProRata {\n    constructor(address auction_, address iterator_) FHEAuctionEngineProRata(auction_, iterator_) {}\n}\n"
    },
    "contracts/mocks/FourStepsIteratorMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FourStepsIterator, IFourStepsIterable, S_FINISHED, S_NOT_FINISHED} from \"../FourStepsIterator.sol\";\n\ncontract FourStepsIteratorMock is FourStepsIterator, IFourStepsIterable {\n    uint64[] private _theCumulatives;\n    uint32[] private _theStepProgress;\n    Step[] private _theSteps;\n\n    constructor(address initialOwner) FourStepsIterator(initialOwner) {}\n\n    function initializeFourSteps(Step[] calldata fourSteps) external {\n        for (uint8 i = 0; i < 4; ++i) {\n            _theSteps.push(Step({size: 0, nativeGasWeight: 0, unitFheGasCost: 0}));\n            _theStepProgress.push(0);\n            _theCumulatives.push(0);\n\n            if (fourSteps.length > i) {\n                _theSteps[i].size = fourSteps[i].size;\n                _theSteps[i].nativeGasWeight = fourSteps[i].nativeGasWeight;\n                _theSteps[i].unitFheGasCost = fourSteps[i].unitFheGasCost;\n                if (i == 0) {\n                    _theCumulatives[0] = fourSteps[0].size * fourSteps[0].nativeGasWeight;\n                } else {\n                    _theCumulatives[i] = fourSteps[i].size * fourSteps[i].nativeGasWeight + _theCumulatives[i - 1];\n                }\n            }\n        }\n\n        _initializeFourSteps(fourSteps);\n    }\n\n    function next(uint32 iter, uint8 stopAfterStep)\n        external\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\n    {\n        return _next(iter, stopAfterStep);\n    }\n\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax)\n        public\n        virtual\n        override\n        returns (uint8, uint32)\n    {\n        return _runStep(0, progress, iter, progressMax);\n    }\n\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax)\n        public\n        virtual\n        override\n        returns (uint8, uint32)\n    {\n        return _runStep(1, progress, iter, progressMax);\n    }\n\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax)\n        public\n        virtual\n        override\n        returns (uint8, uint32)\n    {\n        return _runStep(2, progress, iter, progressMax);\n    }\n\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax)\n        public\n        virtual\n        override\n        returns (uint8, uint32)\n    {\n        return _runStep(3, progress, iter, progressMax);\n    }\n\n    function _runStep(uint8 idx, uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\n        require(iter > 0, \"iter == 0\");\n        require(_theStepProgress[idx] < _theSteps[idx].size, \"_stepProgress >= _step.size\");\n        require(_theStepProgress[idx] == progress, \"_stepProgress != progress\");\n        require(progress + iter <= _theSteps[idx].size, \"progress + iter > _step.size\");\n        require(progressMax == _theSteps[idx].size, \"progressMax != _theSteps[idx].size\");\n        require(\n            _minIterProgressForStep(idx) == _theCumulatives[idx], \"_minIterProgressForStep(idx) != _theCumulatives[idx]\"\n        );\n\n        _theStepProgress[idx] = progress + iter;\n\n        uint8 code = (progress + iter == _theSteps[idx].size) ? S_FINISHED : S_NOT_FINISHED;\n\n        return (code, iter);\n    }\n}\n"
    },
    "contracts/TimedAuction.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {ITimedAuction} from \"./ITimedAuction.sol\";\n\nabstract contract TimedAuction is ITimedAuction {\n    uint256 private _startTime;\n    uint256 private _endTime;\n    uint256 private _flags;\n    bool private _stoppable;\n\n    /*\n     * State Graph:\n     * ------------\n     *         UNINITIALIZED               ->  INITIALIZED\n     *         INITIALIZED                 ->  INITIALIZED_TERMINATED\n     *                                         INITIALIZED_STARTED\n     *         INITIALIZED_STARTED         ->  INITIALIZED_STARTED_ENDED\n     *                                         INITIALIZED_STARTED_ENDED_TERMINATED\n     *         INITIALIZED_STARTED_ENDED   ->  INITIALIZED_STARTED_ENDED_TERMINATED\n     */\n\n    uint256 private constant UNINITIALIZED = uint256(0x0);\n    uint256 private constant INITIALIZED = uint256(0x1);\n    uint256 private constant INITIALIZED_TERMINATED = uint256(0x9);\n    uint256 private constant INITIALIZED_STARTED = uint256(0x3);\n    uint256 private constant INITIALIZED_STARTED_ENDED = uint256(0x7);\n    uint256 private constant INITIALIZED_STARTED_ENDED_TERMINATED = uint256(0xF);\n\n    uint256 private constant FLAGS_INITIALIZED = uint256(0x1);\n    uint256 private constant FLAGS_STARTED = uint256(0x2);\n    uint256 private constant FLAGS_ENDED = uint256(0x4);\n    uint256 private constant FLAGS_TERMINATED = uint256(0x8);\n\n    error NotInitialized();\n    error NotInitializable();\n    error NotStartable();\n    error NotStoppable();\n    error NotTerminable();\n    error NotStarted();\n    error NotOpen();\n    error NotClosed();\n    error InvalidDuration();\n\n    constructor() {}\n\n    function durationInSeconds() public view returns (uint256) {\n        return _endTime - _startTime;\n    }\n\n    function startTime() public view returns (uint256) {\n        return _startTime;\n    }\n\n    function endTime() public view returns (uint256) {\n        return _endTime;\n    }\n\n    function _state() internal view returns (uint256) {\n        uint256 f = _flags;\n        if (f == INITIALIZED_STARTED) {\n            if (block.timestamp >= _endTime) {\n                return f | FLAGS_ENDED;\n            }\n        }\n        return f;\n    }\n\n    function _initialize() internal whenInitializable {\n        _flags = INITIALIZED;\n    }\n\n    function _start(uint256 durationInSeconds_, bool stoppable_) internal whenStartable {\n        if (durationInSeconds_ == 0) {\n            revert InvalidDuration();\n        }\n\n        _flags = INITIALIZED_STARTED;\n\n        _startTime = block.timestamp;\n        _endTime = _startTime + durationInSeconds_;\n        _stoppable = stoppable_;\n    }\n\n    function _stop() internal whenStoppable {\n        _flags = INITIALIZED_STARTED_ENDED;\n    }\n\n    function _terminate() internal whenTerminable {\n        if (_flags == INITIALIZED) {\n            _flags = INITIALIZED_TERMINATED;\n        } else {\n            _flags = INITIALIZED_STARTED_ENDED_TERMINATED;\n        }\n    }\n\n    /**\n     * @notice Returns `true` if the auction can be manually stopped.\n     */\n    function stoppable() public view returns (bool) {\n        return _stoppable;\n    }\n\n    /**\n     * @notice Returns `true` if the auction is ready to start, `false` otherwise.\n     */\n    function canStart() public view returns (bool) {\n        return _flags == INITIALIZED;\n    }\n\n    /**\n     * @notice Returns `true` if the auction can be stopped by calling the {stop} function, `false` otherwise.\n     */\n    function canStop() public view returns (bool) {\n        return (_flags == INITIALIZED_STARTED) && _stoppable;\n    }\n\n    /**\n     * @notice Returns `true` if the auction can be terminated by calling the {terminate} function, `false` otherwise.\n     */\n    function canTerminate() public view returns (bool) {\n        uint256 f = _flags;\n        if (f == UNINITIALIZED || f == INITIALIZED_TERMINATED || f == INITIALIZED_STARTED_ENDED_TERMINATED) {\n            return false;\n        }\n\n        // state == INITIALIZED or INITIALIZED_STARTED or INITIALIZED_STARTED_ENDED\n        uint256 state = _state();\n        if (state == INITIALIZED_STARTED || state == INITIALIZED_STARTED_ENDED) {\n            if (!_canTerminateAfterStart()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _canTerminateAfterStart() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns `true` if the auction has been initialized, `false` otherwise.\n     */\n    function initialized() public view returns (bool) {\n        return _flags != UNINITIALIZED;\n    }\n\n    /**\n     * @notice Returns `true` if the auction is initialized and ready to accept bids, `false` otherwise.\n     */\n    function isOpen() public view returns (bool) {\n        return _state() == INITIALIZED_STARTED;\n    }\n\n    /**\n     * @notice Returns the auction status code. Can be one of the following values.\n     *      - UNINITIALIZED = uint256(0x0)\n     *      - INITIALIZED = uint256(0x1)\n     *      - INITIALIZED_TERMINATED = uint256(0x9)\n     *      - INITIALIZED_STARTED = uint256(0x3)\n     *      - INITIALIZED_STARTED_ENDED = uint256(0x7)\n     *      - INITIALIZED_STARTED_ENDED_TERMINATED = uint256(0xF)\n     */\n    function statusCode() public view returns (uint256) {\n        return _state();\n    }\n\n    /**\n     * @notice Returns `true` if the auction is ready to compute the auction prizes, `false` otherwise.\n     * When the auction is closed, it can no more accept bids.\n     */\n    function closed() public view returns (bool) {\n        return _state() == INITIALIZED_STARTED_ENDED;\n    }\n\n    function terminated() public view returns (bool) {\n        return _flags & FLAGS_TERMINATED != 0;\n    }\n\n    /**\n     * @dev Throws if the auction cannot be initialized.\n     */\n    modifier whenInitializable() {\n        if (_flags != UNINITIALIZED) {\n            revert NotInitializable();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction is not initialized.\n     */\n    modifier whenInitialized() {\n        if (!initialized()) {\n            revert NotInitialized();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction cannot be started.\n     */\n    modifier whenStartable() {\n        if (!canStart()) {\n            revert NotStartable();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction cannot be stopped.\n     */\n    modifier whenStoppable() {\n        if (!canStop()) {\n            revert NotStoppable();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction cannot be terminated.\n     */\n    modifier whenTerminable() {\n        if (!canTerminate()) {\n            revert NotTerminable();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction is not started.\n     */\n    modifier whenStarted() {\n        if ((_state() & FLAGS_STARTED) != 0) {\n            revert NotStarted();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction is not open and accepting new bids.\n     */\n    modifier whenIsOpen() {\n        _requireIsOpen();\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction is not closed (in prize computing state).\n     */\n    modifier whenClosed() {\n        if (!closed()) {\n            revert NotClosed();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if the auction is not open and accepting new bids.\n     */\n    function _requireIsOpen() internal view virtual {\n        if (_state() != INITIALIZED_STARTED) {\n            revert NotOpen();\n        }\n    }\n}\n"
    },
    "fhevm/config/ZamaFHEVMConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE} from \"../lib/TFHE.sol\";\nimport {FHEVMConfigStruct} from \"../lib/Impl.sol\";\n\n/**\n * @title   ZamaFHEVMConfig.\n * @notice  This library returns the TFHE config for different networks\n *          with the contract addresses for\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\n *          which are deployed & maintained by Zama.\n */\nlibrary ZamaFHEVMConfig {\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\n        return\n            FHEVMConfigStruct({\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\n            });\n    }\n\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Sepolia network (chainId = 11155111).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/config/ZamaGatewayConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Gateway} from \"../gateway/lib/Gateway.sol\";\n\n/**\n * @title   ZamaGatewayConfig.\n * @notice  This library returns the Gateway config for different networks\n *          with the address of the Gateway contract, which is\n *          deployed & maintained by Zama.\n */\nlibrary ZamaGatewayConfig {\n    function getSepoliaConfig() internal pure returns (address) {\n        return 0x33347831500F1e73f0ccCBb95c9f86B94d7b1123;\n    }\n\n    function getEthereumConfig() internal pure returns (address) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Sepolia network (chainId = 11155111).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/gateway/GatewayCaller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../lib/TFHE.sol\";\nimport \"./lib/Gateway.sol\";\n\nabstract contract GatewayCaller {\n    modifier onlyGateway() {\n        require(msg.sender == Gateway.gatewayContractAddress());\n        _;\n    }\n    mapping(uint256 => ebool[]) private paramsEBool;\n    mapping(uint256 => euint4[]) private paramsEUint4;\n    mapping(uint256 => euint8[]) private paramsEUint8;\n    mapping(uint256 => euint16[]) private paramsEUint16;\n    mapping(uint256 => euint32[]) private paramsEUint32;\n    mapping(uint256 => euint64[]) private paramsEUint64;\n    mapping(uint256 => eaddress[]) private paramsEAddress;\n    mapping(uint256 => address[]) private paramsAddress;\n    mapping(uint256 => uint256[]) private paramsUint256;\n    mapping(uint256 => uint256[]) private requestedHandles;\n\n    constructor() {}\n\n    function addParamsEBool(uint256 requestID, ebool _ebool) internal {\n        paramsEBool[requestID].push(_ebool);\n    }\n\n    function addParamsEUint4(uint256 requestID, euint4 _euint4) internal {\n        paramsEUint4[requestID].push(_euint4);\n    }\n\n    function addParamsEUint8(uint256 requestID, euint8 _euint8) internal {\n        paramsEUint8[requestID].push(_euint8);\n    }\n\n    function addParamsEUint16(uint256 requestID, euint16 _euint16) internal {\n        paramsEUint16[requestID].push(_euint16);\n    }\n\n    function addParamsEUint32(uint256 requestID, euint32 _euint32) internal {\n        paramsEUint32[requestID].push(_euint32);\n    }\n\n    function addParamsEUint64(uint256 requestID, euint64 _euint64) internal {\n        paramsEUint64[requestID].push(_euint64);\n    }\n\n    function addParamsEAddress(uint256 requestID, eaddress _eaddress) internal {\n        paramsEAddress[requestID].push(_eaddress);\n    }\n\n    function addParamsAddress(uint256 requestID, address _address) internal {\n        paramsAddress[requestID].push(_address);\n    }\n\n    function addParamsUint256(uint256 requestID, uint256 _uint) internal {\n        paramsUint256[requestID].push(_uint);\n    }\n\n    function saveRequestedHandles(uint256 requestID, uint256[] memory handlesList) internal {\n        require(requestedHandles[requestID].length == 0, \"requested handles already saved\");\n        requestedHandles[requestID] = handlesList;\n    }\n\n    function loadRequestedHandles(uint256 requestID) internal view returns (uint256[] memory) {\n        require(requestedHandles[requestID].length != 0, \"requested handles were not saved for this requestID\");\n        return requestedHandles[requestID];\n    }\n\n    function getParamsEBool(uint256 requestID) internal view returns (ebool[] memory) {\n        return paramsEBool[requestID];\n    }\n\n    function getParamsEUint4(uint256 requestID) internal view returns (euint4[] memory) {\n        return paramsEUint4[requestID];\n    }\n\n    function getParamsEUint8(uint256 requestID) internal view returns (euint8[] memory) {\n        return paramsEUint8[requestID];\n    }\n\n    function getParamsEUint16(uint256 requestID) internal view returns (euint16[] memory) {\n        return paramsEUint16[requestID];\n    }\n\n    function getParamsEUint32(uint256 requestID) internal view returns (euint32[] memory) {\n        return paramsEUint32[requestID];\n    }\n\n    function getParamsEUint64(uint256 requestID) internal view returns (euint64[] memory) {\n        return paramsEUint64[requestID];\n    }\n\n    function getParamsEAddress(uint256 requestID) internal view returns (eaddress[] memory) {\n        return paramsEAddress[requestID];\n    }\n\n    function getParamsAddress(uint256 requestID) internal view returns (address[] memory) {\n        return paramsAddress[requestID];\n    }\n\n    function getParamsUint256(uint256 requestID) internal view returns (uint256[] memory) {\n        return paramsUint256[requestID];\n    }\n}\n"
    },
    "fhevm/gateway/lib/Gateway.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../../lib/Impl.sol\";\n\ninterface IKMSVerifier {\n    function verifyDecryptionEIP712KMSSignatures(\n        address aclAddress,\n        uint256[] memory handlesList,\n        bytes memory decryptedResult,\n        bytes[] memory signatures\n    ) external returns (bool);\n}\n\ninterface IGatewayContract {\n    function requestDecryption(\n        uint256[] calldata ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) external returns (uint256);\n}\n\nstruct GatewayConfigStruct {\n    address GatewayContractAddress;\n}\n\nlibrary Gateway {\n    // keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.GatewayConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GatewayLocation = 0x93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700;\n\n    function getGetwayConfig() internal pure returns (GatewayConfigStruct storage $) {\n        assembly {\n            $.slot := GatewayLocation\n        }\n    }\n\n    function setGateway(address gatewayAddress) internal {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        $.GatewayContractAddress = gatewayAddress;\n    }\n\n    function gatewayContractAddress() internal view returns (address) {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        return $.GatewayContractAddress;\n    }\n\n    function toUint256(ebool newCT) internal pure returns (uint256 ct) {\n        ct = ebool.unwrap(newCT);\n    }\n\n    function toUint256(euint4 newCT) internal pure returns (uint256 ct) {\n        ct = euint4.unwrap(newCT);\n    }\n\n    function toUint256(euint8 newCT) internal pure returns (uint256 ct) {\n        ct = euint8.unwrap(newCT);\n    }\n\n    function toUint256(euint16 newCT) internal pure returns (uint256 ct) {\n        ct = euint16.unwrap(newCT);\n    }\n\n    function toUint256(euint32 newCT) internal pure returns (uint256 ct) {\n        ct = euint32.unwrap(newCT);\n    }\n\n    function toUint256(euint64 newCT) internal pure returns (uint256 ct) {\n        ct = euint64.unwrap(newCT);\n    }\n\n    function toUint256(euint128 newCT) internal pure returns (uint256 ct) {\n        ct = euint128.unwrap(newCT);\n    }\n\n    function toUint256(eaddress newCT) internal pure returns (uint256 ct) {\n        ct = eaddress.unwrap(newCT);\n    }\n\n    function toUint256(euint256 newCT) internal pure returns (uint256 ct) {\n        ct = euint256.unwrap(newCT);\n    }\n\n    function toUint256(ebytes64 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes64.unwrap(newCT);\n    }\n\n    function toUint256(ebytes128 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes128.unwrap(newCT);\n    }\n\n    function toUint256(ebytes256 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes256.unwrap(newCT);\n    }\n\n    function requestDecryption(\n        uint256[] memory ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) internal returns (uint256 requestID) {\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        IACL($.ACLAddress).allowForDecryption(ctsHandles);\n        GatewayConfigStruct storage $$ = getGetwayConfig();\n        requestID = IGatewayContract($$.GatewayContractAddress).requestDecryption(\n            ctsHandles,\n            callbackSelector,\n            msgValue,\n            maxTimestamp,\n            passSignaturesToCaller\n        );\n    }\n\n    /// @dev this function is supposed to be called inside the callback function if the dev wants the dApp contract to verify the signatures\n    /// @dev this is useful to give dev the choice not to rely on trusting the GatewayContract.\n    /// @notice this could be used only when signatures are made available to the callback, i.e when `passSignaturesToCaller` is set to true during request\n    function verifySignatures(uint256[] memory handlesList, bytes[] memory signatures) internal returns (bool) {\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\n        uint256 length = getSignedDataLength(handlesList);\n        bytes memory decryptedResult = new bytes(length);\n        assembly {\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\n        }\n        decryptedResult = shiftOffsets(decryptedResult, handlesList);\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        return\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\n                $.ACLAddress,\n                handlesList,\n                decryptedResult,\n                signatures\n            );\n    }\n\n    function getSignedDataLength(uint256[] memory handlesList) private pure returns (uint256) {\n        uint256 handlesListlen = handlesList.length;\n        uint256 signedDataLength;\n        for (uint256 i = 0; i < handlesListlen; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt < 9) {\n                signedDataLength += 32;\n            } else if (typeCt == 9) {\n                //ebytes64\n                signedDataLength += 128;\n            } else if (typeCt == 10) {\n                //ebytes128\n                signedDataLength += 192;\n            } else if (typeCt == 11) {\n                //ebytes256\n                signedDataLength += 320;\n            } else {\n                revert(\"Unsupported handle type\");\n            }\n        }\n        signedDataLength += 32; // add offset of signatures\n        return signedDataLength;\n    }\n\n    function shiftOffsets(bytes memory input, uint256[] memory handlesList) private pure returns (bytes memory) {\n        uint256 numArgs = handlesList.length;\n        for (uint256 i = 0; i < numArgs; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt >= 9) {\n                input = subToBytes32Slice(input, 32 * i); // because we append the signatures, all bytes offsets are shifted by 0x20\n            }\n        }\n        input = remove32Slice(input, 32 * numArgs);\n        return input;\n    }\n\n    function subToBytes32Slice(bytes memory data, uint256 offset) private pure returns (bytes memory) {\n        // @note: data is assumed to be more than 32+offset bytes long\n        assembly {\n            let ptr := add(add(data, 0x20), offset)\n            let val := mload(ptr)\n            val := sub(val, 0x20)\n            mstore(ptr, val)\n        }\n        return data;\n    }\n\n    function remove32Slice(bytes memory input, uint256 start) private pure returns (bytes memory) {\n        // @note we assume start+32 is less than input.length\n        bytes memory result = new bytes(input.length - 32);\n\n        for (uint256 i = 0; i < start; i++) {\n            result[i] = input[i];\n        }\n\n        for (uint256 i = start + 32; i < input.length; i++) {\n            result[i - 32] = input[i];\n        }\n\n        return result;\n    }\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./TFHE.sol\";\n//import {console} from \"hardhat/console.sol\";\n\n/**\n * @title   FHEVMConfigStruct\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\n */\nstruct FHEVMConfigStruct {\n    address ACLAddress;\n    address TFHEExecutorAddress;\n    address FHEPaymentAddress;\n    address KMSVerifierAddress;\n}\n\n/**\n * @title   ITFHEExecutor\n * @notice  This interface contains all functions to conduct FHE operations.\n */\ninterface ITFHEExecutor {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNeg(uint256 ct) external returns (uint256 result);\n    function fheNot(uint256 ct) external returns (uint256 result);\n    function verifyCiphertext(\n        bytes32 inputHandle,\n        address callerAddress,\n        bytes memory inputProof,\n        bytes1 inputType\n    ) external returns (uint256 result);\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\n    function fheRand(bytes1 randType) external returns (uint256 result);\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\n}\n\n/**\n * @title   IACL\n * @notice  This interface contains all functions that are used to conduct operations\n *          with the ACL contract.\n */\ninterface IACL {\n    function allowTransient(uint256 ciphertext, address account) external;\n    function allow(uint256 handle, address account) external;\n    function cleanTransientStorage() external;\n    function isAllowed(uint256 handle, address account) external view returns (bool);\n    function allowForDecryption(uint256[] memory handlesList) external;\n}\n\n/**\n * @title   Impl\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\n */\nlibrary Impl {\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.FHEVMConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\n\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\n        assembly {\n            $.slot := FHEVMConfigLocation\n        }\n    }\n\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        $.ACLAddress = fhevmConfig.ACLAddress;\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\n    }\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\n    }\n\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\n            inputHandle,\n            msg.sender,\n            inputProof,\n            bytes1(toType)\n        );\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function rand(uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\n    }\n\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\n    }\n\n    function allowTransient(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allowTransient(handle, account);\n    }\n\n    function allow(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allow(handle, account);\n    }\n\n    function cleanTransientStorage() internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).cleanTransientStorage();\n    }\n\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        return IACL($.ACLAddress).isAllowed(handle, account);\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./Impl.sol\";\n\ntype ebool is uint256;\ntype euint4 is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\ntype euint64 is uint256;\ntype euint128 is uint256;\ntype euint256 is uint256;\ntype eaddress is uint256;\ntype ebytes64 is uint256;\ntype ebytes128 is uint256;\ntype ebytes256 is uint256;\ntype einput is bytes32;\n\n/**\n * @title   Common\n * @notice  This library contains all the values used to communicate types to the run time.\n */\nlibrary Common {\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint4_t = 1;\n    uint8 internal constant euint8_t = 2;\n    uint8 internal constant euint16_t = 3;\n    uint8 internal constant euint32_t = 4;\n    uint8 internal constant euint64_t = 5;\n    uint8 internal constant euint128_t = 6;\n    uint8 internal constant euint160_t = 7;\n    uint8 internal constant euint256_t = 8;\n    uint8 internal constant ebytes64_t = 9;\n    uint8 internal constant ebytes128_t = 10;\n    uint8 internal constant ebytes256_t = 11;\n}\n\n/**\n * @title   TFHE\n * @notice  This library is the interaction point for all smart contract developers\n *          that interact with TFHE.\n */\nlibrary TFHE {\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        Impl.setFHEVM(fhevmConfig);\n    }\n\n    // Return true if the enrypted bool is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint4 v) internal pure returns (bool) {\n        return euint4.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return euint64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return euint128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return euint256.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\n        euint4 aEnc = asEuint4(a);\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\n        euint64 aEnc = asEuint64(a);\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\n        euint128 aEnc = asEuint128(a);\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\n        euint256 aEnc = asEuint256(a);\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\n    }\n    // Cast an encrypted integer from euint8 to euint4.\n    function asEuint4(euint8 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint4.\n    function asEuint4(euint16 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint4.\n    function asEuint4(euint32 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint4.\n    function asEuint4(euint64 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint4.\n    function asEuint4(euint128 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint4.\n    function asEuint4(euint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to ebool.\n    function asEbool(euint4 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint4'.\n    function asEuint4(ebool b) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint8.\n    function asEuint8(euint4 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint8.\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint8.\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint8.\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\n    }\n\n    // Convert a plaintext value to an encrypted boolean.\n    function asEbool(uint256 value) internal returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal returns (ebool) {\n        if (value) {\n            return asEbool(1);\n        } else {\n            return asEbool(0);\n        }\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    function not(ebool a) internal returns (ebool) {\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\n    }\n\n    // Cast an encrypted integer from euint4 to euint16.\n    function asEuint16(euint4 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint16.\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint16.\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint16.\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint16'.\n    function asEuint16(ebool b) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint32.\n    function asEuint32(euint4 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint32.\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint32.\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint32.\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint32'.\n    function asEuint32(ebool b) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint64.\n    function asEuint64(euint4 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint64.\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint64.\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint64.\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint64.\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint64.\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint64 to ebool.\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint64'.\n    function asEuint64(ebool b) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint128.\n    function asEuint128(euint4 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint128.\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint128.\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint128.\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint128.\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint128.\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint128 to ebool.\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint128'.\n    function asEuint128(ebool b) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint256.\n    function asEuint256(euint4 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint256.\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint256.\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint256.\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint256.\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint256.\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint256 to ebool.\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint256'.\n    function asEuint256(ebool b) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\n    }\n\n    function neg(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\n    }\n\n    function not(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\n    }\n\n    function neg(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    function neg(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\n    }\n\n    function not(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\n    }\n\n    function neg(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\n    }\n\n    function not(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\n    }\n\n    function neg(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\n    }\n\n    function not(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint4 integer.\n    function asEuint4(uint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint64 integer.\n    function asEuint64(uint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint128 integer.\n    function asEuint128(uint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint256 integer.\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\n    }\n\n    // Generates a random encrypted boolean.\n    function randEbool() internal returns (ebool) {\n        return ebool.wrap(Impl.rand(Common.ebool_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer.\n    function randEuint4() internal returns (euint4) {\n        return euint4.wrap(Impl.rand(Common.euint4_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    function randEuint8() internal returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    function randEuint16() internal returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    function randEuint32() internal returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer.\n    function randEuint64() internal returns (euint64) {\n        return euint64.wrap(Impl.rand(Common.euint64_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer.\n    function randEuint128() internal returns (euint128) {\n        return euint128.wrap(Impl.rand(Common.euint128_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer.\n    function randEuint256() internal returns (euint256) {\n        return euint256.wrap(Impl.rand(Common.euint256_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\n    }\n\n    // Generates a random encrypted 512-bit unsigned integer.\n    function randEbytes64() internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\n    }\n\n    // Generates a random encrypted 1024-bit unsigned integer.\n    function randEbytes128() internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\n    }\n\n    // Generates a random encrypted 2048-bit unsigned integer.\n    function randEbytes256() internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\n    }\n\n    // Convert a plaintext value to an encrypted address.\n    function asEaddress(address value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 64, \"Input exceeds 64 bytes\");\n        bytes memory result = new bytes(64);\n        uint256 paddingLength = 64 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 128, \"Input exceeds 128 bytes\");\n        bytes memory result = new bytes(128);\n        uint256 paddingLength = 128 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 256, \"Input exceeds 256 bytes\");\n        bytes memory result = new bytes(256);\n        uint256 paddingLength = 256 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\n    }\n\n    // Return true if the enrypted address is initialized and false otherwise.\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return eaddress.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\n        return ebytes64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\n        return ebytes128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\n        return ebytes256.unwrap(v) != 0;\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\n    }\n\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\n    function cleanTransientStorage() internal {\n        return Impl.cleanTransientStorage();\n    }\n\n    function isAllowed(ebool value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), account);\n    }\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), account);\n    }\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), account);\n    }\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), account);\n    }\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), account);\n    }\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), account);\n    }\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), account);\n    }\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), account);\n    }\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), account);\n    }\n\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\n    }\n\n    function isSenderAllowed(ebool value) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\n    }\n\n    function allow(ebool value, address account) internal {\n        Impl.allow(ebool.unwrap(value), account);\n    }\n\n    function allowThis(ebool value) internal {\n        Impl.allow(ebool.unwrap(value), address(this));\n    }\n\n    function allow(euint4 value, address account) internal {\n        Impl.allow(euint4.unwrap(value), account);\n    }\n\n    function allowThis(euint4 value) internal {\n        Impl.allow(euint4.unwrap(value), address(this));\n    }\n\n    function allow(euint8 value, address account) internal {\n        Impl.allow(euint8.unwrap(value), account);\n    }\n\n    function allowThis(euint8 value) internal {\n        Impl.allow(euint8.unwrap(value), address(this));\n    }\n\n    function allow(euint16 value, address account) internal {\n        Impl.allow(euint16.unwrap(value), account);\n    }\n\n    function allowThis(euint16 value) internal {\n        Impl.allow(euint16.unwrap(value), address(this));\n    }\n\n    function allow(euint32 value, address account) internal {\n        Impl.allow(euint32.unwrap(value), account);\n    }\n\n    function allowThis(euint32 value) internal {\n        Impl.allow(euint32.unwrap(value), address(this));\n    }\n\n    function allow(euint64 value, address account) internal {\n        Impl.allow(euint64.unwrap(value), account);\n    }\n\n    function allowThis(euint64 value) internal {\n        Impl.allow(euint64.unwrap(value), address(this));\n    }\n\n    function allow(euint128 value, address account) internal {\n        Impl.allow(euint128.unwrap(value), account);\n    }\n\n    function allowThis(euint128 value) internal {\n        Impl.allow(euint128.unwrap(value), address(this));\n    }\n\n    function allow(euint256 value, address account) internal {\n        Impl.allow(euint256.unwrap(value), account);\n    }\n\n    function allowThis(euint256 value) internal {\n        Impl.allow(euint256.unwrap(value), address(this));\n    }\n\n    function allow(eaddress value, address account) internal {\n        Impl.allow(eaddress.unwrap(value), account);\n    }\n\n    function allowThis(eaddress value) internal {\n        Impl.allow(eaddress.unwrap(value), address(this));\n    }\n\n    function allow(ebytes64 value, address account) internal {\n        Impl.allow(ebytes64.unwrap(value), account);\n    }\n\n    function allowThis(ebytes64 value) internal {\n        Impl.allow(ebytes64.unwrap(value), address(this));\n    }\n\n    function allow(ebytes128 value, address account) internal {\n        Impl.allow(ebytes128.unwrap(value), account);\n    }\n\n    function allowThis(ebytes128 value) internal {\n        Impl.allow(ebytes128.unwrap(value), address(this));\n    }\n\n    function allow(ebytes256 value, address account) internal {\n        Impl.allow(ebytes256.unwrap(value), account);\n    }\n\n    function allowThis(ebytes256 value) internal {\n        Impl.allow(ebytes256.unwrap(value), address(this));\n    }\n\n    function allowTransient(ebool value, address account) internal {\n        Impl.allowTransient(ebool.unwrap(value), account);\n    }\n\n    function allowTransient(euint4 value, address account) internal {\n        Impl.allowTransient(euint4.unwrap(value), account);\n    }\n\n    function allowTransient(euint8 value, address account) internal {\n        Impl.allowTransient(euint8.unwrap(value), account);\n    }\n\n    function allowTransient(euint16 value, address account) internal {\n        Impl.allowTransient(euint16.unwrap(value), account);\n    }\n\n    function allowTransient(euint32 value, address account) internal {\n        Impl.allowTransient(euint32.unwrap(value), account);\n    }\n\n    function allowTransient(euint64 value, address account) internal {\n        Impl.allowTransient(euint64.unwrap(value), account);\n    }\n\n    function allowTransient(euint128 value, address account) internal {\n        Impl.allowTransient(euint128.unwrap(value), account);\n    }\n\n    function allowTransient(euint256 value, address account) internal {\n        Impl.allowTransient(euint256.unwrap(value), account);\n    }\n\n    function allowTransient(eaddress value, address account) internal {\n        Impl.allowTransient(eaddress.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes64 value, address account) internal {\n        Impl.allowTransient(ebytes64.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes128 value, address account) internal {\n        Impl.allowTransient(ebytes128.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes256 value, address account) internal {\n        Impl.allowTransient(ebytes256.unwrap(value), account);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}