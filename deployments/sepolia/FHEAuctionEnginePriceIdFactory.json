{
  "address": "0xCf779bDD04dc7194a4f16e6Fb799aF5a7C5F9502",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract FHEAuctionEngineIteratorFactory",
          "name": "iteratorFactory_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "auctionAddr",
          "type": "address"
        }
      ],
      "name": "createNewEngine",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x74943bf7d49999313e7ac8091c6329ceffcf16c1ce323f333fbd119af75f53ad",
  "receipt": {
    "to": null,
    "from": "0x37AC010c1c566696326813b840319B58Bb5840E4",
    "contractAddress": "0xCf779bDD04dc7194a4f16e6Fb799aF5a7C5F9502",
    "transactionIndex": 65,
    "gasUsed": "3480914",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000080008000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000200000000000000000000000000000020010000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x54b154d4bc0fe444438097c8d2783aac5862a5170049efb775ad72371144ddfa",
    "transactionHash": "0x74943bf7d49999313e7ac8091c6329ceffcf16c1ce323f333fbd119af75f53ad",
    "logs": [
      {
        "transactionIndex": 65,
        "blockNumber": 7675065,
        "transactionHash": "0x74943bf7d49999313e7ac8091c6329ceffcf16c1ce323f333fbd119af75f53ad",
        "address": "0xCf779bDD04dc7194a4f16e6Fb799aF5a7C5F9502",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000037ac010c1c566696326813b840319b58bb5840e4"
        ],
        "data": "0x",
        "logIndex": 103,
        "blockHash": "0x54b154d4bc0fe444438097c8d2783aac5862a5170049efb775ad72371144ddfa"
      }
    ],
    "blockNumber": 7675065,
    "cumulativeGasUsed": "10106250",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xafaDe50062eE3e1BB6eaA030b1c0394537777b75"
  ],
  "numDeployments": 1,
  "solcInputHash": "7f1d2ee767592f15145b80b3c07e9f87",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract FHEAuctionEngineIteratorFactory\",\"name\":\"iteratorFactory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auctionAddr\",\"type\":\"address\"}],\"name\":\"createNewEngine\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"createNewEngine(address)\":{\"details\":\"Deploys a new FHEAuctionEngine contract. - engine.owner() == `auctionAddr`\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol\":\"FHEAuctionEnginePriceIdFactory\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     *\\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/FourStepsIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n//import {console} from \\\"hardhat/console.sol\\\";\\n\\ninterface IFourStepsIterable {\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n}\\n\\n/*\\n * Return code, iterations were completed but the computation step is not finished\\n */\\nuint8 constant S_NOT_FINISHED = 0;\\n\\n/*\\n * Return code, iterations were completed and the computation step is finished \\n */\\nuint8 constant S_FINISHED = 1;\\n\\n/*\\n * Return code, iterations could not be completed due to insufficient gas.\\n */\\nuint8 constant E_NOT_ENOUGH_GAS = 2;\\n\\nabstract contract FourStepsIterator is Ownable {\\n    struct Step {\\n        uint32 size;\\n        uint8 nativeGasWeight;\\n        uint32 unitFheGasCost;\\n    }\\n\\n    uint64[] _cumulatives;\\n    Step[] _steps; // len = (4+1)\\n    uint8 _step; // 0 <= _step <= 4\\n    uint32 _stepProgress;\\n    uint64 _iterProgress;\\n\\n    error NullWeight();\\n    error UnauthorizedIterable();\\n    //18,992           | 21,952\\n\\n    constructor(address initialOwner) Ownable(initialOwner) {\\n        // _steps[4] should exist\\n        for (uint8 i = 0; i < 5; ++i) {\\n            _steps.push(Step({size: 0, nativeGasWeight: 0, unitFheGasCost: 0}));\\n            _cumulatives.push(0);\\n        }\\n    }\\n\\n    function _initializeFourSteps(Step[] memory fourSteps) internal {\\n        //Debug\\n        require(fourSteps.length <= 4);\\n\\n        uint64 max = 0;\\n        uint8 i;\\n        for (i = 0; i < fourSteps.length; ++i) {\\n            if (fourSteps[i].size > 0 && fourSteps[i].nativeGasWeight == 0) {\\n                revert NullWeight();\\n            }\\n            max += fourSteps[i].size * fourSteps[i].nativeGasWeight;\\n            Step storage s = _steps[i];\\n            s.size = fourSteps[i].size;\\n            s.nativeGasWeight = fourSteps[i].nativeGasWeight;\\n            s.unitFheGasCost = fourSteps[i].unitFheGasCost;\\n            _cumulatives[i] = max;\\n        }\\n\\n        while (i < 4) {\\n            _cumulatives[i] = max;\\n            i++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete step `s`\\n     */\\n    function _minIterProgressForStep(uint8 s) internal view returns (uint64) {\\n        return _cumulatives[s];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete the four steps\\n     */\\n    function iterProgressMax() public view returns (uint64) {\\n        return _cumulatives[3];\\n    }\\n\\n    /**\\n     * @dev Returns the number of completed iterations (`iterProgress()` <= `iterProgressMax()`).\\n     */\\n    function iterProgress() public view returns (uint64) {\\n        return _iterProgress;\\n    }\\n\\n    function getStepProgress(uint8 s) public view returns (uint32) {\\n        uint8 cur = _step;\\n        if (cur == s) {\\n            return _stepProgress;\\n        } else if (cur > s) {\\n            return _steps[s].size;\\n        }\\n        return 0;\\n    }\\n\\n    function getStepProgressMax(uint8 s) public view returns (uint32) {\\n        return _steps[s].size;\\n    }\\n\\n    function getStepIterProgressMax(uint8 s) public view returns (uint64) {\\n        return _steps[s].size * _steps[s].nativeGasWeight;\\n    }\\n\\n    function step() public view returns (uint8) {\\n        return _step;\\n    }\\n\\n    function stepProgress() public view returns (uint32) {\\n        return _stepProgress;\\n    }\\n\\n    function finished() public view returns (bool) {\\n        return _step == 4;\\n    }\\n\\n    /**\\n     * @dev Executes up to `iter` computation iterations, stopping early if step `maxStepCompleted` is fully processed.\\n     *\\n     * @param iter The maximum number of computation iterations to execute.\\n     * @param stopAfterStep The computation step at which execution should stop if it has been fully completed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of iterations completed before this function call.\\n     * @return endIterProgress The total number of iterations completed after this function call.\\n     *         The difference `(endIterProgress - startIterProgress)` represents the number of iterations executed in this call.\\n     */\\n    function _next(uint64 iter, uint8 stopAfterStep)\\n        internal\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        //uint8 s0 = _step;\\n        //uint8 s = s0;\\n        uint8 s = _step;\\n\\n        startIterProgress = _iterProgress;\\n        endIterProgress = startIterProgress;\\n\\n        code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n\\n        if (s > stopAfterStep) {\\n            return (code, startIterProgress, endIterProgress);\\n        }\\n\\n        //uint32 p0 = _stepProgress;\\n        //uint32 p = p0;\\n        uint32 fheGasLeft = 10_000_000;\\n        uint32 p = _stepProgress;\\n        uint64 actualIter = 0;\\n        IFourStepsIterable iterable = IFourStepsIterable(owner());\\n\\n        while (s < 4 && s <= stopAfterStep && fheGasLeft > 0) {\\n            Step memory theStep = _steps[s];\\n\\n            uint32 r = theStep.size - p;\\n\\n            // skip empty steps first.\\n            if (r == 0) {\\n                p = 0;\\n                s += 1;\\n                continue;\\n            }\\n\\n            // after having skipped empty steps\\n            if (iter == 0) {\\n                break;\\n            }\\n\\n            uint32 w = uint32(theStep.nativeGasWeight);\\n            uint32 i;\\n            if (iter < w) {\\n                // align\\n                i = 1;\\n                iter = w;\\n            } else {\\n                if (iter >= r * w) {\\n                    i = r;\\n                } else {\\n                    i = uint32(iter / w);\\n                }\\n            }\\n\\n            if (i * theStep.unitFheGasCost > fheGasLeft) {\\n                i = uint32(fheGasLeft / theStep.unitFheGasCost);\\n\\n                if (i == 0) {\\n                    fheGasLeft = 0;\\n                    break;\\n                }\\n            }\\n\\n            fheGasLeft -= uint32(i * theStep.unitFheGasCost);\\n\\n            uint32 j;\\n\\n            if (s == 0) {\\n                (code, j) = iterable.runStep1(p, i, theStep.size);\\n            } else if (s == 1) {\\n                (code, j) = iterable.runStep2(p, i, theStep.size);\\n            } else if (s == 2) {\\n                (code, j) = iterable.runStep3(p, i, theStep.size);\\n            } else if (s == 3) {\\n                (code, j) = iterable.runStep4(p, i, theStep.size);\\n            }\\n\\n            actualIter += j * w;\\n            iter -= j * w;\\n            p += j;\\n\\n            if (code == S_FINISHED) {\\n                //Debug\\n                require(p == theStep.size, \\\"Panic: p != theStep.size\\\");\\n                p = 0;\\n                s += 1;\\n            } else {\\n                //Debug\\n                require(p < theStep.size, \\\"Panic: p >= theStep.size\\\");\\n                if (code != S_NOT_FINISHED) {\\n                    //Debug\\n                    require(code == E_NOT_ENOUGH_GAS, \\\"Panic: code != E_NOT_ENOUGH_GAS\\\");\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (iter > 0 && fheGasLeft == 0) {\\n            code = E_NOT_ENOUGH_GAS;\\n        }\\n\\n        if (actualIter > 0) {\\n            endIterProgress = startIterProgress + actualIter;\\n            _iterProgress = endIterProgress;\\n        }\\n\\n        _stepProgress = p;\\n        _step = s;\\n\\n        if (code != E_NOT_ENOUGH_GAS) {\\n            code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9a602a7697976048adce1cc678f6b57da623e1cbf4b73a2f22a91071d56c6f26\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/ITimedAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\ninterface ITimedAuction {\\n    function closed() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x172cc08b56e50a2c61499a088a105445b62de1350bf8ad10ada3c542b0e4e5f1\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {IFHEAuctionBase} from \\\"./IFHEAuctionBase.sol\\\";\\n\\ninterface IFHEAuction is IFHEAuctionBase {\\n    function balanceOf(address bidder) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea97d1fa958167d13730897a14fa6df3a6d4f03a43482c9d99a13f6fb73da673\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuctionBase.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {ITimedAuction} from \\\"../ITimedAuction.sol\\\";\\n\\ninterface IFHEAuctionBase is ITimedAuction {}\\n\",\"keccak256\":\"0x7fdc46ad5a85666ee01b04e640117a98a0848b4e27c84dc7a1ab3cf9c808ee67\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IFHEAuctionEngine} from \\\"./IFHEAuctionEngine.sol\\\";\\nimport {IFHEAuction} from \\\"../auctions/IFHEAuction.sol\\\";\\nimport {FHEAuctionEngineIterator} from \\\"./FHEAuctionEngineIterator.sol\\\";\\nimport {\\n    FourStepsIterator,\\n    IFourStepsIterable,\\n    S_FINISHED,\\n    S_NOT_FINISHED,\\n    E_NOT_ENOUGH_GAS\\n} from \\\"../FourStepsIterator.sol\\\";\\n\\n/**\\n * @notice ## Engine Architecture\\n *\\n * ### Incremental Computation\\n *\\n * - A uniform price auction requires an FHE-based sorting operation, which has a computational complexity\\n *   of O(N^2), where N is the number of bidders. As a result, the overall auction computation consumes\\n *   a significant amount of both native and FHE gas.\\n *\\n * - To overcome these gas cost limitations, the implementation adopts an incremental batch-processing mechanism,\\n *   allowing the full computation to be executed iteratively across multiple smaller transactions, rather\\n *   than in a single execution. This ensures computations remain gas-efficient and\\n *   prevents exceeding blockchain transaction limits as well as fhEVM limits.\\n *\\n * - Since the auction results cannot be determined in a single transaction, a dedicated contract,\\n *   {FHEAuctionEngineIterator}, is responsible for managing the paging mechanism. It orchestrates the\\n *   progressive execution of auction computation cycles until completion.\\n *\\n * - A drawback of such iterative approach is the extra native gas cost required to read/write additional state \\n *   variables required to save the computation status between two consecutive computation transactions.\\n *\\n * ### Contract Size Limit\\n *\\n * Due to the maximum contract size restrictions, the auction engine is modularized across multiple contracts:\\n *\\n * - Core Engine: `FHEAuctionEngine`, the base contract.\\n * - Tie-Breaking Implementations: Four specialized contracts inherit from `FHEAuctionEngine`, each\\n *   implementing a different tie-breaking rule:\\n *      - `FHEAuctionEnginePriceId`\\n *      - `FHEAuctionEnginePriceQuantityId`\\n *      - `FHEAuctionEnginePriceRandom`\\n *      - `FHEAuctionEngineProRata`\\n * - Computation Manager: `FHEAuctionEngineIterator`, responsible for orchestrating the incremental\\n *   computation process.\\n *\\n * @notice ## Algorithm for Bid Validation and Ranking\\n *\\n * ### Approach\\n *\\n * A bit-level strategy would have been optimal in terms of FHE cost; however, the resulting native gas cost \\n * would be overwhelming. The primary reason is that the current version of TFHE library lacks batch functions \\n * or high-level bitwise operations (such as array manipulations or tensor operations). \\n * As a result, a more \\\"brute force\\\" approach manipulating encrypted integers is necessary.\\n *\\n * The algorithm consists in 4 steps, with the last one beeing optional. \\n *\\n *  |  Steps                     |  Cost    | \\n *  |----------------------------|----------|\\n *  |  1. Bid validation         |  O(N)    |\\n *  |  2. Bid ranking            |  O(N^2)  |\\n *  |  3. Won Quantities by rank |  O(N)    | \\n *  |  4. Won Quantities by id   |  O(N^2)  |\\n *   \\n * ### Step 1: Bid validation. O(N)\\n *\\n * The first step is to sanitize the list of registered bids by evaluating each one individually. If a bid fails to meet\\n * the engine's validation criteria, it is marked as invalid, with both the price and quantity set to zero\\n * (i.e., `price = 0` and `quantity = 0`).\\n *\\n * Registered bids are indexed starting from `1` up to `bidCount`. Therefore, an index of `0` indicates that no bid\\n * exists. For each valid bid at index `i` (where `1 <= i <= bidCount`), the following two conditions must always hold:\\n *\\n * 1. `0 < price(i) <= Maximum Price`\\n * 2. `0 < quantity(i) <= Total Quantity`\\n *\\n * ### Step 2: Bid ranking (sort). O(N^2)\\n *\\n * - In this step, we determine the price and quantity of the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`. The bid ranked at position `0` is the highest-ranked bid, which is determined based on the selected\\n * ranking criteria. The ranking is strict, meaning no two bids can share the same rank. To achieve this, the bid\\n * set is provided with a strict order relation, ensuring a clear distinction between each bid's position in the ranking.\\n *\\n * - The final list of ranked bids is constructed through an iterative process. Specifically, the bid at index `k+1` is\\n * inserted into an existing list of ranked bids of length `k`, resulting in a new list of length `k+1`. During each\\n * insertion, the bid is placed in its correct position, ensuring that the relationship `Bid(k) > Bid(k+1)` holds true\\n * according to the selected comparison criteria.\\n *\\n * - The comparison function used to rank bids depends on two factors: the bid price and the auction engine's specified\\n * tie-breaking rule. This ensures that bids are ranked in a consistent and predictable manner.\\n *\\n * - Finally, the computational complexity of this bid ranking operation is `N(N-1)/2 = O(N^2)`, where `N` represents the\\n * total number of bids. This complexity arises from the need to perform pairwise comparisons and insert each bid into the\\n * correct position within the sorted list.\\n *\\n * ### Step 3: Ranked bid won quantities and uniform price calculation. O(N)\\n *\\n * - In the third step, we determine the final quantity for the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`, as well as the auction's final uniform price. A winning bid will have a strictly positive quantity,\\n * while a losing bid will have a quantity of zero.\\n *\\n * - Since the bids are ranked in strict order, the quantity for each winning bid can be determined deterministically,\\n * without the need for tie-breaking.\\n *\\n * - The uniform price is calculated as the price of the lowest winning bid.\\n *\\n * - The computational complexity O(N), linear in the number of bids.\\n *\\n * ### Step 4 (Optional): Inverting ranking to index vector. O(N^2)\\n *\\n * - This step generates an index vector that maps the ranking of bids back to their original positions in the\\n * ranked list. Each position in the index vector corresponds to the original index of a bid in the ranked list.\\n *\\n * - The purpose of this step is to facilitate lookup or processing based on the original bid order.\\n *\\n * - This step is optional and can be skipped to minimize computation cost and if auction prizes can delivered directly\\n * based on ranking positions rather than requiring bidder addresses.\\n */\\nabstract contract FHEAuctionEngine is SepoliaZamaFHEVMConfig, Ownable, IFourStepsIterable, IFHEAuctionEngine {\\n    uint256 public constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint256 public constant MIN_GAS_PER_BV_CYCLE = 165_000;\\n    uint256 public constant MIN_GAS_PER_RB_CYCLE = 420_000;\\n    uint256 public constant MIN_GAS_PER_RWQ_CYCLE = 250_000;\\n    uint256 public constant MIN_GAS_PER_WQ_CYCLE = 160_000;\\n\\n    euint256 constant DUMMY_EUINT256_MEMORY = euint256.wrap(uint32(0xdeadbeef));\\n    euint16 constant DUMMY_EUINT16_MEMORY = euint16.wrap(uint32(0xdeadbeef));\\n\\n    enum TieBreakingRule {\\n        PriceId,\\n        PriceQuantityId,\\n        PriceRandom,\\n        ProRata\\n    }\\n\\n    struct ABid {\\n        euint256 price;\\n        euint256 quantity;\\n        euint256 rand;\\n        euint16 id;\\n    }\\n\\n    FHEAuctionEngineIterator _iterator;\\n\\n    uint256 private _totalQuantity;\\n    TieBreakingRule private _tieBreakingRule;\\n    bool private _auctionIsClosed;\\n\\n    uint16 private _maxBidCount;\\n    uint16 private _bidCount;\\n    uint16 private _nextId;\\n\\n    // 1 <= id < _nextId\\n    mapping(address bidder => uint16 id) private _bidderToId;\\n    mapping(uint16 id => address bidder) private _idToBidder;\\n\\n    // 1 <= idxPlusOne <= _bidCount\\n    mapping(uint16 idxPlusOne => uint16 id) private _indexPlusOneToId;\\n    mapping(uint16 id => uint16 idxPlusOne) private _idToIndexPlusOne;\\n\\n    // 1 <= id < _nextId\\n    mapping(uint16 id => ABid bid) private _idToBid;\\n\\n    euint256 private _cumulativeQuantity;\\n    euint256 private _uniformPrice;\\n\\n    ///@dev A precomputed zero euint256 to minimize the `TFHE.asEuint256(0)` calls \\n    euint256 private immutable _eZeroU256;\\n\\n    // Step 2: Bid ranking. O(N^2)\\n    // ===========================\\n\\n    ///@dev Index from which the computation of step #2 should resume.\\n    uint16 private _resumeIdxRB;\\n\\n    ///@dev Temporary saved did data required when the computation of step #2 should resume.\\n    ABid private _cursorRB;\\n\\n    ///@dev Total number of ranked bids that have been computed so far.\\n    ///@dev 0 <= _rankedBidCount <= _bidCount\\n    uint16 private _rankedBidCount;\\n\\n    ///@dev Array of bids sorted by rank order, where entry k contains the bid placed by bidder ranked at position k.\\n    ///@dev 0 <= rank < _rankedBidCount\\n    ABid[] private _rankedBids;\\n\\n    // Step 3: Ranked bid won quantity and uniform price calculation. O(N)\\n    // ===================================================================\\n\\n    ///@dev Array of final won quantities sorted by rank order, where entry k contains the won quantity for bidder\\n    /// ranked at position k.\\n    euint256[] private _rankedWonQuantities;\\n\\n    // Step 4: Inverting ranking to index vector. O(N)\\n    // ===============================================\\n\\n    ///@dev Index of the bidder whose final won quantity is being computed\\n    uint16 private _idxWQ;\\n\\n    ///@dev Index from which the computation of the final won quantity should resume\\n    uint16 private _resumeIdxWQ;\\n\\n    ///@dev `true` if all won quantities have been computed\\n    bool private _wonQuantitiesByIdReady;\\n\\n    ///@dev `true` if all ranked won quantities have been computed\\n    bool private _wonQuantitiesByRankReady;\\n\\n    ///@dev Current computed final won quantity for the bidder at index `_idxWQ`\\n    euint256 private _quantityWQ;\\n\\n    ///@dev Array of final won quantities, where entry k contains the won quantity for bidder with index = k + 1\\n    euint256[] private _wonQuantities;\\n\\n    error ExpectedNotClosed();\\n    error ExpectedClosed();\\n    error IndexOutOfBounds(uint16 idx, uint16 count);\\n    error RankOutOfBounds(uint16 rank, uint16 rankCount);\\n    error InvalidIterator();\\n    error InvalidId(uint16 id);\\n    error BidderAlreadyRegistered(address bidder);\\n    error TooManyBids();\\n    error WonQuantitiesByRankNotReady();\\n    error WonQuantitiesByIdNotReady();\\n    error NotEnoughGas(uint256 gasLeft, uint256 gasNeeded);\\n    error UnauthorizedIterator();\\n    // Debug\\n    error DebugEngineError(uint16 code);\\n\\n    /**\\n     * @dev Ensures the auction engine not closed before executing the function.\\n     */\\n    modifier whenNotClosed() {\\n        if (_auctionIsClosed) revert ExpectedNotClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Ensures the auction engine is closed before executing the function.\\n     */\\n    modifier whenClosed() {\\n        if (!_auctionIsClosed) revert ExpectedClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the iterator.\\n     */\\n    modifier onlyIterator() {\\n        if (address(_iterator) != msg.sender) {\\n            revert UnauthorizedIterator();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @param auctionOrInitialOwner_ The address of the `FHEAuctionBase` contract that owns this auction engine or the \\n     * address of the initial owner. If the engine initial owner is not the auction contract, a transfer ownership must\\n     * be performed to give ownership to the auction contract.\\n     * @param tieBreakingRule_ The tie-breaking rule used by the auction engine to resolve ties. \\n     * @param iterator_ The addre.\\n     */\\n    constructor(address auctionOrInitialOwner_, uint8 tieBreakingRule_, address iterator_) Ownable(auctionOrInitialOwner_) {\\n        if (iterator_ == address(0) || Ownable(iterator_).owner() != auctionOrInitialOwner_) {\\n            revert InvalidIterator();\\n        }\\n\\n        _iterator = FHEAuctionEngineIterator(iterator_);\\n        _tieBreakingRule = TieBreakingRule(tieBreakingRule_);\\n\\n        euint256 eZero = TFHE.asEuint256(0);\\n        TFHE.allowThis(eZero);\\n\\n        _eZeroU256 = eZero;\\n        _cumulativeQuantity = eZero;\\n        _uniformPrice = eZero;\\n\\n        // A bit counter intuitive.\\n        // Mainly to ensure that computation iterations have a constant gas cost\\n        _cursorRB.price = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.quantity = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.id = DUMMY_EUINT16_MEMORY;\\n        _resumeIdxRB = uint16(0xdead);\\n\\n        _quantityWQ = eZero;\\n        _nextId = 1;\\n        _maxBidCount = type(uint16).max;\\n    }\\n\\n    /**\\n     * @notice Initializes the auction engine with a specified quantity of items.\\n     * The `FHEAuctionEngine` contract is intended for internal use by its owner and is not designed to be\\n     * used by other contracts. It does not include protections against reentrancy or multiple initializations.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner (a contract of type `FHEAuctionBase`).\\n     * - The engine must not be in a closed state.\\n     *\\n     * @param totalQuantity_ The total quantity of items to be auctioned.\\n     */\\n    function initialize(uint256 totalQuantity_, uint16 maxBidCount_) external onlyOwner whenNotClosed {\\n        _totalQuantity = totalQuantity_;\\n        _maxBidCount = maxBidCount_;\\n    }\\n\\n    /**\\n     * @notice Returns the auction contract associated with this engine.\\n     * @dev The auction contract is required to be the owner of the engine.\\n     * @return The auction contract interface.\\n     */\\n    function _auction() internal view returns (IFHEAuction) {\\n        return IFHEAuction(owner());\\n    }\\n\\n    /**\\n     * @notice Returns the engine iterator address. The iterator's owner is the engine itself.\\n     */\\n    function iterator() public view returns (address) {\\n        return address(_iterator);\\n    }\\n\\n    /**\\n     * @notice Returns total quantity of items to be auctioned.\\n     */\\n    function totalQuantity() external view returns (uint256) {\\n        return _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum allowable price for each bid.\\n     * This value ensures that subsequent TFHE arithmetic operations will not overflow.\\n     */\\n    function maximumPrice() public view returns (uint256) {\\n        return MAX_UINT256 / _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the tie-breaking rule used to resolve winning ties.\\n     */\\n    function tieBreakingRule() external view returns (uint8) {\\n        return uint8(_tieBreakingRule);\\n    }\\n\\n    /**\\n     * @notice Returns the total number of bids.\\n     */\\n    function getBidCount() public view returns (uint16) {\\n        return _bidCount;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum number of bids.\\n     */\\n    function getMaximumBidCount() public view returns (uint16) {\\n        return _maxBidCount;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bid index. Reverts if the index is out of bounds.\\n     * @param index The zero-based index of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByIndex(uint16 index) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        if (index >= _bidCount) {\\n            revert IndexOutOfBounds(index, _bidCount);\\n        }\\n\\n        id = _indexPlusOneToId[index + 1];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bidder address.\\n     * @param bidder The address of the bidder whose bid is being retrieved.\\n     * @return id The clear ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByBidder(address bidder) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        id = _bidderToId[bidder];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Returns the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` is the highest-ranked (winning) bid. Reverts if `rank` is out of bounds.\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (rank >= _rankedBidCount) {\\n            revert RankOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedBids[rank].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` represents the highest-ranked (winning) bid.\\n     * The function reverts if:\\n     * - The ranked won quantities computation is not complete.\\n     * - The provided `rank` is out of bounds.\\n     *\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid at the specified rank.\\n     * @return price The encrypted price of the bid at the specified rank.\\n     * @return quantity The encrypted quantity won by the bid at the specified rank.\\n     */\\n    function getWonBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (!_wonQuantitiesByRankReady) {\\n            // step #3 is not yet completed\\n            revert WonQuantitiesByRankNotReady();\\n        }\\n\\n        if (rank >= _rankedBidCount) {\\n            revert IndexOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedWonQuantities[rank];\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the uniform price is ready for decryption.\\n     */\\n    function canDecryptUniformPrice() external view returns (bool) {\\n        // uniformPrice is computed during step #3\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns the encrypted uniform price if computations are complete;\\n     * otherwise, returns zero (uninitialized `euint256`).\\n     * @return price the encrypted uniform price. The engine owner has TFHE permissions to access `price`.\\n     */\\n    function getUniformPrice() public view returns (euint256 price) {\\n        // uniformPrice is computed during step #3\\n        if (_wonQuantitiesByRankReady) {\\n            price = _uniformPrice;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the computation of all won quantities is complete (step #4),\\n     * allowing bidders to claim their auction prizes.\\n     */\\n    function canClaim() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function canBlindClaim() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function wonQuantitiesByRankReady() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #4),\\n     */\\n    function wonQuantitiesByIdReady() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns the validated price and the encrypted won quantity associated with the bid identified by `id`.\\n     *\\n     * @notice Requirements:\\n     * - The computation of all won quantities must be complete (step #4).\\n     * - `id` must be a valid ID.\\n     *\\n     * @param id The bid ID.\\n     * @return validatedPrice The encrypted validated price of the bid.\\n     * @return wonQuantity The encrypted won quantity of the bid.\\n     *\\n     * @dev The owning auction contract has TFHE access permissions on both `wonQuantity` and `validatedPrice`.\\n     */\\n    function validatedPriceAndWonQuantityById(uint16 id)\\n        external\\n        view\\n        returns (euint256 validatedPrice, euint256 wonQuantity)\\n    {\\n        if (_wonQuantitiesByIdReady) {\\n            uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n            if (idxPlusOne == 0 || idxPlusOne > _bidCount) {\\n                revert InvalidId(id);\\n            }\\n\\n            // owner has TFHE permissions.\\n            validatedPrice = _idToBid[id].price;\\n            wonQuantity = _wonQuantities[idxPlusOne - 1];\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the bid ID associated with the specified `bidder` address.\\n     */\\n    function bidderId(address bidder) external view returns (uint16) {\\n        return _bidderToId[bidder];\\n    }\\n\\n    /**\\n     * @notice Returns the bidder address associated with the specified `id`.\\n     */\\n    function getBidderById(uint16 id) external view returns (address) {\\n        return _idToBidder[id];\\n    }\\n\\n    /**\\n     * @notice Removes a bidder's bid from the list of bids\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not be closed. (ie still accepting new bids)\\n     */\\n    function removeBid(address bidder) external onlyOwner whenNotClosed {\\n        uint16 id = _bidderToId[bidder];\\n        if (id == 0) {\\n            return;\\n        }\\n\\n        // Debug\\n        if (!(_bidCount > 0)) revert DebugEngineError(4);\\n\\n        uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n        // Debug\\n        if (!(idxPlusOne > 0)) revert DebugEngineError(5);\\n\\n        // remove bidder address\\n        _bidderToId[bidder] = 0;\\n        _idToBidder[id] = address(0);\\n\\n        // swap id with last id\\n        if (idxPlusOne < _bidCount) {\\n            uint16 lastId = _indexPlusOneToId[_bidCount];\\n\\n            // Debug\\n            if (!(lastId > 0)) revert DebugEngineError(6);\\n\\n            _indexPlusOneToId[idxPlusOne] = lastId;\\n            _idToIndexPlusOne[lastId] = idxPlusOne;\\n        }\\n\\n        // remove id\\n        _indexPlusOneToId[_bidCount] = 0;\\n        _idToIndexPlusOne[id] = 0;\\n        _idToBid[id] =\\n            ABid({price: euint256.wrap(0), quantity: euint256.wrap(0), id: euint16.wrap(0), rand: euint256.wrap(0)});\\n\\n        _bidCount--;\\n    }\\n\\n    /**\\n     * @notice Mark the auction engine as closed. When the engine is closed, it can no more accept new bids.\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not already be closed.\\n     */\\n    function close() external onlyOwner whenNotClosed {\\n        _close(false);\\n    }\\n\\n    function _close(bool onlyBlindClaim) internal {\\n        _auctionIsClosed = true;\\n        _iterator.initializeFourSteps(_bidCount, 2_456_000, _rankFheGasCostPerIdx(), 1_469_000, 101_000, onlyBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Executes a batch of auction computation cycles, processing up to `iter` cycles in a single call.\\n     * This function allows incremental processing of the auction results until completion.\\n     *\\n     * @dev If the auction is not yet closed, it will be closed before starting the computation.\\n     *\\n     * @notice Requirements:\\n     * - Only the contract owner can call this function.\\n     *\\n     * @param iter The maximum number of computation cycles to execute in this call.\\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of computation cycles completed before this function call.\\n     * @return endIterProgress The total number of computation cycles completed after this function call.\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        if (!_auctionIsClosed) {\\n            _close(false);\\n        }\\n        (code, startIterProgress, endIterProgress) = _iterator.computeAuctionIterations(iter, stopIfReadyForBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Adds a new bid to the list of bids.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine must not be closed.\\n     *\\n     * @param bidder The address of the bidder placing the new bid.\\n     * @param ePrice The encrypted price of the bid.\\n     * @param eQuantity The encrypted quantity of the bid.\\n     */\\n    function addBid(address bidder, euint256 ePrice, euint256 eQuantity) external onlyOwner whenNotClosed {\\n        if (_bidderToId[bidder] != 0) {\\n            revert BidderAlreadyRegistered(bidder);\\n        }\\n\\n        if (_bidCount == _maxBidCount) {\\n            revert TooManyBids();\\n        }\\n\\n        uint16 nextId = _nextId;\\n        _nextId = nextId + 1;\\n\\n        uint16 nextIdxPlusOne = _bidCount + 1;\\n        _bidCount = nextIdxPlusOne;\\n\\n        euint256 zero = _eZeroU256;\\n        ebool priceTooHigh = TFHE.gt(ePrice, maximumPrice());\\n        ePrice = TFHE.select(priceTooHigh, zero, ePrice);\\n        eQuantity = TFHE.min(eQuantity, _totalQuantity);\\n\\n        ebool ePriceIsZero = TFHE.eq(ePrice, zero);\\n        ebool eQuantityIsZero = TFHE.eq(eQuantity, zero);\\n\\n        ePrice = TFHE.select(eQuantityIsZero, zero, ePrice);\\n        eQuantity = TFHE.select(ePriceIsZero, zero, eQuantity);\\n\\n        euint256 eRand = euint256.wrap(0);\\n        euint16 eId = TFHE.asEuint16(nextId);\\n\\n        if (_tieBreakingRule == TieBreakingRule.PriceRandom) {\\n            eRand = TFHE.randEuint256();\\n            TFHE.allowThis(eRand);\\n        }\\n\\n        TFHE.allowThis(ePrice);\\n        TFHE.allowThis(eQuantity);\\n        TFHE.allowThis(eId);\\n\\n        _indexPlusOneToId[nextIdxPlusOne] = nextId;\\n        _idToIndexPlusOne[nextId] = nextIdxPlusOne;\\n\\n        _bidderToId[bidder] = nextId;\\n        _idToBidder[nextId] = bidder;\\n\\n        _idToBid[nextId] = ABid({price: ePrice, quantity: eQuantity, rand: eRand, id: eId});\\n\\n        // Bidder pays for memory allocation\\n        ABid memory _emptySortedBid;\\n        _emptySortedBid.price = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.quantity = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.rand = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.id = eId;\\n\\n        _rankedBids.push(_emptySortedBid);\\n        _rankedWonQuantities.push(DUMMY_EUINT256_MEMORY);\\n        _wonQuantities.push(DUMMY_EUINT256_MEMORY);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //                  \\u2b50\\ufe0f Step 1/4: Bid Validation O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #1.\\n     *\\n     * - Returns `E_NOT_ENOUGH_GAS` if the `chunckSize` iterations could not be completed due to insufficient gas.\\n     * - Returns `S_NOT_FINISHED` if the iterations were completed but the computation step is not yet finished.\\n     * - Returns `S_FINISHED` if the iterations were completed (or fewer iterations were needed) and the bid ranking step has been completed.\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #1. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x mul(euint256, euint256) : 1 x 2_045_000\\n     * - 1x le(euint256, uint256)   : 1 x   231_000\\n     * - 2x select(euint256)        : 2 x    90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 2_456_000\\n     */\\n    function _runStep1(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Gas cost ~= 2_400\\n        uint16 toIdx = uint16(progress + iter);\\n\\n        euint256 ePrice;\\n        euint256 eQuantity;\\n\\n        IFHEAuction auction = _auction();\\n\\n        // From start to beginning of the loop : Gas cost ~= 2_600\\n        // 1x loop iter ~= 153_000 gas\\n        // After loop ~= 3_000 gas\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        for (uint16 idx = uint16(progress); idx < toIdx; ++idx) {\\n            uint16 bidId = _indexPlusOneToId[idx + 1];\\n\\n            // Debug\\n            if (!(bidId > 0)) revert DebugEngineError(7);\\n\\n            ABid storage b = _idToBid[bidId];\\n            ePrice = b.price;\\n            eQuantity = b.quantity;\\n            // ePrice = _idToBid[bidId].price;\\n            // eQuantity = _idToBid[bidId].quantity;\\n\\n            // Cannot overflow\\n            euint256 minBalance = TFHE.mul(ePrice, eQuantity);\\n\\n            ebool enoughBalance = TFHE.le(minBalance, auction.balanceOf(_idToBidder[bidId]));\\n\\n            ePrice = TFHE.select(enoughBalance, ePrice, _eZeroU256);\\n            eQuantity = TFHE.select(enoughBalance, eQuantity, _eZeroU256);\\n\\n            // _idToBid[bidId].price = ePrice;\\n            // _idToBid[bidId].quantity = eQuantity;\\n            b.price = ePrice;\\n            b.quantity = eQuantity;\\n\\n            TFHE.allowThis(ePrice);\\n            TFHE.allowThis(eQuantity);\\n            TFHE.allow(ePrice, address(auction));\\n            TFHE.allow(eQuantity, address(auction));\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            code = S_FINISHED;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //             \\u2b50\\ufe0f Step 2/4: Sort Bids by Rank Order O(N^2) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @dev Returns the FHE Gas cost per iteration consumed by the `_rankFromIdxToIdx` function.\\n     */\\n    function _rankFheGasCostPerIdx() internal pure virtual returns (uint32);\\n\\n    /**\\n     * @dev Performs a ranking pass from index `fromIdx` to index `toIdx`. The FHE Gas cost can be evaluated using the\\n     * `_rankFheGasCostPerIdx` function.\\n     */\\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual;\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #2.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #2. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev Total FHE Gas Cost per iteration : `_rankFheGasCostPerIdx()`\\n     */\\n    function _runStep2(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < 2 * MIN_GAS_PER_RB_CYCLE) {\\n            // If we do not have enough gas left to perform `one TFHE cycle` + `one sort completion`\\n            // it is probably safe to interrupt at this point to avoid any accidental revert due to insufficient gas\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 rankedBidCount = _rankedBidCount;\\n        uint16 resumeIdx;\\n\\n        // We want to optimize the following calls:\\n        // - TFHE.allow(...) which cost about 25_000 gas\\n        // - SSTORE operations\\n        // We use the following 2 flags to minimize those calls.\\n        bool cursorAllowNeeded = false;\\n        bool cursorUpdateNeeded = false;\\n\\n        ABid memory cursor;\\n\\n        // We pick the first registered bid and store it at the first place of\\n        // the sorted bid list.\\n        if (rankedBidCount == 0) {\\n            // The first bid id is equal to `1`\\n            // (See the bid() function and the above remark (3))\\n            _rankedBids[0] = _idToBid[_indexPlusOneToId[1]];\\n\\n            // if there is only one single bidder, the sort is over\\n            if (_bidCount == 1) {\\n                _rankedBidCount = 1;\\n                return (S_FINISHED, 1);\\n            }\\n\\n            // if there are more than one bidder,\\n            // load the second unsorted bid into the cursor and setup the cursor position to zero\\n            rankedBidCount = 1;\\n            resumeIdx = 0;\\n            cursor = _idToBid[_indexPlusOneToId[2]];\\n            cursorUpdateNeeded = true;\\n        } else {\\n            // If the function is called to resume the sort operation, then\\n            // start from the last position stored in the cursor.\\n            resumeIdx = _resumeIdxRB;\\n            cursor = _cursorRB;\\n        }\\n\\n        uint8 code = S_NOT_FINISHED;\\n        uint32 count = 0;\\n\\n        while (count < iter) {\\n            uint32 toIdx = resumeIdx + uint16(iter - count);\\n            if (toIdx > rankedBidCount) {\\n                toIdx = rankedBidCount;\\n            }\\n\\n            // We want to make sure we have enough gas to compute the following:\\n            // - `toIdx - resumeIdxRB` cycles of TFHE operations\\n            // - 1 extra gas quantity to finish the current sort pass.\\n            if (gasleft() < (toIdx - resumeIdx + 1) * MIN_GAS_PER_RB_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            // since resumeIdx < toIdx, the cursor will always be modified\\n            // therefore we must invalidate the storage `_cursorRB` struct.\\n            _rankFromIdxToIdx(resumeIdx, uint16(toIdx), cursor);\\n\\n            count += (toIdx - resumeIdx);\\n\\n            // invalidate the storage `_cursorRB`\\n            cursorUpdateNeeded = true;\\n\\n            // We have reached the end of the currently sorted bids.\\n            // We must do the following:\\n            // 1. append the bid cursor to end of the sorted list.\\n            // 2. load the cursor with the next unsorted bid\\n            // 3. set the cursor position to zero.\\n            if (toIdx == rankedBidCount) {\\n                _rankedBids[rankedBidCount] = cursor;\\n                rankedBidCount++;\\n\\n                _allowBid(cursor);\\n\\n                // If all the registered bids have been sorted, then the sort operation\\n                // is completed.\\n                if (rankedBidCount == _bidCount) {\\n                    // Debug\\n                    if (!(progress + count == progressMax)) revert DebugEngineError(8);\\n\\n                    _rankedBidCount = rankedBidCount;\\n                    return (S_FINISHED, count);\\n                }\\n\\n                // restart from the beginning with the next unsorted bid.\\n                // The next unsorted bid index is equal to `rankedBidCount`\\n                resumeIdx = 0;\\n                cursor = _idToBid[_indexPlusOneToId[rankedBidCount + 1]];\\n\\n                // since the values stored in the cursor are already allowed, there\\n                // will be no need to perform any TFHE.allow() call.\\n                cursorAllowNeeded = false;\\n            } else {\\n                // Debug\\n                if (!(count == iter)) revert DebugEngineError(9);\\n\\n                resumeIdx = uint16(toIdx);\\n\\n                // a TFHE.allow call must be executed on the new cursor values\\n                cursorAllowNeeded = true;\\n            }\\n        }\\n\\n        // Debug\\n        if (!(progress + count < progressMax)) revert DebugEngineError(10);\\n\\n        // Perform TFHE.allow if needed\\n        if (cursorAllowNeeded) {\\n            _allowBid(cursor);\\n        }\\n\\n        // Save the new cursor if needed\\n        if (cursorUpdateNeeded) {\\n            _cursorRB = cursor;\\n        }\\n\\n        // Save the new _rankedBidCount value\\n        _rankedBidCount = rankedBidCount;\\n\\n        // Save the new cursor position\\n        _resumeIdxRB = resumeIdx;\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //            \\u2b50\\ufe0f Step 3/4: Compute Ranked Won Quantities O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #3.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The maximum progress value for the step #3 which is equal to `_bidCount`.\\n     * (`progress` + `iter` <= `progressMax`)\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x lt(euint256, euint256)  : 1 x 231_000\\n     * - 1x gt(euint256, euint256)  : 1 x 231_000\\n     * - 1x and                     : 1 x  44_000\\n     * - 1x sub(euint256, euint256) : 1 x 253_000\\n     * - 1x min(euint256, euint256) : 1 x 277_000\\n     * - 1x add(euint256, euint256) : 1 x 253_000\\n     * - 2x select(euint256)        : 2 x  90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 1_469_000\\n     */\\n    function _runStep3(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        // Average gas cost:\\n        // - first iteration : 113_000 gas\\n        // - single iteration : 225_000 gas\\n        if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Debug\\n        if (!(_rankedBidCount == _bidCount && _rankedBids.length >= _bidCount)) revert DebugEngineError(11);\\n\\n        uint16 from = uint16(progress);\\n        uint16 to = uint16(from + iter);\\n\\n        address auctionAddr = address(_auction());\\n        euint256 cumulativeQuantity;\\n        euint256 uniformPrice;\\n\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        if (from == 0) {\\n            cumulativeQuantity = _rankedBids[0].quantity;\\n            uniformPrice = _rankedBids[0].price;\\n\\n            euint256 wonQuantity = TFHE.min(cumulativeQuantity, _totalQuantity);\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[0].id, auctionAddr);\\n            TFHE.allow(_rankedBids[0].price, auctionAddr);\\n\\n            _rankedWonQuantities[0] = wonQuantity;\\n\\n            if (to == 1) {\\n                _cumulativeQuantity = cumulativeQuantity;\\n                _uniformPrice = uniformPrice;\\n\\n                if (to == progressMax) {\\n                    TFHE.allow(uniformPrice, auctionAddr);\\n                    code = S_FINISHED;\\n                    _wonQuantitiesByRankReady = true;\\n                }\\n\\n                return (code, 1);\\n            }\\n\\n            from = 1;\\n            count = 1;\\n        } else {\\n            // Gas cost ~= 4_000\\n            cumulativeQuantity = _cumulativeQuantity;\\n            uniformPrice = _uniformPrice;\\n        }\\n\\n        // Here: 1 <= from < to\\n\\n        // Possible gas cost from start up to this point:\\n        //   - Branch #1 : 13_000 gas (from != 0)\\n        //   - Branch #2 : 73_000 gas (from == 0 && to != 1)\\n        //\\n        // 1x loop iter ~= 155_000 gas\\n        // After loop ~= 60_000 gas\\n        for (uint16 k = from; k < to; ++k) {\\n            if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            euint256 bidQuantity = _rankedBids[k].quantity;\\n            euint256 bidPrice = _rankedBids[k].price;\\n\\n            // Formula:\\n            // Wk = (C(k-1) < Q) ? min(Q - C(k-1), q_k) : 0\\n            ebool isValid = TFHE.lt(cumulativeQuantity, _totalQuantity);\\n\\n            // Price = 0 means the bid is invalid\\n            // pk = 0 => qk = 0\\n            isValid = TFHE.and(isValid, TFHE.gt(bidPrice, _eZeroU256));\\n\\n            euint256 remainingQuantity = TFHE.sub(_totalQuantity, cumulativeQuantity);\\n            euint256 wonQuantity = TFHE.select(isValid, TFHE.min(remainingQuantity, bidQuantity), _eZeroU256);\\n\\n            cumulativeQuantity = TFHE.add(cumulativeQuantity, bidQuantity);\\n\\n            uniformPrice = TFHE.select(isValid, bidPrice, uniformPrice);\\n\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[k].id, auctionAddr);\\n            TFHE.allow(_rankedBids[k].price, auctionAddr);\\n\\n            _rankedWonQuantities[k] = wonQuantity;\\n\\n            count++;\\n        }\\n\\n        // Allow cost ~= 48_000 gas\\n        if (count > 0) {\\n            TFHE.allowThis(cumulativeQuantity);\\n            TFHE.allowThis(uniformPrice);\\n        }\\n\\n        // Storage cost ~= 9_000 gas\\n        _cumulativeQuantity = cumulativeQuantity;\\n        _uniformPrice = uniformPrice;\\n\\n        // Debug\\n        if (!(progress + count <= progressMax)) revert DebugEngineError(13);\\n\\n        if (progress + count == progressMax) {\\n            TFHE.allow(uniformPrice, auctionAddr);\\n            code = S_FINISHED;\\n            _wonQuantitiesByRankReady = true;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //        \\u2b50\\ufe0f Step 4/4: Compute Won Quantities O(N^2) (Optional) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n \\n    /**\\n     * @notice Computes a set of `iter` iteration cycles for the step #4.\\n     * see function {computeValidation}\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x eq(euint16, euint16)  : 1 x 54_000\\n     * - 1x select(euint16)       : 1 x 47_000\\n     *\\n     * Total FHE Gas Cost per iteration : 101_000\\n     */\\n    function _runStep4(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 idxWQ = _idxWQ;\\n        uint16 resumeIdxWQ = _resumeIdxWQ;\\n        euint256 quantity = _quantityWQ;\\n\\n        // Debug\\n        if (!(idxWQ < _bidCount && resumeIdxWQ < _bidCount && (idxWQ * _bidCount + resumeIdxWQ + iter <= _bidCount * _bidCount))) {\\n            revert DebugEngineError(14);\\n        }\\n        // Debug\\n        if (!(progress == idxWQ * _bidCount + resumeIdxWQ)) revert DebugEngineError(15);\\n\\n        uint16 idx = idxWQ;\\n        uint16 resumeIdx = resumeIdxWQ;\\n        uint32 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n        address auctionAddr = address(_auction());\\n\\n        while (count < iter) {\\n            ebool eq_id = TFHE.eq(_rankedBids[resumeIdx].id, _indexPlusOneToId[idx + 1]);\\n            quantity = TFHE.select(eq_id, _rankedWonQuantities[resumeIdx], quantity);\\n\\n            resumeIdx++;\\n\\n            if (resumeIdx == _bidCount) {\\n                // store won quantity\\n                _wonQuantities[idx] = quantity;\\n                TFHE.allowThis(quantity);\\n                TFHE.allow(quantity, auctionAddr);\\n\\n                // reset cursor\\n                idx += 1;\\n                resumeIdx = 0;\\n                quantity = _eZeroU256;\\n            }\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            // Debug\\n            if (!(idx == _bidCount && resumeIdx == 0)) revert DebugEngineError(18);\\n\\n            //could be removed\\n            _idxWQ = _bidCount;\\n            //not necessary ?\\n            //_resumeIdxWQ = 0;\\n            _wonQuantitiesByIdReady = true;\\n\\n            return (S_FINISHED, count);\\n        }\\n\\n        // Debug\\n        if (!(idx < _bidCount)) revert DebugEngineError(19);\\n\\n        if (resumeIdx != resumeIdxWQ) {\\n            _resumeIdxWQ = resumeIdx;\\n        }\\n\\n        if (idx != idxWQ) {\\n            _idxWQ = idx;\\n        }\\n\\n        _quantityWQ = quantity;\\n        TFHE.allowThis(quantity);\\n\\n        return (code, count);\\n    }\\n\\n    /**\\n     * @dev Returns the encrypted bid ranked at position `rank`.\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _rankedBidAt(uint16 rank) internal view returns (ABid storage bid) {\\n        bid = _rankedBids[rank];\\n    }\\n\\n    /**\\n     * @dev Sets the encrypted bid ranked at position `rank`\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _setRankedBidAt(uint16 rank, ABid memory newBid) internal {\\n        _rankedBids[rank] = newBid;\\n        _allowBid(newBid);\\n    }\\n\\n    /**\\n     * @dev Grants the engine permission to access the encrypted bid values (`price`, `quantity`, `id`, `rand`).\\n     */\\n    function _allowBid(ABid memory bid_) private {\\n        TFHE.allowThis(bid_.price);\\n        TFHE.allowThis(bid_.quantity);\\n        TFHE.allowThis(bid_.id);\\n        if (TFHE.isInitialized(bid_.rand)) {\\n            TFHE.allowThis(bid_.rand);\\n        }\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //               \\u2b50\\ufe0f IFourStepsIterable implementation \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep1(progress, iter, progressMax);\\n    }\\n\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep2(progress, iter, progressMax);\\n    }\\n\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep3(progress, iter, progressMax);\\n    }\\n\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep4(progress, iter, progressMax);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1924ebc5aef4e1b4ea1bbd690afb90884f3c356f4e411033ebe34d8a280c41\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngineIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FourStepsIterator, IFourStepsIterable} from \\\"../FourStepsIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"./FHEAuctionEngine.sol\\\";\\n\\n// For better readability, steps are named using a one-based index.\\nuint8 constant STEP_1_VALIDATION = 0;\\nuint8 constant STEP_2_SORT = 1;\\nuint8 constant STEP_3_WON_QUANTITIES_BY_RANK = 2;\\nuint8 constant STEP_4_WON_QUANTITIES_BY_ID = 3;\\n\\ncontract FHEAuctionEngineIterator is FourStepsIterator {\\n    constructor(address initialOwner) FourStepsIterator(initialOwner) {}\\n\\n    function initializeFourSteps(\\n        uint16 bidCount,\\n        uint32 step1UnitFheGasCost,\\n        uint32 step2UnitFheGasCost,\\n        uint32 step3UnitFheGasCost,\\n        uint32 step4UnitFheGasCost,\\n        bool onlyBlindClaim\\n    ) external onlyOwner {\\n        FourStepsIterator.Step[] memory fourSteps = new FourStepsIterator.Step[](4);\\n\\n        fourSteps[0].size = bidCount;\\n        fourSteps[0].nativeGasWeight = 1;\\n        fourSteps[0].unitFheGasCost = step1UnitFheGasCost;\\n\\n        fourSteps[1].size = (bidCount == 0) ? 0 : ((bidCount < 3) ? 1 : bidCount * (bidCount - 1) / 2);\\n        fourSteps[1].nativeGasWeight = 2;\\n        fourSteps[1].unitFheGasCost = step2UnitFheGasCost;\\n\\n        fourSteps[2].size = bidCount;\\n        fourSteps[2].nativeGasWeight = 1;\\n        fourSteps[2].unitFheGasCost = step3UnitFheGasCost;\\n\\n        if (!onlyBlindClaim) {\\n            fourSteps[3].size = bidCount * bidCount;\\n            fourSteps[3].nativeGasWeight = 1;\\n            fourSteps[3].unitFheGasCost = step4UnitFheGasCost;\\n        }\\n\\n        _initializeFourSteps(fourSteps);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to execute a blind claim.\\n     */\\n    function minIterationsForBlindClaim() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to finalize the auction uniform price.\\n     */\\n    function minIterationsForUniformPrice() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice see {FHEAuctionEngine-computeAuctionIterations}\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        (code, startIterProgress, endIterProgress) =\\n            _next(iter, (stopIfReadyForBlindClaim) ? STEP_3_WON_QUANTITIES_BY_RANK : STEP_4_WON_QUANTITIES_BY_ID);\\n    }\\n}\\n\",\"keccak256\":\"0x80c2276d1d166f51cc190c57c90d830cd95f6b304badc0db201102e57124eac7\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEnginePriceId.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE, euint256, euint16, ebool} from \\\"fhevm/lib/TFHE.sol\\\";\\nimport {FHEAuctionEngine} from \\\"./FHEAuctionEngine.sol\\\";\\n\\ncontract FHEAuctionEnginePriceId is FHEAuctionEngine {\\n    constructor(address auction_, address iterator_)\\n        FHEAuctionEngine(auction_, uint8(TieBreakingRule.PriceId), iterator_)\\n    {}\\n\\n    /**\\n     * @dev Returns the fixed FHE gas cost per iteration for executing {_rankFromIdxToIdx}.\\n     */\\n    function _rankFheGasCostPerIdx() internal pure virtual override returns (uint32) {\\n        return 978_000;\\n    }\\n\\n    /**\\n     * @notice Performs a ranking operation from index `fromIdx` to index `toIdx` using the following comparison function:\\n     *\\n     * It returns `true` if the bid at `idx` is ranked higher, otherwise returns `false`.\\n     *\\n     * The comparison follows these rules:\\n     * - If `price(idx) > price(bid)`, return `true`\\n     * - If `price(idx) < price(bid)`, return `false`\\n     * - If `price(idx) == price(bid)`, return `true` if `id(idx) < id(bid)`, otherwise return `false`\\n     *\\n     * @notice A lower `id` indicates that the bid was placed earlier.\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x gt(euint256, uint256)   : 1 x   231_000\\n     * - 1x eq(euint256, uint256)   : 1 x   100_000\\n     * - 1x lt(euint16, uint16)     : 1 x   105_000\\n     * - 1x and                     : 1 x    44_000\\n     * - 1x or                      : 1 x    44_000\\n     * - 4x select(euint256)        : 4 x    90_000\\n     * - 2x select(euint16)         : 2 x    47_000\\n     *\\n     * Total FHE Gas Cost per iteration : 978_000\\n     */\\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual override {\\n        ABid memory newBid;\\n        for (uint16 idx = fromIdx; idx < toIdx; ++idx) {\\n            ABid storage b = _rankedBidAt(idx);\\n            euint256 p_i = b.price;\\n            euint256 q_i = b.quantity;\\n            euint16 id_i = b.id;\\n\\n            ebool i_gt_c;\\n            {\\n                ebool p_gt = TFHE.gt(p_i, cursor.price);\\n                ebool p_eq = TFHE.eq(p_i, cursor.price);\\n\\n                ebool id_lt = TFHE.lt(id_i, cursor.id);\\n\\n                i_gt_c = TFHE.or(p_gt, TFHE.and(p_eq, id_lt));\\n            }\\n\\n            newBid.price = TFHE.select(i_gt_c, p_i, cursor.price);\\n            newBid.quantity = TFHE.select(i_gt_c, q_i, cursor.quantity);\\n            newBid.id = TFHE.select(i_gt_c, id_i, cursor.id);\\n\\n            cursor.price = TFHE.select(i_gt_c, cursor.price, p_i);\\n            cursor.quantity = TFHE.select(i_gt_c, cursor.quantity, q_i);\\n            cursor.id = TFHE.select(i_gt_c, cursor.id, id_i);\\n\\n            _setRankedBidAt(idx, newBid);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf97e4c77411612660ed68f8793f0b7ab4d3365d8564fd9f6fa703071f2611f31\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/IFHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {euint16, euint256} from \\\"fhevm/lib/TFHE.sol\\\";\\n\\ninterface IFHEAuctionEngine {\\n    function canClaim() external view returns (bool);\\n    function canBlindClaim() external view returns (bool);\\n    function initialize(uint256 totalQuantity, uint16 maxBidCount) external;\\n    function close() external;\\n    function bidderId(address bidder) external view returns (uint16);\\n    function getBidderById(uint16 id) external view returns (address);\\n    function addBid(address bidder, euint256 inPrice, euint256 inQuantity) external;\\n    function removeBid(address bidder) external;\\n    function canDecryptUniformPrice() external view returns (bool);\\n    function getUniformPrice() external view returns (euint256);\\n    function validatedPriceAndWonQuantityById(uint16 id) external view returns (euint256, euint256);\\n    function totalQuantity() external view returns (uint256);\\n    function maximumPrice() external view returns (uint256);\\n    function getBidCount() external view returns (uint16);\\n    function getMaximumBidCount() external view returns (uint16);\\n    function getBidByBidder(address bidder) external view returns (uint16 id, euint256 price, euint256 quantity);\\n    function getWonBidByRank(uint16 rank) external view returns (euint16 id, euint256 price, euint256 quantity);\\n    function iterator() external view returns (address);\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress);\\n}\\n\",\"keccak256\":\"0xdb32399333e9265f90af58c2822f95b773f533e73fd1584f299a84af5ddc8be5\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEngineFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIterator} from \\\"../FHEAuctionEngineIterator.sol\\\";\\nimport {FHEAuctionEngineIteratorFactory} from \\\"./FHEAuctionEngineIteratorFactory.sol\\\";\\n\\nabstract contract FHEAuctionEngineFactory is Ownable2Step {\\n    FHEAuctionEngineIteratorFactory _iteratorFactory;\\n\\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) Ownable(msg.sender) {\\n        _iteratorFactory = iteratorFactory_;\\n    }\\n\\n    /**\\n     * @dev Deploys a new FHEAuctionEngine contract.\\n     * - engine.owner() == `auctionAddr`\\n     */\\n    function createNewEngine(address auctionAddr) public returns (address) {\\n        // Constructor requirements:\\n        // - iterator.owner() == engine.owner()\\n        // Runtime requirements:\\n        // - iterator.owner() == address(engine)\\n        // - engine.owner() == auctionAddr\\n        address iteratorAddr = _iteratorFactory.createNewIterator(address(this));\\n        address engineAddr = _createNewEngine(address(this), iteratorAddr);\\n        Ownable(iteratorAddr).transferOwnership(engineAddr);\\n        Ownable(engineAddr).transferOwnership(auctionAddr);\\n        return engineAddr;\\n    }\\n\\n    /**\\n     * @dev Abstract function, should be implemented by derived contracts\\n     */\\n    function _createNewEngine(address auction_, address iterator_) internal virtual returns (address);\\n}\\n\",\"keccak256\":\"0xbc0bea47f763b3d3cf309694469dc390c49ff7a87f90640afb527cc41b1a8fe2\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIterator} from \\\"../FHEAuctionEngineIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"../FHEAuctionEngine.sol\\\";\\n\\ncontract FHEAuctionEngineIteratorFactory is Ownable2Step {\\n    constructor() Ownable(msg.sender) {}\\n\\n    function createNewIterator(address initialOwner) public virtual returns (address) {\\n        FHEAuctionEngineIterator iterator = new FHEAuctionEngineIterator(initialOwner);\\n        return address(iterator);\\n    }\\n}\\n\",\"keccak256\":\"0x542e17a2f1034da6fcc4749ec1d65e8036db67cea3ae4ed27fda6029e915cf42\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIteratorFactory} from \\\"./FHEAuctionEngineIteratorFactory.sol\\\";\\nimport {FHEAuctionEngineFactory} from \\\"./FHEAuctionEngineFactory.sol\\\";\\nimport {FHEAuctionEnginePriceId} from \\\"../FHEAuctionEnginePriceId.sol\\\";\\n\\ncontract FHEAuctionEnginePriceIdFactory is FHEAuctionEngineFactory {\\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) FHEAuctionEngineFactory(iteratorFactory_) {}\\n\\n    function _createNewEngine(address initialOwner, address iteratorAddr) internal virtual override returns (address) {\\n        require(Ownable(iteratorAddr).owner() == initialOwner, \\\"Wrong owner\\\");\\n        FHEAuctionEnginePriceId engine = new FHEAuctionEnginePriceId(initialOwner, iteratorAddr);\\n        return address(engine);\\n    }\\n}\\n\",\"keccak256\":\"0x9220d483da7651d77eacceb2808d3e79b1423ccc4e883ba4e82606e05db0df08\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n//import {console} from \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x8f563211d7ebe547648dab005df9bdf2f9f52392e451a451b96a29bd9f9005fc\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f80fd5b50604051613e38380380613e3883398101604081905261002e916100ef565b80338061005457604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61005d81610084565b50600280546001600160a01b0319166001600160a01b03929092169190911790555061011c565b600180546001600160a01b031916905561009d816100a0565b50565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f602082840312156100ff575f80fd5b81516001600160a01b0381168114610115575f80fd5b9392505050565b613d0f806101295f395ff3fe608060405234801562000010575f80fd5b506004361062000078575f3560e01c80638da5cb5b11620000535780638da5cb5b14620000c5578063e30c397814620000d6578063f2fde38b14620000e8575f80fd5b8063715018a6146200007c57806379ba509714620000885780637e1c07101462000092575b5f80fd5b62000086620000ff565b005b6200008662000116565b620000a9620000a336600462000505565b62000162565b6040516001600160a01b03909116815260200160405180910390f35b5f546001600160a01b0316620000a9565b6001546001600160a01b0316620000a9565b62000086620000f936600462000505565b6200029f565b620001096200031f565b620001145f6200034d565b565b60015433906001600160a01b03168114620001545760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6200015f816200034d565b50565b600254604051631fbddea160e21b81523060048201525f9182916001600160a01b0390911690637ef77a84906024016020604051808303815f875af1158015620001ae573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620001d491906200052a565b90505f620001e3308362000375565b60405163f2fde38b60e01b81526001600160a01b0380831660048301529192509083169063f2fde38b906024015f604051808303815f87803b15801562000228575f80fd5b505af11580156200023b573d5f803e3d5ffd5b505060405163f2fde38b60e01b81526001600160a01b0387811660048301528416925063f2fde38b91506024015f604051808303815f87803b15801562000280575f80fd5b505af115801562000293573d5f803e3d5ffd5b50929695505050505050565b620002a96200031f565b600180546001600160a01b03831673ffffffffffffffffffffffffffffffffffffffff199091168117909155620002e75f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b03163314620001145760405163118cdaa760e01b81523360048201526024016200014b565b6001805473ffffffffffffffffffffffffffffffffffffffff191690556200015f8162000486565b5f826001600160a01b0316826001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620003bd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620003e391906200052a565b6001600160a01b0316146200043b5760405162461bcd60e51b815260206004820152600b60248201527f57726f6e67206f776e657200000000000000000000000000000000000000000060448201526064016200014b565b5f83836040516200044c90620004e2565b6001600160a01b03928316815291166020820152604001604051809103905ff0801580156200047d573d5f803e3d5ffd5b50949350505050565b5f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6137ba806200054983390190565b6001600160a01b03811681146200015f575f80fd5b5f6020828403121562000516575f80fd5b81356200052381620004f0565b9392505050565b5f602082840312156200053b575f80fd5b81516200052381620004f056fe60a060405234801562000010575f80fd5b50604051620037ba380380620037ba833981016040819052620000339162000513565b815f8282620000dd620000d7604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b6200028b565b6001600160a01b0381166200010b57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b620001168162000358565b506001600160a01b0381161580620001a25750826001600160a01b0316816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000170573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906200019691906200055d565b6001600160a01b031614155b15620001c15760405163d855fd1760e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b03831617905560ff82166003811115620001f457620001f462000549565b6003805460ff19166001838381111562000212576200021262000549565b02179055505f6200022381620003a7565b90506200023081620003bb565b60808190526009819055600a81905563deadbeef600c819055600d819055600f55600b805461ffff191661dead17905560145550506003805466010000ffff000067ffff0000ffff0000199091161790555062000598915050565b80515f805160206200379a83398151915280546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b50565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f620003b5826008620003c7565b92915050565b6200035581306200047e565b5f805f805160206200379a8339815191526001810154604051631ce2e8d760e31b8152600481018790527fff0000000000000000000000000000000000000000000000000000000000000060f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af115801562000450573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000476919062000580565b949350505050565b5f5f805160206200379a8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015620004db575f80fd5b505af1158015620004ee573d5f803e3d5ffd5b50505050505050565b80516001600160a01b03811681146200050e575f80fd5b919050565b5f806040838503121562000525575f80fd5b6200053083620004f7565b91506200054060208401620004f7565b90509250929050565b634e487b7160e01b5f52602160045260245ffd5b5f602082840312156200056e575f80fd5b6200057982620004f7565b9392505050565b5f6020828403121562000591575f80fd5b5051919050565b6080516131c6620005d45f395f818161084001528181611b6101528181611f6401528181611faf015281816122b401526122e101526131c65ff3fe608060405234801561000f575f80fd5b506004361061024f575f3560e01c80637ca40d1c1161013d578063c15bd28f116100b8578063e8f5858111610088578063f2fde38b1161006e578063f2fde38b1461056f578063fcd9107614610582578063fddcc14814610595575f80fd5b8063e8f5858114610552578063e9a04b0c14610565575f80fd5b8063c15bd28f14610512578063c616f41214610524578063d36256081461052c578063dcc5ed201461053f575f80fd5b80638da5cb5b1161010d578063983fc6e1116100f3578063983fc6e1146102535780639da3604a146104c2578063b1890879146104d5575f80fd5b80638da5cb5b146104a8578063938e1222146104b8575f80fd5b80637ca40d1c1461043f578063869a0ca41461045257806386eea6c2146104965780638a88cb6f1461049e575f80fd5b8063290d2e8c116101cd5780635471e17f1161019d5780636dc7a627116101835780636dc7a62714610370578063715018a6146104245780637562fa0b1461042c575f80fd5b80635471e17f146103be5780635c94cb0c14610253575f80fd5b8063290d2e8c146103705780632f64cdf01461038257806333a581d2146103ae57806343d726d6146103b6575f80fd5b806318083d061161022257806326c8a7571161020857806326c8a75714610303578063285bb3931461031d57806328f6a48a1461034e575f80fd5b806318083d06146102e357806323e45f62146102fb575f80fd5b806302dda9cf146102535780630aa50fe0146102785780630de7056b146102a657806316e807c4146102ce575b5f80fd5b60135465010000000000900460ff165b60405190151581526020015b60405180910390f35b61028b610286366004612e6b565b6105a6565b6040805193845260208401929092529082015260600161026f565b6102b96102b4366004612e6b565b61066e565b6040805192835260208301919091520161026f565b6102e16102dc366004612e9a565b610722565b005b6102ed6202710081565b60405190815260200161026f565b6102ed610bbe565b61030b610bd3565b60405160ff909116815260200161026f565b61033061032b366004612edd565b610bee565b6040805160ff909316835263ffffffff90911660208301520161026f565b600354600160201b900461ffff165b60405161ffff909116815260200161026f565b601354600160201b900460ff16610263565b61035d610390366004612f1d565b6001600160a01b03165f9081526004602052604090205461ffff1690565b6102ed5f1981565b6102e1610c35565b6104046103cc366004612f1d565b6001600160a01b03165f9081526004602090815260408083205461ffff16808452600890925290912080546001909101549192909190565b6040805161ffff909416845260208401929092529082015260600161026f565b6102e1610c71565b61033061043a366004612edd565b610c82565b6102e161044d366004612f36565b610cbc565b61047e610460366004612e6b565b61ffff165f908152600560205260409020546001600160a01b031690565b6040516001600160a01b03909116815260200161026f565b6102ed610d13565b6102ed6202848881565b5f546001600160a01b031661047e565b6102ed6203d09081565b61028b6104d0366004612e6b565b610d31565b6104e86104e3366004612f75565b610e16565b6040805160ff909416845267ffffffffffffffff928316602085015291169082015260600161026f565b60035462010000900461ffff1661035d565b6002546102ed565b6102e161053a366004612f1d565b610ec4565b61033061054d366004612edd565b611119565b610330610560366004612edd565b611153565b6102ed620668a081565b6102e161057d366004612f1d565b61118d565b610404610590366004612e6b565b6111c7565b6001546001600160a01b031661047e565b6010545f908190819061ffff908116908516106105ed5760105460405163d5e461d560e01b815261ffff808716600483015290911660248201526044015b60405180910390fd5b60118461ffff168154811061060457610604612fb0565b905f5260205f20906004020160030154925060118461ffff168154811061062d5761062d612fb0565b905f5260205f2090600402015f0154915060118461ffff168154811061065557610655612fb0565b905f5260205f2090600402016001015490509193909250565b6013545f908190600160201b900460ff161561071d5761ffff8084165f90815260076020526040902054168015806106b6575060035461ffff600160201b9091048116908216115b156106da5760405163033c90e360e31b815261ffff851660048201526024016105e4565b61ffff84165f90815260086020526040902054925060156106fc600183612fd8565b61ffff168154811061071057610710612fb0565b905f5260205f2001549150505b915091565b61072a611262565b600354610100900460ff161561075357604051630cdc4b0d60e31b815260040160405180910390fd5b6001600160a01b0383165f9081526004602052604090205461ffff1615610798576040516301f87a7b60e11b81526001600160a01b03841660048201526024016105e4565b60035461ffff6201000082048116600160201b90920416036107cd5760405163f9910d2b60e01b815260040160405180910390fd5b6003546601000000000000900461ffff166107e9816001612ffa565b6003805467ffff0000000000001916660100000000000061ffff9384160217908190555f9161082191600160201b9004166001612ffa565b6003805465ffff000000001916600160201b61ffff84160217905590507f00000000000000000000000000000000000000000000000000000000000000005f6108718661086c610bbe565b61128e565b905061087e8183886112b5565b955061088c856002546112c9565b94505f61089987846112e7565b90505f6108a687856112e7565b90506108b381858a6112b5565b97506108c08285896112b5565b96505f806108d18861ffff16611315565b905060026003805460ff16908111156108ec576108ec613015565b03610904576108f9611321565b91506109048261132c565b61090d8a61132c565b6109168961132c565b61091f8161132c565b8760065f8961ffff1661ffff1681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508660075f8a61ffff1661ffff1681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508760045f8d6001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508a60055f8a61ffff1661ffff1681526020019081526020015f205f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060405180608001604052808b81526020018a81526020018381526020018281525060085f8a61ffff1661ffff1681526020019081526020015f205f820151815f0155602082015181600101556040820151816002015560608201518160030155905050610a8960405180608001604052805f81526020015f81526020015f81526020015f81525090565b63deadbeef80825260208201818152604083018281526060840194855260118054600180820183555f92835295517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6860049092029182015592517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6984015590517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6a83015593517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6b90910155601280548084019091557fbb8a6a4669ba250d26cd7a459eca9d215f8307e33aebe50379bc5a3617ec3444018190556015805492830181559092527f55f448fdea98c4d29eb340757ef0a66cd03dbb9538908a6a81d96026b71ec475015550505050505050505050565b5f6002545f19610bce9190613029565b905090565b600380545f9160ff90911690811115610bce57610bce613015565b6001545f9081906001600160a01b03163314610c1d5760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611336565b915091505b935093915050565b610c3d611262565b600354610100900460ff1615610c6657604051630cdc4b0d60e31b815260040160405180910390fd5b610c6f5f6117e7565b565b610c79611262565b610c6f5f6118bc565b6001545f9081906001600160a01b03163314610cb15760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611918565b610cc4611262565b600354610100900460ff1615610ced57604051630cdc4b0d60e31b815260040160405180910390fd5b6002919091556003805461ffff909216620100000263ffff000019909216919091179055565b6013545f9065010000000000900460ff1615610d2e5750600a545b90565b5f805f601360059054906101000a900460ff16610d6057604051625cf4ff60e41b815260040160405180910390fd5b60105461ffff90811690851610610d9c57601054604051639b99854360e01b815261ffff808716600483015290911660248201526044016105e4565b60118461ffff1681548110610db357610db3612fb0565b905f5260205f20906004020160030154925060118461ffff1681548110610ddc57610ddc612fb0565b905f5260205f2090600402015f0154915060128461ffff1681548110610e0457610e04612fb0565b905f5260205f20015490509193909250565b5f805f610e21611262565b600354610100900460ff16610e3957610e395f6117e7565b60015460405163b189087960e01b815267ffffffffffffffff8716600482015285151560248201526001600160a01b039091169063b1890879906044016060604051808303815f875af1158015610e92573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610eb69190613048565b919790965090945092505050565b610ecc611262565b600354610100900460ff1615610ef557604051630cdc4b0d60e31b815260040160405180910390fd5b6001600160a01b0381165f9081526004602052604081205461ffff1690819003610f1d575050565b600354600160201b900461ffff16610f4a57604051636f72435d60e01b81526004818101526024016105e4565b61ffff8082165f908152600760205260409020541680610f8057604051636f72435d60e01b8152600560048201526024016105e4565b6001600160a01b0383165f908152600460209081526040808320805461ffff1916905561ffff85811684526005909252909120805473ffffffffffffffffffffffffffffffffffffffff19169055600354600160201b9004811690821610156110615760035461ffff600160201b90910481165f90815260066020526040902054168061102357604051636f72435d60e01b8152600660048201526024016105e4565b61ffff8083165f81815260066020908152604080832080549590961661ffff1995861681179096559482526007905292909220805490911690911790555b6003805461ffff600160201b9182900481165f908152600660209081526040808320805461ffff199081169091558885168085526007845282852080549092169091558151608081018352848152808401858152818401868152606083018781529387526008909552929094209351845590516001840155905160028301555190840155825491909104169060046110f883613097565b91906101000a81548161ffff021916908361ffff1602179055505050505b50565b6001545f9081906001600160a01b031633146111485760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611cd9565b6001545f9081906001600160a01b031633146111825760405163ca27b3c960e01b815260040160405180910390fd5b610c2885858561215e565b611195611262565b6001600160a01b0381166111be57604051631e4fbdf760e01b81525f60048201526024016105e4565b611116816118bc565b6003545f908190819061ffff600160201b90910481169085161061121857600354604051639b99854360e01b815261ffff8681166004830152600160201b90920490911660248201526044016105e4565b60065f611226866001612ffa565b61ffff908116825260208083019390935260409182015f9081205490911680825260089093522080546001909101549196909550909350915050565b5f546001600160a01b03163314610c6f5760405163118cdaa760e01b81523360048201526024016105e4565b5f826112a05761129d5f6123a4565b92505b6112ac838360016123b0565b90505b92915050565b5f6112c184848461246d565b949350505050565b5f826112db576112d85f6123a4565b92505b6112ac83836001612503565b5f826112f9576112f65f6123a4565b92505b8161130a576113075f6123a4565b91505b6112ac83835f61257a565b5f6112af8260036125f1565b5f610bce6008612684565b6111168130612717565b5f80611346620668a060026130b3565b5a10156113585750600290505f610c2d565b601054604080516080810182525f808252602082018190529181018290526060810182905261ffff90921691819081908482036114b2577f3e5fec24aa4dc4e5aee2e025e51e1392c72a2500577559fae9665c6d52bd6a315461ffff165f90815260086020526040812060118054919290916113d6576113d6612fb0565b5f918252602090912082546004909202019081556001808301548183015560028084015490830155600392830154918301919091559054600160201b900461ffff16900361143f5750506010805461ffff191660019081179091559450849350610c2d92505050565b50507f8819ef417987f8ae7a81f42cdfb18815282fe989326fbff903d13cf0e03ace295461ffff165f9081526008602090815260408083208151608081018352815481526001828101549482019490945260028201549281019290925260030154606082015290945090925083906114e8565b50600b5460408051608081018252600c548152600d546020820152600e5491810191909152600f54606082015261ffff90911693505b5f805b8a63ffffffff168163ffffffff161015611745575f61150a828d6130ca565b6115149088612ffa565b61ffff9081169150881681111561152c575061ffff87165b620668a061153e61ffff8916836130ca565b6115499060016130e7565b63ffffffff1661155991906130b3565b5a101561156a576002925050611745565b61157587828661278d565b61158361ffff8816826130ca565b61158d90836130e7565b9150600194508761ffff168163ffffffff1603611708578360118961ffff16815481106115bc576115bc612fb0565b5f918252602091829020835160049092020190815590820151600182015560408201516002820155606090910151600390910155876115fa81613104565b985050611606846128c4565b60035461ffff600160201b9091048116908916036116805763ffffffff8b1661162f838f6130e7565b63ffffffff161461165657604051636f72435d60e01b8152600860048201526024016105e4565b506010805461ffff191661ffff98909816979097179096555060019650939450610c2d9350505050565b5f96506008876006816116948c6001612ffa565b61ffff1661ffff1681526020019081526020015f205f9054906101000a900461ffff1661ffff1661ffff1681526020019081526020015f206040518060800160405290815f8201548152602001600182015481526020016002820154815260200160038201548152505093505f955061173f565b8b63ffffffff168263ffffffff161461173757604051636f72435d60e01b8152600960048201526024016105e4565b809650600195505b506114eb565b63ffffffff8a16611756828e6130e7565b63ffffffff161061177d57604051636f72435d60e01b8152600a60048201526024016105e4565b841561178c5761178c836128c4565b83156117b0578251600c556020830151600d556040830151600e556060830151600f555b6010805461ffff98891661ffff1991821617909155600b805497909816961695909517909555509294509092505050935093915050565b6003805461ff00191661010017908190556001546001600160a01b03169063c4ef91f29061ffff600160201b90910416622579c0611825620eec5090565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261ffff909316600484015263ffffffff918216602484015216604482015262166a48606482015262018a88608482015283151560a482015260c4015f604051808303815f87803b1580156118a3575f80fd5b505af11580156118b5573d5f803e3d5ffd5b5050505050565b5f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f80620271005a10156119305750600290505f610c2d565b60135460145460035461ffff8084169362010000900481169291600160201b90041683108015611970575060035461ffff600160201b9091048116908316105b80156119d0575060035461198f90600160201b900461ffff1680613124565b60035461ffff91821691899185916119af91600160201b90041687613124565b6119b99190612ffa565b61ffff166119c791906130e7565b63ffffffff1611155b6119f057604051636f72435d60e01b8152600e60048201526024016105e4565b6003548290611a0a90600160201b900461ffff1685613124565b611a149190612ffa565b61ffff168863ffffffff1614611a4057604051636f72435d60e01b8152600f60048201526024016105e4565b82825f8080611a565f546001600160a01b031690565b90505b8b63ffffffff168363ffffffff161015611bab575f611ac460118661ffff1681548110611a8857611a88612fb0565b905f5260205f2090600402016003015460065f896001611aa89190612ffa565b61ffff908116825260208201929092526040015f205416612900565b9050611af08160128761ffff1681548110611ae157611ae1612fb0565b905f5260205f200154896112b5565b965084611afc81613104565b60035490965061ffff600160201b9091048116908716039050611b83578660158761ffff1681548110611b3157611b31612fb0565b5f91825260209091200155611b458761132c565b611b4f8783612922565b611b5a600187612ffa565b95505f94507f000000000000000000000000000000000000000000000000000000000000000096505b83611b8d8161314a565b945050620271005a1015611ba5576002925050611bab565b50611a59565b63ffffffff8b16611bbc848f6130e7565b63ffffffff1603611c3d5760035461ffff868116600160201b90920416148015611be8575061ffff8416155b611c0857604051636f72435d60e01b8152601260048201526024016105e4565b50506003546013805464ff0000ffff191661ffff600160201b9384900416179091179055600197509550610c2d945050505050565b60035461ffff600160201b909104811690861610611c7157604051636f72435d60e01b8152601360048201526024016105e4565b8661ffff168461ffff1614611c99576013805463ffff000019166201000061ffff8716021790555b8761ffff168561ffff1614611cba576013805461ffff191661ffff87161790555b6014869055611cc88661132c565b509b909a5098505050505050505050565b5f806203d0905a1015611cf15750600290505f610c2d565b60035460105461ffff908116600160201b90920416148015611d235750600354601154600160201b90910461ffff1611155b611d4357604051636f72435d60e01b8152600b60048201526024016105e4565b845f611d538661ffff84166130e7565b90505f611d675f546001600160a01b031690565b90505f805f808661ffff165f03611ec75760115f81548110611d8b57611d8b612fb0565b905f5260205f20906004020160010154935060115f81548110611db057611db0612fb0565b905f5260205f2090600402015f015492505f611dce856002546112c9565b9050611dd98161132c565b611de38187612922565b611e0f60115f81548110611df957611df9612fb0565b905f5260205f2090600402016003015487612922565b611e3a60115f81548110611e2557611e25612fb0565b905f5260205f2090600402015f015487612922565b8060125f81548110611e4e57611e4e612fb0565b5f9182526020909120015561ffff8716600103611eb9576009859055600a84905563ffffffff8b1661ffff881603611ea657611e8a8487612922565b6013805465ff0000000000191665010000000000179055600191505b50975060019650610c2d95505050505050565b600197506001925050611ed2565b6009549350600a5492505b865b8661ffff168161ffff1610156120a0576203d0905a1015611ef857600291506120a0565b5f60118261ffff1681548110611f1057611f10612fb0565b905f5260205f2090600402016001015490505f60118361ffff1681548110611f3a57611f3a612fb0565b905f5260205f2090600402015f015490505f611f5888600254612930565b9050611f8d81611f88847f000000000000000000000000000000000000000000000000000000000000000061294e565b61297c565b90505f611f9c6002548a612988565b90505f611fd383611fad84886129b1565b7f00000000000000000000000000000000000000000000000000000000000000006112b5565b9050611fdf8a866129df565b9950611fec83858b6112b5565b9850611ff78161132c565b612001818c612922565b61203160118761ffff168154811061201b5761201b612fb0565b905f5260205f209060040201600301548c612922565b61206060118761ffff168154811061204b5761204b612fb0565b905f5260205f2090600402015f01548c612922565b8060128761ffff168154811061207857612078612fb0565b5f918252602090912001558761208d81613104565b9850505050505050806001019050611ed4565b5061ffff8216156120bd576120b48461132c565b6120bd8361132c565b6009849055600a83905563ffffffff8a166120dc61ffff84168e6130e7565b63ffffffff16111561210457604051636f72435d60e01b8152600d60048201526024016105e4565b63ffffffff8a1661211961ffff84168e6130e7565b63ffffffff16036121495761212e8386612922565b506013805465ff000000000019166501000000000017905560015b975061ffff1695505050505050935093915050565b5f80620284885a10156121765750600290505f610c2d565b5f61218185876130e7565b90505f805f6121975f546001600160a01b031690565b90505f808a5b8661ffff168161ffff16101561236b575f6006816121bc846001612ffa565b61ffff908116825260208201929092526040015f2054169050806121f657604051636f72435d60e01b8152600760048201526024016105e4565b61ffff81165f9081526008602052604081208054600182015490995097509061221f8989612a0d565b61ffff84165f908152600560205260408082205490516370a0823160e01b81526001600160a01b03918216600482015292935090916122ab918491908b16906370a0823190602401602060405180830381865afa158015612282573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122a69190613162565b612a3b565b90506122d8818b7f00000000000000000000000000000000000000000000000000000000000000006112b5565b9950612305818a7f00000000000000000000000000000000000000000000000000000000000000006112b5565b8a845560018401819055985061231a8a61132c565b6123238961132c565b61232d8a89612922565b6123378989612922565b8661234181613104565b975050620284885a101561235c57600295505050505061236b565b5050505080600101905061219d565b5063ffffffff891661238161ffff84168d6130e7565b63ffffffff1603612390575060015b965061ffff16945050505050935093915050565b5f6112af8260086125f1565b5f8082156123c35750600160f81b6123c6565b505f5b5f8051602061319a83398151915254604051631f31e28560e11b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690633e63c50a906064015b6020604051808303815f875af115801561243f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124639190613162565b9695505050505050565b5f805f8051602061317a833981519152600181015460405163cb3b940760e01b81526004810188905260248101879052604481018690529192506001600160a01b03169063cb3b9407906064016020604051808303815f875af11580156124d6573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124fa9190613162565b95945050505050565b5f8082156125165750600160f81b612519565b505f5b5f8051602061319a83398151915254604051632a1f7ab160e21b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063a87deac490606401612423565b5f80821561258d5750600160f81b612590565b505f5b5f8051602061319a83398151915254604051630d7c62eb60e31b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690636be3175890606401612423565b5f805f8051602061317a8339815191526001810154604051631ce2e8d760e31b8152600481018790526001600160f81b031960f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af1158015612660573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112c19190613162565b5f805f8051602061317a833981519152600181015460405163480694a760e11b81526001600160f81b031960f887901b1660048201529192506001600160a01b03169063900d294e906024016020604051808303815f875af11580156126ec573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127109190613162565b9392505050565b5f5f8051602061317a8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015612772575f80fd5b505af1158015612784573d5f803e3d5ffd5b50505050505050565b6127b460405180608001604052805f81526020015f81526020015f81526020015f81525090565b835b8361ffff168161ffff1610156118b5575f6127d082612a59565b805460018201546003830154875193945091929091905f9081906127f590869061294e565b90505f612805868b5f01516112e7565b90505f612816858c60600151612a84565b905061282b83612826848461297c565b612ab2565b935050505061283e81858a5f01516112b5565b8752602088015161285290829085906112b5565b6020880152606088015161286990829084906112b5565b6060880152875161287c908290866112b5565b8852602088015161288f908290856112b5565b602089015260608801516128a5908290846112b5565b60608901526128b48688612abe565b50505050508060010190506127b6565b80516128cf9061132c565b6128dc816020015161132c565b6128e9816060015161132c565b60408101511561111657611116816040015161132c565b5f826129125761290f5f611315565b92505b6112ac838361ffff16600161257a565b61292c8282612717565b5050565b5f826129425761293f5f6123a4565b92505b6112ac83836001612b14565b5f826129605761295d5f6123a4565b92505b816129715761296e5f6123a4565b91505b6112ac83835f6123b0565b5f6112ac83835f612b8b565b5f80612993846123a4565b9050826129a6576129a35f6123a4565b92505b6112c181845f612c02565b5f826129c3576129c05f6123a4565b92505b816129d4576129d15f6123a4565b91505b6112ac83835f612503565b5f826129f1576129ee5f6123a4565b92505b81612a02576129ff5f6123a4565b91505b6112ac83835f612c79565b5f82612a1f57612a1c5f6123a4565b92505b81612a3057612a2d5f6123a4565b91505b6112ac83835f612cf0565b5f82612a4d57612a4a5f6123a4565b92505b6112ac83836001612d67565b5f60118261ffff1681548110612a7157612a71612fb0565b905f5260205f2090600402019050919050565b5f82612a9657612a935f611315565b92505b81612aa757612aa45f611315565b91505b6112ac83835f612b14565b5f6112ac83835f612dde565b8060118361ffff1681548110612ad657612ad6612fb0565b905f5260205f2090600402015f820151815f015560208201518160010155604082015181600201556060820151816003015590505061292c816128c4565b5f808215612b275750600160f81b612b2a565b505f5b5f8051602061319a83398151915254604051639675211f60e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690639675211f90606401612423565b5f808215612b9e5750600160f81b612ba1565b505f5b5f8051602061319a83398151915254604051630ccd46b160e31b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063666a358890606401612423565b5f808215612c155750600160f81b612c18565b505f5b5f8051602061319a83398151915254604051638c14cc2160e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690638c14cc2190606401612423565b5f808215612c8c5750600160f81b612c8f565b505f5b5f8051602061319a8339815191525460405163f953e42760e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063f953e42790606401612423565b5f808215612d035750600160f81b612d06565b505f5b5f8051602061319a8339815191525460405163816d57d360e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063816d57d390606401612423565b5f808215612d7a5750600160f81b612d7d565b505f5b5f8051602061319a833981519152546040516334a6d7b960e11b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063694daf7290606401612423565b5f808215612df15750600160f81b612df4565b505f5b5f8051602061319a83398151915254604051633b1015f760e21b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063ec4057dc90606401612423565b803561ffff81168114612e66575f80fd5b919050565b5f60208284031215612e7b575f80fd5b6112ac82612e55565b80356001600160a01b0381168114612e66575f80fd5b5f805f60608486031215612eac575f80fd5b612eb584612e84565b95602085013595506040909401359392505050565b803563ffffffff81168114612e66575f80fd5b5f805f60608486031215612eef575f80fd5b612ef884612eca565b9250612f0660208501612eca565b9150612f1460408501612eca565b90509250925092565b5f60208284031215612f2d575f80fd5b6112ac82612e84565b5f8060408385031215612f47575f80fd5b82359150612f5760208401612e55565b90509250929050565b67ffffffffffffffff81168114611116575f80fd5b5f8060408385031215612f86575f80fd5b8235612f9181612f60565b915060208301358015158114612fa5575f80fd5b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b61ffff828116828216039080821115612ff357612ff3612fc4565b5092915050565b61ffff818116838216019080821115612ff357612ff3612fc4565b634e487b7160e01b5f52602160045260245ffd5b5f8261304357634e487b7160e01b5f52601260045260245ffd5b500490565b5f805f6060848603121561305a575f80fd5b835160ff8116811461306a575f80fd5b602085015190935061307b81612f60565b604085015190925061308c81612f60565b809150509250925092565b5f61ffff8216806130aa576130aa612fc4565b5f190192915050565b80820281158282048414176112af576112af612fc4565b63ffffffff828116828216039080821115612ff357612ff3612fc4565b63ffffffff818116838216019080821115612ff357612ff3612fc4565b5f61ffff80831681810361311a5761311a612fc4565b6001019392505050565b61ffff81811683821602808216919082811461314257613142612fc4565b505092915050565b5f63ffffffff80831681810361311a5761311a612fc4565b5f60208284031215613172575f80fd5b505191905056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600ed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000aed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a164736f6c6343000818000a",
  "deployedBytecode": "0x608060405234801562000010575f80fd5b506004361062000078575f3560e01c80638da5cb5b11620000535780638da5cb5b14620000c5578063e30c397814620000d6578063f2fde38b14620000e8575f80fd5b8063715018a6146200007c57806379ba509714620000885780637e1c07101462000092575b5f80fd5b62000086620000ff565b005b6200008662000116565b620000a9620000a336600462000505565b62000162565b6040516001600160a01b03909116815260200160405180910390f35b5f546001600160a01b0316620000a9565b6001546001600160a01b0316620000a9565b62000086620000f936600462000505565b6200029f565b620001096200031f565b620001145f6200034d565b565b60015433906001600160a01b03168114620001545760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6200015f816200034d565b50565b600254604051631fbddea160e21b81523060048201525f9182916001600160a01b0390911690637ef77a84906024016020604051808303815f875af1158015620001ae573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620001d491906200052a565b90505f620001e3308362000375565b60405163f2fde38b60e01b81526001600160a01b0380831660048301529192509083169063f2fde38b906024015f604051808303815f87803b15801562000228575f80fd5b505af11580156200023b573d5f803e3d5ffd5b505060405163f2fde38b60e01b81526001600160a01b0387811660048301528416925063f2fde38b91506024015f604051808303815f87803b15801562000280575f80fd5b505af115801562000293573d5f803e3d5ffd5b50929695505050505050565b620002a96200031f565b600180546001600160a01b03831673ffffffffffffffffffffffffffffffffffffffff199091168117909155620002e75f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b03163314620001145760405163118cdaa760e01b81523360048201526024016200014b565b6001805473ffffffffffffffffffffffffffffffffffffffff191690556200015f8162000486565b5f826001600160a01b0316826001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620003bd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620003e391906200052a565b6001600160a01b0316146200043b5760405162461bcd60e51b815260206004820152600b60248201527f57726f6e67206f776e657200000000000000000000000000000000000000000060448201526064016200014b565b5f83836040516200044c90620004e2565b6001600160a01b03928316815291166020820152604001604051809103905ff0801580156200047d573d5f803e3d5ffd5b50949350505050565b5f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6137ba806200054983390190565b6001600160a01b03811681146200015f575f80fd5b5f6020828403121562000516575f80fd5b81356200052381620004f0565b9392505050565b5f602082840312156200053b575f80fd5b81516200052381620004f056fe60a060405234801562000010575f80fd5b50604051620037ba380380620037ba833981016040819052620000339162000513565b815f8282620000dd620000d7604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b6200028b565b6001600160a01b0381166200010b57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b620001168162000358565b506001600160a01b0381161580620001a25750826001600160a01b0316816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000170573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906200019691906200055d565b6001600160a01b031614155b15620001c15760405163d855fd1760e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b03831617905560ff82166003811115620001f457620001f462000549565b6003805460ff19166001838381111562000212576200021262000549565b02179055505f6200022381620003a7565b90506200023081620003bb565b60808190526009819055600a81905563deadbeef600c819055600d819055600f55600b805461ffff191661dead17905560145550506003805466010000ffff000067ffff0000ffff0000199091161790555062000598915050565b80515f805160206200379a83398151915280546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b50565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f620003b5826008620003c7565b92915050565b6200035581306200047e565b5f805f805160206200379a8339815191526001810154604051631ce2e8d760e31b8152600481018790527fff0000000000000000000000000000000000000000000000000000000000000060f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af115801562000450573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000476919062000580565b949350505050565b5f5f805160206200379a8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015620004db575f80fd5b505af1158015620004ee573d5f803e3d5ffd5b50505050505050565b80516001600160a01b03811681146200050e575f80fd5b919050565b5f806040838503121562000525575f80fd5b6200053083620004f7565b91506200054060208401620004f7565b90509250929050565b634e487b7160e01b5f52602160045260245ffd5b5f602082840312156200056e575f80fd5b6200057982620004f7565b9392505050565b5f6020828403121562000591575f80fd5b5051919050565b6080516131c6620005d45f395f818161084001528181611b6101528181611f6401528181611faf015281816122b401526122e101526131c65ff3fe608060405234801561000f575f80fd5b506004361061024f575f3560e01c80637ca40d1c1161013d578063c15bd28f116100b8578063e8f5858111610088578063f2fde38b1161006e578063f2fde38b1461056f578063fcd9107614610582578063fddcc14814610595575f80fd5b8063e8f5858114610552578063e9a04b0c14610565575f80fd5b8063c15bd28f14610512578063c616f41214610524578063d36256081461052c578063dcc5ed201461053f575f80fd5b80638da5cb5b1161010d578063983fc6e1116100f3578063983fc6e1146102535780639da3604a146104c2578063b1890879146104d5575f80fd5b80638da5cb5b146104a8578063938e1222146104b8575f80fd5b80637ca40d1c1461043f578063869a0ca41461045257806386eea6c2146104965780638a88cb6f1461049e575f80fd5b8063290d2e8c116101cd5780635471e17f1161019d5780636dc7a627116101835780636dc7a62714610370578063715018a6146104245780637562fa0b1461042c575f80fd5b80635471e17f146103be5780635c94cb0c14610253575f80fd5b8063290d2e8c146103705780632f64cdf01461038257806333a581d2146103ae57806343d726d6146103b6575f80fd5b806318083d061161022257806326c8a7571161020857806326c8a75714610303578063285bb3931461031d57806328f6a48a1461034e575f80fd5b806318083d06146102e357806323e45f62146102fb575f80fd5b806302dda9cf146102535780630aa50fe0146102785780630de7056b146102a657806316e807c4146102ce575b5f80fd5b60135465010000000000900460ff165b60405190151581526020015b60405180910390f35b61028b610286366004612e6b565b6105a6565b6040805193845260208401929092529082015260600161026f565b6102b96102b4366004612e6b565b61066e565b6040805192835260208301919091520161026f565b6102e16102dc366004612e9a565b610722565b005b6102ed6202710081565b60405190815260200161026f565b6102ed610bbe565b61030b610bd3565b60405160ff909116815260200161026f565b61033061032b366004612edd565b610bee565b6040805160ff909316835263ffffffff90911660208301520161026f565b600354600160201b900461ffff165b60405161ffff909116815260200161026f565b601354600160201b900460ff16610263565b61035d610390366004612f1d565b6001600160a01b03165f9081526004602052604090205461ffff1690565b6102ed5f1981565b6102e1610c35565b6104046103cc366004612f1d565b6001600160a01b03165f9081526004602090815260408083205461ffff16808452600890925290912080546001909101549192909190565b6040805161ffff909416845260208401929092529082015260600161026f565b6102e1610c71565b61033061043a366004612edd565b610c82565b6102e161044d366004612f36565b610cbc565b61047e610460366004612e6b565b61ffff165f908152600560205260409020546001600160a01b031690565b6040516001600160a01b03909116815260200161026f565b6102ed610d13565b6102ed6202848881565b5f546001600160a01b031661047e565b6102ed6203d09081565b61028b6104d0366004612e6b565b610d31565b6104e86104e3366004612f75565b610e16565b6040805160ff909416845267ffffffffffffffff928316602085015291169082015260600161026f565b60035462010000900461ffff1661035d565b6002546102ed565b6102e161053a366004612f1d565b610ec4565b61033061054d366004612edd565b611119565b610330610560366004612edd565b611153565b6102ed620668a081565b6102e161057d366004612f1d565b61118d565b610404610590366004612e6b565b6111c7565b6001546001600160a01b031661047e565b6010545f908190819061ffff908116908516106105ed5760105460405163d5e461d560e01b815261ffff808716600483015290911660248201526044015b60405180910390fd5b60118461ffff168154811061060457610604612fb0565b905f5260205f20906004020160030154925060118461ffff168154811061062d5761062d612fb0565b905f5260205f2090600402015f0154915060118461ffff168154811061065557610655612fb0565b905f5260205f2090600402016001015490509193909250565b6013545f908190600160201b900460ff161561071d5761ffff8084165f90815260076020526040902054168015806106b6575060035461ffff600160201b9091048116908216115b156106da5760405163033c90e360e31b815261ffff851660048201526024016105e4565b61ffff84165f90815260086020526040902054925060156106fc600183612fd8565b61ffff168154811061071057610710612fb0565b905f5260205f2001549150505b915091565b61072a611262565b600354610100900460ff161561075357604051630cdc4b0d60e31b815260040160405180910390fd5b6001600160a01b0383165f9081526004602052604090205461ffff1615610798576040516301f87a7b60e11b81526001600160a01b03841660048201526024016105e4565b60035461ffff6201000082048116600160201b90920416036107cd5760405163f9910d2b60e01b815260040160405180910390fd5b6003546601000000000000900461ffff166107e9816001612ffa565b6003805467ffff0000000000001916660100000000000061ffff9384160217908190555f9161082191600160201b9004166001612ffa565b6003805465ffff000000001916600160201b61ffff84160217905590507f00000000000000000000000000000000000000000000000000000000000000005f6108718661086c610bbe565b61128e565b905061087e8183886112b5565b955061088c856002546112c9565b94505f61089987846112e7565b90505f6108a687856112e7565b90506108b381858a6112b5565b97506108c08285896112b5565b96505f806108d18861ffff16611315565b905060026003805460ff16908111156108ec576108ec613015565b03610904576108f9611321565b91506109048261132c565b61090d8a61132c565b6109168961132c565b61091f8161132c565b8760065f8961ffff1661ffff1681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508660075f8a61ffff1661ffff1681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508760045f8d6001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548161ffff021916908361ffff1602179055508a60055f8a61ffff1661ffff1681526020019081526020015f205f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060405180608001604052808b81526020018a81526020018381526020018281525060085f8a61ffff1661ffff1681526020019081526020015f205f820151815f0155602082015181600101556040820151816002015560608201518160030155905050610a8960405180608001604052805f81526020015f81526020015f81526020015f81525090565b63deadbeef80825260208201818152604083018281526060840194855260118054600180820183555f92835295517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6860049092029182015592517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6984015590517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6a83015593517f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c6b90910155601280548084019091557fbb8a6a4669ba250d26cd7a459eca9d215f8307e33aebe50379bc5a3617ec3444018190556015805492830181559092527f55f448fdea98c4d29eb340757ef0a66cd03dbb9538908a6a81d96026b71ec475015550505050505050505050565b5f6002545f19610bce9190613029565b905090565b600380545f9160ff90911690811115610bce57610bce613015565b6001545f9081906001600160a01b03163314610c1d5760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611336565b915091505b935093915050565b610c3d611262565b600354610100900460ff1615610c6657604051630cdc4b0d60e31b815260040160405180910390fd5b610c6f5f6117e7565b565b610c79611262565b610c6f5f6118bc565b6001545f9081906001600160a01b03163314610cb15760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611918565b610cc4611262565b600354610100900460ff1615610ced57604051630cdc4b0d60e31b815260040160405180910390fd5b6002919091556003805461ffff909216620100000263ffff000019909216919091179055565b6013545f9065010000000000900460ff1615610d2e5750600a545b90565b5f805f601360059054906101000a900460ff16610d6057604051625cf4ff60e41b815260040160405180910390fd5b60105461ffff90811690851610610d9c57601054604051639b99854360e01b815261ffff808716600483015290911660248201526044016105e4565b60118461ffff1681548110610db357610db3612fb0565b905f5260205f20906004020160030154925060118461ffff1681548110610ddc57610ddc612fb0565b905f5260205f2090600402015f0154915060128461ffff1681548110610e0457610e04612fb0565b905f5260205f20015490509193909250565b5f805f610e21611262565b600354610100900460ff16610e3957610e395f6117e7565b60015460405163b189087960e01b815267ffffffffffffffff8716600482015285151560248201526001600160a01b039091169063b1890879906044016060604051808303815f875af1158015610e92573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610eb69190613048565b919790965090945092505050565b610ecc611262565b600354610100900460ff1615610ef557604051630cdc4b0d60e31b815260040160405180910390fd5b6001600160a01b0381165f9081526004602052604081205461ffff1690819003610f1d575050565b600354600160201b900461ffff16610f4a57604051636f72435d60e01b81526004818101526024016105e4565b61ffff8082165f908152600760205260409020541680610f8057604051636f72435d60e01b8152600560048201526024016105e4565b6001600160a01b0383165f908152600460209081526040808320805461ffff1916905561ffff85811684526005909252909120805473ffffffffffffffffffffffffffffffffffffffff19169055600354600160201b9004811690821610156110615760035461ffff600160201b90910481165f90815260066020526040902054168061102357604051636f72435d60e01b8152600660048201526024016105e4565b61ffff8083165f81815260066020908152604080832080549590961661ffff1995861681179096559482526007905292909220805490911690911790555b6003805461ffff600160201b9182900481165f908152600660209081526040808320805461ffff199081169091558885168085526007845282852080549092169091558151608081018352848152808401858152818401868152606083018781529387526008909552929094209351845590516001840155905160028301555190840155825491909104169060046110f883613097565b91906101000a81548161ffff021916908361ffff1602179055505050505b50565b6001545f9081906001600160a01b031633146111485760405163ca27b3c960e01b815260040160405180910390fd5b610c28858585611cd9565b6001545f9081906001600160a01b031633146111825760405163ca27b3c960e01b815260040160405180910390fd5b610c2885858561215e565b611195611262565b6001600160a01b0381166111be57604051631e4fbdf760e01b81525f60048201526024016105e4565b611116816118bc565b6003545f908190819061ffff600160201b90910481169085161061121857600354604051639b99854360e01b815261ffff8681166004830152600160201b90920490911660248201526044016105e4565b60065f611226866001612ffa565b61ffff908116825260208083019390935260409182015f9081205490911680825260089093522080546001909101549196909550909350915050565b5f546001600160a01b03163314610c6f5760405163118cdaa760e01b81523360048201526024016105e4565b5f826112a05761129d5f6123a4565b92505b6112ac838360016123b0565b90505b92915050565b5f6112c184848461246d565b949350505050565b5f826112db576112d85f6123a4565b92505b6112ac83836001612503565b5f826112f9576112f65f6123a4565b92505b8161130a576113075f6123a4565b91505b6112ac83835f61257a565b5f6112af8260036125f1565b5f610bce6008612684565b6111168130612717565b5f80611346620668a060026130b3565b5a10156113585750600290505f610c2d565b601054604080516080810182525f808252602082018190529181018290526060810182905261ffff90921691819081908482036114b2577f3e5fec24aa4dc4e5aee2e025e51e1392c72a2500577559fae9665c6d52bd6a315461ffff165f90815260086020526040812060118054919290916113d6576113d6612fb0565b5f918252602090912082546004909202019081556001808301548183015560028084015490830155600392830154918301919091559054600160201b900461ffff16900361143f5750506010805461ffff191660019081179091559450849350610c2d92505050565b50507f8819ef417987f8ae7a81f42cdfb18815282fe989326fbff903d13cf0e03ace295461ffff165f9081526008602090815260408083208151608081018352815481526001828101549482019490945260028201549281019290925260030154606082015290945090925083906114e8565b50600b5460408051608081018252600c548152600d546020820152600e5491810191909152600f54606082015261ffff90911693505b5f805b8a63ffffffff168163ffffffff161015611745575f61150a828d6130ca565b6115149088612ffa565b61ffff9081169150881681111561152c575061ffff87165b620668a061153e61ffff8916836130ca565b6115499060016130e7565b63ffffffff1661155991906130b3565b5a101561156a576002925050611745565b61157587828661278d565b61158361ffff8816826130ca565b61158d90836130e7565b9150600194508761ffff168163ffffffff1603611708578360118961ffff16815481106115bc576115bc612fb0565b5f918252602091829020835160049092020190815590820151600182015560408201516002820155606090910151600390910155876115fa81613104565b985050611606846128c4565b60035461ffff600160201b9091048116908916036116805763ffffffff8b1661162f838f6130e7565b63ffffffff161461165657604051636f72435d60e01b8152600860048201526024016105e4565b506010805461ffff191661ffff98909816979097179096555060019650939450610c2d9350505050565b5f96506008876006816116948c6001612ffa565b61ffff1661ffff1681526020019081526020015f205f9054906101000a900461ffff1661ffff1661ffff1681526020019081526020015f206040518060800160405290815f8201548152602001600182015481526020016002820154815260200160038201548152505093505f955061173f565b8b63ffffffff168263ffffffff161461173757604051636f72435d60e01b8152600960048201526024016105e4565b809650600195505b506114eb565b63ffffffff8a16611756828e6130e7565b63ffffffff161061177d57604051636f72435d60e01b8152600a60048201526024016105e4565b841561178c5761178c836128c4565b83156117b0578251600c556020830151600d556040830151600e556060830151600f555b6010805461ffff98891661ffff1991821617909155600b805497909816961695909517909555509294509092505050935093915050565b6003805461ff00191661010017908190556001546001600160a01b03169063c4ef91f29061ffff600160201b90910416622579c0611825620eec5090565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815261ffff909316600484015263ffffffff918216602484015216604482015262166a48606482015262018a88608482015283151560a482015260c4015f604051808303815f87803b1580156118a3575f80fd5b505af11580156118b5573d5f803e3d5ffd5b5050505050565b5f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f80620271005a10156119305750600290505f610c2d565b60135460145460035461ffff8084169362010000900481169291600160201b90041683108015611970575060035461ffff600160201b9091048116908316105b80156119d0575060035461198f90600160201b900461ffff1680613124565b60035461ffff91821691899185916119af91600160201b90041687613124565b6119b99190612ffa565b61ffff166119c791906130e7565b63ffffffff1611155b6119f057604051636f72435d60e01b8152600e60048201526024016105e4565b6003548290611a0a90600160201b900461ffff1685613124565b611a149190612ffa565b61ffff168863ffffffff1614611a4057604051636f72435d60e01b8152600f60048201526024016105e4565b82825f8080611a565f546001600160a01b031690565b90505b8b63ffffffff168363ffffffff161015611bab575f611ac460118661ffff1681548110611a8857611a88612fb0565b905f5260205f2090600402016003015460065f896001611aa89190612ffa565b61ffff908116825260208201929092526040015f205416612900565b9050611af08160128761ffff1681548110611ae157611ae1612fb0565b905f5260205f200154896112b5565b965084611afc81613104565b60035490965061ffff600160201b9091048116908716039050611b83578660158761ffff1681548110611b3157611b31612fb0565b5f91825260209091200155611b458761132c565b611b4f8783612922565b611b5a600187612ffa565b95505f94507f000000000000000000000000000000000000000000000000000000000000000096505b83611b8d8161314a565b945050620271005a1015611ba5576002925050611bab565b50611a59565b63ffffffff8b16611bbc848f6130e7565b63ffffffff1603611c3d5760035461ffff868116600160201b90920416148015611be8575061ffff8416155b611c0857604051636f72435d60e01b8152601260048201526024016105e4565b50506003546013805464ff0000ffff191661ffff600160201b9384900416179091179055600197509550610c2d945050505050565b60035461ffff600160201b909104811690861610611c7157604051636f72435d60e01b8152601360048201526024016105e4565b8661ffff168461ffff1614611c99576013805463ffff000019166201000061ffff8716021790555b8761ffff168561ffff1614611cba576013805461ffff191661ffff87161790555b6014869055611cc88661132c565b509b909a5098505050505050505050565b5f806203d0905a1015611cf15750600290505f610c2d565b60035460105461ffff908116600160201b90920416148015611d235750600354601154600160201b90910461ffff1611155b611d4357604051636f72435d60e01b8152600b60048201526024016105e4565b845f611d538661ffff84166130e7565b90505f611d675f546001600160a01b031690565b90505f805f808661ffff165f03611ec75760115f81548110611d8b57611d8b612fb0565b905f5260205f20906004020160010154935060115f81548110611db057611db0612fb0565b905f5260205f2090600402015f015492505f611dce856002546112c9565b9050611dd98161132c565b611de38187612922565b611e0f60115f81548110611df957611df9612fb0565b905f5260205f2090600402016003015487612922565b611e3a60115f81548110611e2557611e25612fb0565b905f5260205f2090600402015f015487612922565b8060125f81548110611e4e57611e4e612fb0565b5f9182526020909120015561ffff8716600103611eb9576009859055600a84905563ffffffff8b1661ffff881603611ea657611e8a8487612922565b6013805465ff0000000000191665010000000000179055600191505b50975060019650610c2d95505050505050565b600197506001925050611ed2565b6009549350600a5492505b865b8661ffff168161ffff1610156120a0576203d0905a1015611ef857600291506120a0565b5f60118261ffff1681548110611f1057611f10612fb0565b905f5260205f2090600402016001015490505f60118361ffff1681548110611f3a57611f3a612fb0565b905f5260205f2090600402015f015490505f611f5888600254612930565b9050611f8d81611f88847f000000000000000000000000000000000000000000000000000000000000000061294e565b61297c565b90505f611f9c6002548a612988565b90505f611fd383611fad84886129b1565b7f00000000000000000000000000000000000000000000000000000000000000006112b5565b9050611fdf8a866129df565b9950611fec83858b6112b5565b9850611ff78161132c565b612001818c612922565b61203160118761ffff168154811061201b5761201b612fb0565b905f5260205f209060040201600301548c612922565b61206060118761ffff168154811061204b5761204b612fb0565b905f5260205f2090600402015f01548c612922565b8060128761ffff168154811061207857612078612fb0565b5f918252602090912001558761208d81613104565b9850505050505050806001019050611ed4565b5061ffff8216156120bd576120b48461132c565b6120bd8361132c565b6009849055600a83905563ffffffff8a166120dc61ffff84168e6130e7565b63ffffffff16111561210457604051636f72435d60e01b8152600d60048201526024016105e4565b63ffffffff8a1661211961ffff84168e6130e7565b63ffffffff16036121495761212e8386612922565b506013805465ff000000000019166501000000000017905560015b975061ffff1695505050505050935093915050565b5f80620284885a10156121765750600290505f610c2d565b5f61218185876130e7565b90505f805f6121975f546001600160a01b031690565b90505f808a5b8661ffff168161ffff16101561236b575f6006816121bc846001612ffa565b61ffff908116825260208201929092526040015f2054169050806121f657604051636f72435d60e01b8152600760048201526024016105e4565b61ffff81165f9081526008602052604081208054600182015490995097509061221f8989612a0d565b61ffff84165f908152600560205260408082205490516370a0823160e01b81526001600160a01b03918216600482015292935090916122ab918491908b16906370a0823190602401602060405180830381865afa158015612282573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122a69190613162565b612a3b565b90506122d8818b7f00000000000000000000000000000000000000000000000000000000000000006112b5565b9950612305818a7f00000000000000000000000000000000000000000000000000000000000000006112b5565b8a845560018401819055985061231a8a61132c565b6123238961132c565b61232d8a89612922565b6123378989612922565b8661234181613104565b975050620284885a101561235c57600295505050505061236b565b5050505080600101905061219d565b5063ffffffff891661238161ffff84168d6130e7565b63ffffffff1603612390575060015b965061ffff16945050505050935093915050565b5f6112af8260086125f1565b5f8082156123c35750600160f81b6123c6565b505f5b5f8051602061319a83398151915254604051631f31e28560e11b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690633e63c50a906064015b6020604051808303815f875af115801561243f573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124639190613162565b9695505050505050565b5f805f8051602061317a833981519152600181015460405163cb3b940760e01b81526004810188905260248101879052604481018690529192506001600160a01b03169063cb3b9407906064016020604051808303815f875af11580156124d6573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124fa9190613162565b95945050505050565b5f8082156125165750600160f81b612519565b505f5b5f8051602061319a83398151915254604051632a1f7ab160e21b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063a87deac490606401612423565b5f80821561258d5750600160f81b612590565b505f5b5f8051602061319a83398151915254604051630d7c62eb60e31b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690636be3175890606401612423565b5f805f8051602061317a8339815191526001810154604051631ce2e8d760e31b8152600481018790526001600160f81b031960f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af1158015612660573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112c19190613162565b5f805f8051602061317a833981519152600181015460405163480694a760e11b81526001600160f81b031960f887901b1660048201529192506001600160a01b03169063900d294e906024016020604051808303815f875af11580156126ec573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127109190613162565b9392505050565b5f5f8051602061317a8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015612772575f80fd5b505af1158015612784573d5f803e3d5ffd5b50505050505050565b6127b460405180608001604052805f81526020015f81526020015f81526020015f81525090565b835b8361ffff168161ffff1610156118b5575f6127d082612a59565b805460018201546003830154875193945091929091905f9081906127f590869061294e565b90505f612805868b5f01516112e7565b90505f612816858c60600151612a84565b905061282b83612826848461297c565b612ab2565b935050505061283e81858a5f01516112b5565b8752602088015161285290829085906112b5565b6020880152606088015161286990829084906112b5565b6060880152875161287c908290866112b5565b8852602088015161288f908290856112b5565b602089015260608801516128a5908290846112b5565b60608901526128b48688612abe565b50505050508060010190506127b6565b80516128cf9061132c565b6128dc816020015161132c565b6128e9816060015161132c565b60408101511561111657611116816040015161132c565b5f826129125761290f5f611315565b92505b6112ac838361ffff16600161257a565b61292c8282612717565b5050565b5f826129425761293f5f6123a4565b92505b6112ac83836001612b14565b5f826129605761295d5f6123a4565b92505b816129715761296e5f6123a4565b91505b6112ac83835f6123b0565b5f6112ac83835f612b8b565b5f80612993846123a4565b9050826129a6576129a35f6123a4565b92505b6112c181845f612c02565b5f826129c3576129c05f6123a4565b92505b816129d4576129d15f6123a4565b91505b6112ac83835f612503565b5f826129f1576129ee5f6123a4565b92505b81612a02576129ff5f6123a4565b91505b6112ac83835f612c79565b5f82612a1f57612a1c5f6123a4565b92505b81612a3057612a2d5f6123a4565b91505b6112ac83835f612cf0565b5f82612a4d57612a4a5f6123a4565b92505b6112ac83836001612d67565b5f60118261ffff1681548110612a7157612a71612fb0565b905f5260205f2090600402019050919050565b5f82612a9657612a935f611315565b92505b81612aa757612aa45f611315565b91505b6112ac83835f612b14565b5f6112ac83835f612dde565b8060118361ffff1681548110612ad657612ad6612fb0565b905f5260205f2090600402015f820151815f015560208201518160010155604082015181600201556060820151816003015590505061292c816128c4565b5f808215612b275750600160f81b612b2a565b505f5b5f8051602061319a83398151915254604051639675211f60e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690639675211f90606401612423565b5f808215612b9e5750600160f81b612ba1565b505f5b5f8051602061319a83398151915254604051630ccd46b160e31b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063666a358890606401612423565b5f808215612c155750600160f81b612c18565b505f5b5f8051602061319a83398151915254604051638c14cc2160e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b031690638c14cc2190606401612423565b5f808215612c8c5750600160f81b612c8f565b505f5b5f8051602061319a8339815191525460405163f953e42760e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063f953e42790606401612423565b5f808215612d035750600160f81b612d06565b505f5b5f8051602061319a8339815191525460405163816d57d360e01b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063816d57d390606401612423565b5f808215612d7a5750600160f81b612d7d565b505f5b5f8051602061319a833981519152546040516334a6d7b960e11b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063694daf7290606401612423565b5f808215612df15750600160f81b612df4565b505f5b5f8051602061319a83398151915254604051633b1015f760e21b815260048101879052602481018690526001600160f81b0319831660448201525f8051602061317a833981519152916001600160a01b03169063ec4057dc90606401612423565b803561ffff81168114612e66575f80fd5b919050565b5f60208284031215612e7b575f80fd5b6112ac82612e55565b80356001600160a01b0381168114612e66575f80fd5b5f805f60608486031215612eac575f80fd5b612eb584612e84565b95602085013595506040909401359392505050565b803563ffffffff81168114612e66575f80fd5b5f805f60608486031215612eef575f80fd5b612ef884612eca565b9250612f0660208501612eca565b9150612f1460408501612eca565b90509250925092565b5f60208284031215612f2d575f80fd5b6112ac82612e84565b5f8060408385031215612f47575f80fd5b82359150612f5760208401612e55565b90509250929050565b67ffffffffffffffff81168114611116575f80fd5b5f8060408385031215612f86575f80fd5b8235612f9181612f60565b915060208301358015158114612fa5575f80fd5b809150509250929050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b61ffff828116828216039080821115612ff357612ff3612fc4565b5092915050565b61ffff818116838216019080821115612ff357612ff3612fc4565b634e487b7160e01b5f52602160045260245ffd5b5f8261304357634e487b7160e01b5f52601260045260245ffd5b500490565b5f805f6060848603121561305a575f80fd5b835160ff8116811461306a575f80fd5b602085015190935061307b81612f60565b604085015190925061308c81612f60565b809150509250925092565b5f61ffff8216806130aa576130aa612fc4565b5f190192915050565b80820281158282048414176112af576112af612fc4565b63ffffffff828116828216039080821115612ff357612ff3612fc4565b63ffffffff818116838216019080821115612ff357612ff3612fc4565b5f61ffff80831681810361311a5761311a612fc4565b6001019392505050565b61ffff81811683821602808216919082811461314257613142612fc4565b505092915050565b5f63ffffffff80831681810361311a5761311a612fc4565b5f60208284031215613172575f80fd5b505191905056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600ed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000aed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a164736f6c6343000818000a",
  "devdoc": {
    "errors": {
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "createNewEngine(address)": {
        "details": "Deploys a new FHEAuctionEngine contract. - engine.owner() == `auctionAddr`"
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8,
        "contract": "contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol:FHEAuctionEnginePriceIdFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 156,
        "contract": "contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol:FHEAuctionEnginePriceIdFactory",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 9086,
        "contract": "contracts/engines/factories/FHEAuctionEnginePriceIdFactory.sol:FHEAuctionEnginePriceIdFactory",
        "label": "_iteratorFactory",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(FHEAuctionEngineIteratorFactory)9200"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(FHEAuctionEngineIteratorFactory)9200": {
        "encoding": "inplace",
        "label": "contract FHEAuctionEngineIteratorFactory",
        "numberOfBytes": "20"
      }
    }
  }
}