{
  "address": "0x564F52dE1185D705d61fDC0A1F9095BbbF1F7655",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract FHEAuctionEngineFactory",
              "name": "enginePriceIdFactory",
              "type": "address"
            },
            {
              "internalType": "contract FHEAuctionEngineFactory",
              "name": "enginePriceQuantityIdFactory",
              "type": "address"
            },
            {
              "internalType": "contract FHEAuctionEngineFactory",
              "name": "enginePriceRandomFactory",
              "type": "address"
            },
            {
              "internalType": "contract FHEAuctionEngineFactory",
              "name": "engineProRataFactory",
              "type": "address"
            }
          ],
          "internalType": "struct FHEAuctionFactory.FHEAuctionFactoryDetails",
          "name": "details_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Create2EmptyBytecode",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedDeployment",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        }
      ],
      "name": "InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "auction_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "salt_",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "beneficiary_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "auctionToken_",
          "type": "address"
        }
      ],
      "name": "FHEAuctionNativeDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt_",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "beneficiary_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "auctionToken_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minimumPaymentDeposit_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "paymentPenalty_",
          "type": "uint256"
        }
      ],
      "name": "computeAuctionAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "auctionOwner_",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt_",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "beneficiary_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "auctionQuantity_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "auctionToken_",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "maxBidCount_",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "tieBreakingRule_",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "minimumPaymentDeposit_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "paymentPenalty_",
          "type": "uint256"
        }
      ],
      "name": "createNewAuction",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt_",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "beneficiary_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "auctionToken_",
          "type": "address"
        }
      ],
      "name": "getAuction",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isNative",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xeba1cdfb0fc79a05d07ce9b3cd07ee7986edd5bd05cd384b12fe14aca0b744bb",
  "receipt": {
    "to": null,
    "from": "0x37AC010c1c566696326813b840319B58Bb5840E4",
    "contractAddress": "0x564F52dE1185D705d61fDC0A1F9095BbbF1F7655",
    "transactionIndex": 66,
    "gasUsed": "4191533",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000008000000000000000002000000000004000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000020010000000000000000000000000000000000000000000000000000000001000000",
    "blockHash": "0xc3b603ffc0dbb4f17508dc11659a01b644aed81a9419b08e3c2546ddc3635100",
    "transactionHash": "0xeba1cdfb0fc79a05d07ce9b3cd07ee7986edd5bd05cd384b12fe14aca0b744bb",
    "logs": [
      {
        "transactionIndex": 66,
        "blockNumber": 7688390,
        "transactionHash": "0xeba1cdfb0fc79a05d07ce9b3cd07ee7986edd5bd05cd384b12fe14aca0b744bb",
        "address": "0x564F52dE1185D705d61fDC0A1F9095BbbF1F7655",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000037ac010c1c566696326813b840319b58bb5840e4"
        ],
        "data": "0x",
        "logIndex": 80,
        "blockHash": "0xc3b603ffc0dbb4f17508dc11659a01b644aed81a9419b08e3c2546ddc3635100"
      }
    ],
    "blockNumber": 7688390,
    "cumulativeGasUsed": "10144419",
    "status": 1,
    "byzantium": true
  },
  "args": [
    {
      "enginePriceIdFactory": "0x1E3Da707285e756a332C0325C470BEdD0f569879",
      "enginePriceQuantityIdFactory": "0x69E4ba3B754e60e13AA8326dD611F65535Cd44B0",
      "enginePriceRandomFactory": "0x1032300C568A0776e8d31Ff12005309d58704Ec6",
      "engineProRataFactory": "0xc57db6C16f6FAB6933177a4d0f2C69A0D3f632ED"
    }
  ],
  "numDeployments": 2,
  "solcInputHash": "b4131e9528337a45f242293135657fca",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract FHEAuctionEngineFactory\",\"name\":\"enginePriceIdFactory\",\"type\":\"address\"},{\"internalType\":\"contract FHEAuctionEngineFactory\",\"name\":\"enginePriceQuantityIdFactory\",\"type\":\"address\"},{\"internalType\":\"contract FHEAuctionEngineFactory\",\"name\":\"enginePriceRandomFactory\",\"type\":\"address\"},{\"internalType\":\"contract FHEAuctionEngineFactory\",\"name\":\"engineProRataFactory\",\"type\":\"address\"}],\"internalType\":\"struct FHEAuctionFactory.FHEAuctionFactoryDetails\",\"name\":\"details_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Create2EmptyBytecode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDeployment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"auction_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionToken_\",\"type\":\"address\"}],\"name\":\"FHEAuctionNativeDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumPaymentDeposit_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentPenalty_\",\"type\":\"uint256\"}],\"name\":\"computeAuctionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auctionOwner_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionQuantity_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"auctionToken_\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxBidCount_\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"tieBreakingRule_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"minimumPaymentDeposit_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentPenalty_\",\"type\":\"uint256\"}],\"name\":\"createNewAuction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionToken_\",\"type\":\"address\"}],\"name\":\"getAuction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNative\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"Create2EmptyBytecode()\":[{\"details\":\"There's no code to deploy.\"}],\"FailedDeployment()\":[{\"details\":\"The deployment failed.\"}],\"InsufficientBalance(uint256,uint256)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/auctions/factories/FHEAuctionNativeFactory.sol\":\"FHEAuctionNativeFactory\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     *\\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n            // if no address was created, and returndata is not empty, bubble revert\\n            if and(iszero(addr), not(iszero(returndatasize()))) {\\n                let p := mload(0x40)\\n                returndatacopy(p, 0, returndatasize())\\n                revert(p, returndatasize())\\n            }\\n        }\\n        if (addr == address(0)) {\\n            revert Errors.FailedDeployment();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb7e8401583d26268ea9103013bcdcd90866a7718bd91105ebd21c9bf11f4f06\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3\",\"license\":\"MIT\"},\"contracts/FourStepsIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IFourStepsIterable {\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n}\\n\\n/*\\n * Return code, iterations were completed but the computation step is not finished\\n */\\nuint8 constant S_NOT_FINISHED = 0;\\n\\n/*\\n * Return code, iterations were completed and the computation step is finished \\n */\\nuint8 constant S_FINISHED = 1;\\n\\n/*\\n * Return code, iterations could not be completed due to insufficient gas.\\n */\\nuint8 constant E_NOT_ENOUGH_GAS = 2;\\n\\nabstract contract FourStepsIterator is Ownable {\\n    struct Step {\\n        uint32 size;\\n        uint8 nativeGasWeight;\\n        uint32 unitFheGasCost;\\n    }\\n\\n    uint64[] _cumulatives;\\n    Step[] _steps; // len = (4+1)\\n    uint8 _step; // 0 <= _step <= 4\\n    uint32 _stepProgress;\\n    uint64 _iterProgress;\\n\\n    error NullWeight();\\n    error UnauthorizedIterable();\\n    //18,992           | 21,952\\n\\n    constructor(address initialOwner) Ownable(initialOwner) {\\n        // _steps[4] should exist\\n        for (uint8 i = 0; i < 5; ++i) {\\n            _steps.push(Step({size: 0, nativeGasWeight: 0, unitFheGasCost: 0}));\\n            _cumulatives.push(0);\\n        }\\n    }\\n\\n    function _initializeFourSteps(Step[] memory fourSteps) internal {\\n        //Debug\\n        require(fourSteps.length <= 4);\\n\\n        uint64 max = 0;\\n        uint8 i;\\n        for (i = 0; i < fourSteps.length; ++i) {\\n            if (fourSteps[i].size > 0 && fourSteps[i].nativeGasWeight == 0) {\\n                revert NullWeight();\\n            }\\n            max += fourSteps[i].size * fourSteps[i].nativeGasWeight;\\n            Step storage s = _steps[i];\\n            s.size = fourSteps[i].size;\\n            s.nativeGasWeight = fourSteps[i].nativeGasWeight;\\n            s.unitFheGasCost = fourSteps[i].unitFheGasCost;\\n            _cumulatives[i] = max;\\n        }\\n\\n        while (i < 4) {\\n            _cumulatives[i] = max;\\n            i++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete step `s`\\n     */\\n    function _minIterProgressForStep(uint8 s) internal view returns (uint64) {\\n        return _cumulatives[s];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete the four steps\\n     */\\n    function iterProgressMax() public view returns (uint64) {\\n        return _cumulatives[3];\\n    }\\n\\n    /**\\n     * @dev Returns the number of completed iterations (`iterProgress()` <= `iterProgressMax()`).\\n     */\\n    function iterProgress() public view returns (uint64) {\\n        return _iterProgress;\\n    }\\n\\n    function getStepProgress(uint8 s) public view returns (uint32) {\\n        uint8 cur = _step;\\n        if (cur == s) {\\n            return _stepProgress;\\n        } else if (cur > s) {\\n            return _steps[s].size;\\n        }\\n        return 0;\\n    }\\n\\n    function getStepProgressMax(uint8 s) public view returns (uint32) {\\n        return _steps[s].size;\\n    }\\n\\n    function getStepIterProgressMax(uint8 s) public view returns (uint64) {\\n        return _steps[s].size * _steps[s].nativeGasWeight;\\n    }\\n\\n    function step() public view returns (uint8) {\\n        return _step;\\n    }\\n\\n    function stepProgress() public view returns (uint32) {\\n        return _stepProgress;\\n    }\\n\\n    function finished() public view returns (bool) {\\n        return _step == 4;\\n    }\\n\\n    /**\\n     * @dev Executes up to `iter` computation iterations, stopping early if step `maxStepCompleted` is fully processed.\\n     *\\n     * @param iter The maximum number of computation iterations to execute.\\n     * @param stopAfterStep The computation step at which execution should stop if it has been fully completed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of iterations completed before this function call.\\n     * @return endIterProgress The total number of iterations completed after this function call.\\n     *         The difference `(endIterProgress - startIterProgress)` represents the number of iterations executed in this call.\\n     */\\n    function _next(uint64 iter, uint8 stopAfterStep)\\n        internal\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        //uint8 s0 = _step;\\n        //uint8 s = s0;\\n        uint8 s = _step;\\n\\n        startIterProgress = _iterProgress;\\n        endIterProgress = startIterProgress;\\n\\n        code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n\\n        if (s > stopAfterStep) {\\n            return (code, startIterProgress, endIterProgress);\\n        }\\n\\n        //uint32 p0 = _stepProgress;\\n        //uint32 p = p0;\\n        uint32 fheGasLeft = 10_000_000;\\n        uint32 p = _stepProgress;\\n        uint64 actualIter = 0;\\n        IFourStepsIterable iterable = IFourStepsIterable(owner());\\n\\n        while (s < 4 && s <= stopAfterStep && fheGasLeft > 0) {\\n            Step memory theStep = _steps[s];\\n\\n            uint32 r = theStep.size - p;\\n\\n            // skip empty steps first.\\n            if (r == 0) {\\n                p = 0;\\n                s += 1;\\n                continue;\\n            }\\n\\n            // after having skipped empty steps\\n            if (iter == 0) {\\n                break;\\n            }\\n\\n            uint32 w = uint32(theStep.nativeGasWeight);\\n            uint32 i;\\n            if (iter < w) {\\n                // align\\n                i = 1;\\n                iter = w;\\n            } else {\\n                if (iter >= r * w) {\\n                    i = r;\\n                } else {\\n                    i = uint32(iter / w);\\n                }\\n            }\\n\\n            if (i * theStep.unitFheGasCost > fheGasLeft) {\\n                i = uint32(fheGasLeft / theStep.unitFheGasCost);\\n\\n                if (i == 0) {\\n                    fheGasLeft = 0;\\n                    break;\\n                }\\n            }\\n\\n            fheGasLeft -= uint32(i * theStep.unitFheGasCost);\\n\\n            uint32 j;\\n\\n            if (s == 0) {\\n                (code, j) = iterable.runStep1(p, i, theStep.size);\\n            } else if (s == 1) {\\n                (code, j) = iterable.runStep2(p, i, theStep.size);\\n            } else if (s == 2) {\\n                (code, j) = iterable.runStep3(p, i, theStep.size);\\n            } else if (s == 3) {\\n                (code, j) = iterable.runStep4(p, i, theStep.size);\\n            }\\n\\n            actualIter += j * w;\\n            iter -= j * w;\\n            p += j;\\n\\n            if (code == S_FINISHED) {\\n                //Debug\\n                require(p == theStep.size, \\\"Panic: p != theStep.size\\\");\\n                p = 0;\\n                s += 1;\\n            } else {\\n                //Debug\\n                require(p < theStep.size, \\\"Panic: p >= theStep.size\\\");\\n                if (code != S_NOT_FINISHED) {\\n                    //Debug\\n                    require(code == E_NOT_ENOUGH_GAS, \\\"Panic: code != E_NOT_ENOUGH_GAS\\\");\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (iter > 0 && fheGasLeft == 0) {\\n            code = E_NOT_ENOUGH_GAS;\\n        }\\n\\n        if (actualIter > 0) {\\n            endIterProgress = startIterProgress + actualIter;\\n            _iterProgress = endIterProgress;\\n        }\\n\\n        _stepProgress = p;\\n        _step = s;\\n\\n        if (code != E_NOT_ENOUGH_GAS) {\\n            code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe546249b210236275a9940c5b040d58a5c1fd4e0c3a469d6d90c562d0f22e8bf\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/ITimedAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\ninterface ITimedAuction {\\n    function closed() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x172cc08b56e50a2c61499a088a105445b62de1350bf8ad10ada3c542b0e4e5f1\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/TimedAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {ITimedAuction} from \\\"./ITimedAuction.sol\\\";\\n\\nabstract contract TimedAuction is ITimedAuction {\\n    uint256 private _startTime;\\n    uint256 private _endTime;\\n    uint256 private _flags;\\n    bool private _stoppable;\\n\\n    /*\\n     * State Graph:\\n     * ------------\\n     *         UNINITIALIZED               ->  INITIALIZED\\n     *         INITIALIZED                 ->  INITIALIZED_TERMINATED\\n     *                                         INITIALIZED_STARTED\\n     *         INITIALIZED_STARTED         ->  INITIALIZED_STARTED_ENDED\\n     *                                         INITIALIZED_STARTED_ENDED_TERMINATED\\n     *         INITIALIZED_STARTED_ENDED   ->  INITIALIZED_STARTED_ENDED_TERMINATED\\n     */\\n\\n    uint256 private constant UNINITIALIZED = uint256(0x0);\\n    uint256 private constant INITIALIZED = uint256(0x1);\\n    uint256 private constant INITIALIZED_TERMINATED = uint256(0x9);\\n    uint256 private constant INITIALIZED_STARTED = uint256(0x3);\\n    uint256 private constant INITIALIZED_STARTED_ENDED = uint256(0x7);\\n    uint256 private constant INITIALIZED_STARTED_ENDED_TERMINATED = uint256(0xF);\\n\\n    uint256 private constant FLAGS_INITIALIZED = uint256(0x1);\\n    uint256 private constant FLAGS_STARTED = uint256(0x2);\\n    uint256 private constant FLAGS_ENDED = uint256(0x4);\\n    uint256 private constant FLAGS_TERMINATED = uint256(0x8);\\n\\n    error NotInitialized();\\n    error NotInitializable();\\n    error NotStartable();\\n    error NotStoppable();\\n    error NotTerminable();\\n    error NotStarted();\\n    error NotOpen();\\n    error NotClosed();\\n    error InvalidDuration();\\n\\n    constructor() {}\\n\\n    function durationInSeconds() public view returns (uint256) {\\n        return _endTime - _startTime;\\n    }\\n\\n    function startTime() public view returns (uint256) {\\n        return _startTime;\\n    }\\n\\n    function endTime() public view returns (uint256) {\\n        return _endTime;\\n    }\\n\\n    function _state() internal view returns (uint256) {\\n        uint256 f = _flags;\\n        if (f == INITIALIZED_STARTED) {\\n            if (block.timestamp >= _endTime) {\\n                return f | FLAGS_ENDED;\\n            }\\n        }\\n        return f;\\n    }\\n\\n    function _initialize() internal whenInitializable {\\n        _flags = INITIALIZED;\\n    }\\n\\n    function _start(uint256 durationInSeconds_, bool stoppable_) internal whenStartable {\\n        if (durationInSeconds_ == 0) {\\n            revert InvalidDuration();\\n        }\\n\\n        _flags = INITIALIZED_STARTED;\\n\\n        _startTime = block.timestamp;\\n        _endTime = _startTime + durationInSeconds_;\\n        _stoppable = stoppable_;\\n    }\\n\\n    function _stop() internal whenStoppable {\\n        _flags = INITIALIZED_STARTED_ENDED;\\n    }\\n\\n    function _terminate() internal whenTerminable {\\n        if (_flags == INITIALIZED) {\\n            _flags = INITIALIZED_TERMINATED;\\n        } else {\\n            _flags = INITIALIZED_STARTED_ENDED_TERMINATED;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction can be manually stopped.\\n     */\\n    function stoppable() public view returns (bool) {\\n        return _stoppable;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is ready to start, `false` otherwise.\\n     */\\n    function canStart() public view returns (bool) {\\n        return _flags == INITIALIZED;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction can be stopped by calling the {stop} function, `false` otherwise.\\n     */\\n    function canStop() public view returns (bool) {\\n        return (_flags == INITIALIZED_STARTED) && _stoppable;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction can be terminated by calling the {terminate} function, `false` otherwise.\\n     */\\n    function canTerminate() public view returns (bool) {\\n        uint256 f = _flags;\\n        if (f == UNINITIALIZED || f == INITIALIZED_TERMINATED || f == INITIALIZED_STARTED_ENDED_TERMINATED) {\\n            return false;\\n        }\\n\\n        // state == INITIALIZED or INITIALIZED_STARTED or INITIALIZED_STARTED_ENDED\\n        uint256 state = _state();\\n        if (state == INITIALIZED_STARTED || state == INITIALIZED_STARTED_ENDED) {\\n            if (!_canTerminateAfterStart()) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function _canTerminateAfterStart() internal view virtual returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction has been initialized, `false` otherwise.\\n     */\\n    function initialized() public view returns (bool) {\\n        return _flags != UNINITIALIZED;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is initialized and ready to accept bids, `false` otherwise.\\n     */\\n    function isOpen() public view returns (bool) {\\n        return _state() == INITIALIZED_STARTED;\\n    }\\n\\n    /**\\n     * @notice Returns the auction status code. Can be one of the following values.\\n     *      - UNINITIALIZED = uint256(0x0)\\n     *      - INITIALIZED = uint256(0x1)\\n     *      - INITIALIZED_TERMINATED = uint256(0x9)\\n     *      - INITIALIZED_STARTED = uint256(0x3)\\n     *      - INITIALIZED_STARTED_ENDED = uint256(0x7)\\n     *      - INITIALIZED_STARTED_ENDED_TERMINATED = uint256(0xF)\\n     */\\n    function statusCode() public view returns (uint256) {\\n        return _state();\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is ready to compute the auction prizes, `false` otherwise.\\n     * When the auction is closed, it can no more accept bids.\\n     */\\n    function closed() public view returns (bool) {\\n        return _state() == INITIALIZED_STARTED_ENDED;\\n    }\\n\\n    function terminated() public view returns (bool) {\\n        return _flags & FLAGS_TERMINATED != 0;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction cannot be initialized.\\n     */\\n    modifier whenInitializable() {\\n        if (_flags != UNINITIALIZED) {\\n            revert NotInitializable();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction is not initialized.\\n     */\\n    modifier whenInitialized() {\\n        if (!initialized()) {\\n            revert NotInitialized();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction cannot be started.\\n     */\\n    modifier whenStartable() {\\n        if (!canStart()) {\\n            revert NotStartable();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction cannot be stopped.\\n     */\\n    modifier whenStoppable() {\\n        if (!canStop()) {\\n            revert NotStoppable();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction cannot be terminated.\\n     */\\n    modifier whenTerminable() {\\n        if (!canTerminate()) {\\n            revert NotTerminable();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction is not started.\\n     */\\n    modifier whenStarted() {\\n        if ((_state() & FLAGS_STARTED) != 0) {\\n            revert NotStarted();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction is not open and accepting new bids.\\n     */\\n    modifier whenIsOpen() {\\n        _requireIsOpen();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction is not closed (in prize computing state).\\n     */\\n    modifier whenClosed() {\\n        if (!closed()) {\\n            revert NotClosed();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the auction is not open and accepting new bids.\\n     */\\n    function _requireIsOpen() internal view virtual {\\n        if (_state() != INITIALIZED_STARTED) {\\n            revert NotOpen();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa9cc792567d988ea8f942cc24714dc654e9c5fd1f11a18848961130bb530fce8\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/FHEAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"fhevm/gateway/GatewayCaller.sol\\\";\\nimport {FHEAuctionBase} from \\\"./FHEAuctionBase.sol\\\";\\nimport {IFHEAuction} from \\\"./IFHEAuction.sol\\\";\\n\\n/**\\n * @dev Base abstract contract for implementing a Single Price Auction using a non-encrypted payment token.\\n *\\n * This contract serves as the foundation for a Single Price Auction mechanism where bidders place bids\\n * using non-encrypted payment tokens (e.g., Ether or ERC20 tokens).\\n *\\n * Derived contracts can further customize the logic for specific payment token operations.\\n */\\nabstract contract FHEAuction is FHEAuctionBase, IFHEAuction {\\n    mapping(address account => uint256) private _balances;\\n    mapping(uint256 requestID => address bidder) private _requestIDToBidder;\\n    mapping(uint256 requestID => uint16 rank) private _requestIDToRank;\\n\\n    /**\\n     * @notice Returns the value of payment tokens deposited by `bidder`\\n     */\\n    function balanceOf(address bidder) public view returns (uint256) {\\n        return _balances[bidder];\\n    }\\n\\n    /**\\n     * @dev See {FHEAuctionBase-_canAward}.\\n     * @dev Additionnal conditions:\\n     * - The final uniform price must have been decrypted.\\n     */\\n    function _canAward() internal view virtual override returns (bool) {\\n        return (clearUniformPrice() > 0);\\n    }\\n\\n    /**\\n     * @dev See {FHEAuctionBase-_awardWinningBidForBidder}.\\n     */\\n    function _awardWinningBidForBidder(address bidder, uint16, /*id*/ euint256 validatedPrice, euint256 wonQuantity)\\n        internal\\n        virtual\\n        override\\n    {\\n        uint256[] memory cts = new uint256[](2);\\n        cts[0] = Gateway.toUint256(validatedPrice);\\n        cts[1] = Gateway.toUint256(wonQuantity);\\n        uint256 requestID =\\n            Gateway.requestDecryption(cts, this.callbackDecryptWonQuantity.selector, 0, block.timestamp + 100, false);\\n\\n        _requestIDToBidder[requestID] = bidder;\\n    }\\n\\n    /**\\n     * @dev see {_callbackDecrypt}\\n     * @dev This function can only be called by the fhEVM Gateway.\\n     */\\n    function callbackDecryptWonQuantity(uint256 requestID, uint256 clearValidatedPrice, uint256 clearWonQuantity)\\n        external\\n        onlyGateway\\n    {\\n        _callbackDecrypt(_requestIDToBidder[requestID], clearValidatedPrice, clearWonQuantity);\\n    }\\n\\n    /**\\n     * @dev See {FHEAuctionBase-_awardWinningBidAtRank}.\\n     */\\n    function _awardWinningBidAtRank(uint16 rank, euint16 id, euint256 validatedPrice, euint256 wonQuantity)\\n        internal\\n        virtual\\n        override\\n    {\\n        uint256[] memory cts = new uint256[](3);\\n        cts[0] = Gateway.toUint256(id);\\n        cts[1] = Gateway.toUint256(validatedPrice);\\n        cts[2] = Gateway.toUint256(wonQuantity);\\n        uint256 requestID = Gateway.requestDecryption(\\n            cts, this.callbackDecryptRankedWonQuantity.selector, 0, block.timestamp + 100, false\\n        );\\n\\n        _requestIDToRank[requestID] = rank;\\n    }\\n\\n    /**\\n     * @dev see {_callbackDecrypt}\\n     * @dev This function can only be called by the fhEVM Gateway.\\n     */\\n    function callbackDecryptRankedWonQuantity(\\n        uint256 requestID,\\n        uint16 clearId,\\n        uint256 clearValidatedPrice,\\n        uint256 clearWonQuantity\\n    ) external onlyGateway {\\n        // reverts if already completed\\n        _markPrizeAtRankAwarded(_requestIDToRank[requestID]);\\n\\n        _callbackDecrypt(_getBidderById(clearId), clearValidatedPrice, clearWonQuantity);\\n    }\\n\\n    /**\\n     * @dev Callback function to process the results of a requested claim.\\n     * It handles the transfer of payments as follows:\\n     * - Transfers the payment (including any penalty fees for invalid bids) to the auction beneficiary.\\n     * - Transfers any remaining payment token balance to the bidder.\\n     *\\n     * @param bidder The bidder address.\\n     * @param clearValidatedPrice The decrypted validated price of the auction provided by the Gateway. If this value is\\n     * zero, the bid is considered invalid and subject to a penalty fee.\\n     * @param clearWonQuantity The decrypted final quantity won by the bidder in the auction, provided by the Gateway.\\n     */\\n    function _callbackDecrypt(address bidder, uint256 clearValidatedPrice, uint256 clearWonQuantity) internal {\\n        // Debug\\n        require(bidder != address(0), \\\"Panic: bidder == 0\\\");\\n\\n        // reverts if already completed\\n        _markClaimCompleted(bidder);\\n\\n        uint256 uniformPrice = clearUniformPrice();\\n\\n        // Debug\\n        require(uniformPrice > 0, \\\"Panic: uniformPrice == 0\\\");\\n\\n        if (clearValidatedPrice == 0) {\\n            // Debug\\n            require(clearWonQuantity == 0, \\\"Panic: clearValidatedPrice == 0 && clearWonQuantity != 0\\\");\\n        }\\n\\n        if (clearWonQuantity > 0) {\\n            uint256 bidderDueAmount = uniformPrice * clearWonQuantity;\\n\\n            // Debug\\n            require(bidderDueAmount > 0, \\\"Panic: bidderDueAmount == 0\\\");\\n\\n            // Debug\\n            require(_balances[bidder] >= bidderDueAmount, \\\"Panic: _balances[bidder] < bidderDueAmount\\\");\\n\\n            // Pay beneficiary\\n            _withdrawPaymentTo(bidder, beneficiary(), bidderDueAmount);\\n        } else {\\n            // if the bid was invalid, transfer a penalty fee.\\n            if (clearValidatedPrice == 0) {\\n                uint256 penalty = paymentPenalty();\\n                if (penalty > 0) {\\n                    // Pay penalty to beneficiary\\n                    _withdrawPaymentTo(bidder, beneficiary(), penalty);\\n                }\\n            }\\n        }\\n\\n        uint256 remaining = _balances[bidder];\\n        if (remaining > 0) {\\n            // Give back remaining balance to bidder (minus penalty)\\n            _withdrawPayment(bidder, remaining);\\n        }\\n\\n        // Debug\\n        require(_balances[bidder] == 0, \\\"Panic: _balances[bidder] > 0\\\");\\n\\n        if (clearWonQuantity > 0) {\\n            // Transfer auction tokens to winner\\n            _transferAuctionTokenTo(bidder, clearWonQuantity);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {FHEAuctionBase-_cancelBid}.\\n     */\\n    function _cancelBid(address bidder) internal virtual override {\\n        _withdrawPayment(bidder, _balances[bidder]);\\n    }\\n\\n    /**\\n     * @dev See {FHEAuctionBase-_checkBidderPaymentDeposit}.\\n     */\\n    function _checkBidderPaymentDeposit(address bidder) internal view virtual override {\\n        _requireSufficientPaymentDeposit(_balances[bidder]);\\n    }\\n\\n    /**\\n     * @notice Allows the caller to withdraw `amount` of payment tokens previously deposited into the auction contract\\n     * as collateral for placing bids. If the withdrawal causes the caller's bid value (`price * quantity`) to fall\\n     * below the required balance at the end of the auction, a penalty fee will be applied\\n     * (see {FHEAuctionBase-paymentPenalty}).\\n     *\\n     * @dev Requirements:\\n     * - If the caller has already placed a bid, the auction must be open and currently accepting bids.\\n     * - If the caller has not placed any bid, the auction must have started.\\n     * - The function reverts if the withdrawal causes the caller's remaining deposit balance to fall below the minimum\\n     *   deposit required by the auction.\\n     *\\n     * @param amount The amount of payment tokens to withdraw.\\n     */\\n    function withdraw(uint256 amount) public nonReentrant whenStarted {\\n        address bidder = msg.sender;\\n        bool registered = _registered(bidder);\\n\\n        uint256 balance = _balances[bidder];\\n        uint256 maxWithdrawAmount = balance;\\n        uint256 minDeposit = minimumDeposit();\\n\\n        if (registered) {\\n            _requireIsOpen();\\n\\n            if (balance < minDeposit) {\\n                // Debug\\n                require(balance == 0, \\\"Panic: balance > 0 && balance < minDeposit\\\");\\n                return;\\n            }\\n\\n            maxWithdrawAmount -= minDeposit;\\n        }\\n\\n        if (amount > maxWithdrawAmount) {\\n            amount = maxWithdrawAmount;\\n        }\\n\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        _withdrawPayment(bidder, amount);\\n\\n        // Debug\\n        if (registered) {\\n            require(_balances[bidder] >= minDeposit, \\\"Panic: _balances[bidder] < minDeposit\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` of payment tokens from the bidder's deposit in the auction contract to the bidder's\\n     * own address.\\n     *\\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\\n     * @param amount The amount of payment tokens to withdraw and transfer back to the bidder.\\n     */\\n    function _withdrawPayment(address bidder, uint256 amount) internal {\\n        _withdrawPaymentTo(bidder, bidder, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function without access restriction. Transfers `amount` of payment tokens from the bidder's\\n     * deposit in the auction contract to the specified address `to`.\\n     *\\n     * @dev This function updates the bidder's deposit balance before performing the transfer and handles the token\\n     * transfer to the specified recipient.\\n     *\\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\\n     * @param to The address to which the payment tokens will be sent.\\n     * @param amount The amount of payment tokens to withdraw and transfer.\\n     */\\n    function _withdrawPaymentTo(address bidder, address to, uint256 amount) internal {\\n        _updatePaymentTokenBeforeWithdraw(bidder, amount);\\n        _transferPaymentTokenTo(to, amount);\\n    }\\n\\n    /**\\n     * @notice Updates the bidder's balance before a withdraw operation.\\n     * This is an internal function with no access restrictions.\\n     *\\n     * @param bidder The address of the bidder whose deposit will be withdrawn.\\n     * @param amount The amount of payment tokens to withdraw and transfer.\\n     */\\n    function _updatePaymentTokenBeforeWithdraw(address bidder, uint256 amount) internal {\\n        _balances[bidder] -= amount;\\n    }\\n\\n    /**\\n     * @notice Updates the bidder's balance after a deposit operation.\\n     * This is an internal function with no access restrictions.\\n     *\\n     * @param bidder The address of the bidder whose balance is being updated.\\n     * @param amount The amount of payment tokens deposited.\\n     */\\n    function _updatePaymentTokenAfterDeposit(address bidder, uint256 amount) internal {\\n        _balances[bidder] += amount;\\n    }\\n\\n    /**\\n     * @dev Abstract function to be implemented by derived contracts.\\n     * It allows for the inclusion of custom logic for transferring payment tokens to a specified address.\\n     * Derived contracts should provide the specific implementation for how the transfer should be handled\\n     * (e.g., native Eth or ERC20 token transfer).\\n     *\\n     * @param to The address receiving the transferred payment tokens.\\n     * @param amount The amount of payment tokens to be transferred.\\n     */\\n    function _transferPaymentTokenTo(address to, uint256 amount) internal virtual;\\n\\n    /**\\n     * @dev Abstract function to be implemented by derived contracts.\\n     * This function should return the balance of payment tokens owned by a specified address (`account`).\\n     * @param account The address for which the payment token balance is being queried.\\n     * @return The balance of payment tokens owned by the `account`.\\n     */\\n    function _paymentTokenBalanceOf(address account) internal view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0xd45d230bd589392d57867d41f8ea3064618c79a92db40977f09deb6ef173c3b1\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/FHEAuctionBase.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE, euint16, euint256, einput} from \\\"fhevm/lib/TFHE.sol\\\";\\nimport {SepoliaZamaFHEVMConfig} from \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\nimport {SepoliaZamaGatewayConfig} from \\\"fhevm/config/ZamaGatewayConfig.sol\\\";\\nimport {Gateway, GatewayCaller} from \\\"fhevm/gateway/GatewayCaller.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {TimedAuction} from \\\"../TimedAuction.sol\\\";\\nimport {IFHEAuctionEngine} from \\\"../engines/IFHEAuctionEngine.sol\\\";\\nimport {FHEAuctionEngineIterator} from \\\"../engines/FHEAuctionEngineIterator.sol\\\";\\n\\n/**\\n * @dev Abstract contract for implementing a Single Price Auction.\\n * This implementation is payment-agnostic, supporting various types of payments such as Ether, ERC20 tokens,\\n * or encrypted ERC20 tokens. As a result, a payment or deposit locking mechanism must be implemented in a derived\\n * contract.\\n *\\n * Provides fundamental auction functionality, including:\\n * - Initialization\\n * - Auction timing (open/close states)\\n * - Bid placement and canceling\\n * - Prize claiming by bidders\\n * - Auction termination\\n *\\n * The contract interacts with a separate `TFHEAuctionEngine` contract, which is responsible for:\\n * - Validating bids\\n * - Ranking bids\\n * - Computing the final prize for each bidder\\n */\\nabstract contract FHEAuctionBase is\\n    SepoliaZamaFHEVMConfig,\\n    SepoliaZamaGatewayConfig,\\n    TimedAuction,\\n    Ownable,\\n    ReentrancyGuard,\\n    GatewayCaller\\n{\\n    uint8 constant YES = 1;\\n\\n    struct Bid {\\n        euint256 price;\\n        euint256 quantity;\\n    }\\n\\n    uint256 private immutable _paymentPenalty;\\n    uint256 private immutable _minimumPaymentDeposit;\\n\\n    address private _engine;\\n    ///@dev _iterator == _engine.iterator().\\n    ///@dev We keep a copy in order to minimize contract loading when calling progress-related view functions.\\n    address private _iterator;\\n    address private _beneficiary;\\n    IERC20 private _auctionToken;\\n    uint256 private _clearUniformPrice;\\n\\n    uint16 private _claimCompletedCount;\\n    uint16 private _prizeAtRankAwardedCount;\\n\\n    mapping(address bidder => uint8) private _claimCompleted;\\n    mapping(uint16 rank => uint8) private _prizeAtRankAwarded;\\n    mapping(address bidder => Bid) private _bidderToBid;\\n\\n    error BidderNotRegistered(address bidder);\\n    error DepositFailed(address token, address from, uint256 amount);\\n    error WithdrawFailed();\\n    error InvalidEngine(address engine);\\n    error InvalidBeneficiary(address beneficiary);\\n    error InvalidAuctionToken(address token);\\n    error InvalidAuctionQuantity(uint256 quantity);\\n    error InvalidTieBreakingRule(uint8 tieBreakingRule);\\n    error AlreadyClaimed(address bidder);\\n    error NotReadyForBidderClaim(address bidder);\\n    error PrizeAlreadyAwardedAtRank(uint16 rank);\\n    error NotReadyForPrizeAwarding();\\n    error UniformPriceNotReadyToDecrypt();\\n\\n    /**\\n     * @notice Thrown when the account's payment token balance is insufficient to perform the operation.\\n     *\\n     * @param balance The current payment token balance of the account.\\n     * @param needed The required payment token balance to complete the operation.\\n     */\\n    error InsufficientPaymentDeposit(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @notice Thrown when the payment penalty exceeds the requested minimum payment token balance.\\n     *\\n     * @param minimumBalance The required minimum payment token balance.\\n     * @param penalty The payment penalty that triggered the error.\\n     */\\n    error PaymentPenaltyTooHigh(uint256 minimumBalance, uint256 penalty);\\n\\n    /**\\n     * @notice Emitted when a batch of auction computation cycles has been processed.\\n     *\\n     * @param requestedIter The number of computation cycles requested.\\n     * @param statusCode A status code indicating the result of the computation.\\n     * @param startIterProgress The total number of computation cycles completed before this function call.\\n     * @param endIterProgress The total number of computation cycles completed after this function call.\\n     */\\n    event ComputeAuctionCycles(\\n        uint64 requestedIter, uint8 statusCode, uint64 startIterProgress, uint64 endIterProgress\\n    );\\n\\n    /**\\n     * @notice Reverts if `paymentPenalty_` exceeds `minimumPaymentDeposit_`.\\n     * Ensures the auction retains sufficient payment tokens to cover any penalty fees.\\n     *\\n     * @param minimumPaymentDeposit_ The minimum amount of payment tokens a bidder must deposit before placing any bid.\\n     * @param paymentPenalty_ The amount of payment tokens transferred to the auction's {beneficiary} for each invalid bid.\\n     */\\n    constructor(uint256 minimumPaymentDeposit_, uint256 paymentPenalty_) Ownable(msg.sender) {\\n        if (paymentPenalty_ > minimumPaymentDeposit_) {\\n            revert PaymentPenaltyTooHigh(minimumPaymentDeposit_, paymentPenalty_);\\n        }\\n        _minimumPaymentDeposit = minimumPaymentDeposit_;\\n        _paymentPenalty = paymentPenalty_;\\n    }\\n\\n    /**\\n     * @notice Initializes the auction with a specified auction engine and parameters.\\n     *\\n     * @notice Requirements:\\n     * - The auction must not already be initialized (see `_initialize`).\\n     * - The caller must be the contract owner.\\n     * - The `engine_`'s owner must be the current contract.\\n     * - The `beneficiary_` must not be the zero address.\\n     * - The `auctionToken_` must not be the zero address.\\n     * - The `auctionQuantity_` must be strictly positive.\\n     *\\n     * @param engine_ Address of the auction engine used to compute auction prizes.\\n     * @param beneficiary_ Address of the auction beneficiary who will receive the proceeds.\\n     * @param auctionToken_ Address of the {IERC20} token being auctioned.\\n     * @param auctionQuantity_ Total quantity of tokens to be auctioned.\\n     * @param maxBidCount_ Maximum number of bids.\\n     */\\n    function initialize(\\n        address engine_,\\n        address beneficiary_,\\n        IERC20 auctionToken_,\\n        uint256 auctionQuantity_,\\n        uint16 maxBidCount_\\n    ) external onlyOwner nonReentrant {\\n        if (engine_ == address(0) || Ownable(engine_).owner() != address(this)) {\\n            revert InvalidEngine(engine_);\\n        }\\n        if (address(beneficiary_) == address(0)) {\\n            revert InvalidBeneficiary(beneficiary_);\\n        }\\n        if (address(auctionToken_) == address(0)) {\\n            revert InvalidAuctionToken(address(auctionToken_));\\n        }\\n        if (auctionQuantity_ == 0) {\\n            revert InvalidAuctionQuantity(auctionQuantity_);\\n        }\\n\\n        // reverts if the auction is already initialized.\\n        _initialize();\\n\\n        _engine = engine_;\\n        _beneficiary = beneficiary_;\\n        _auctionToken = auctionToken_;\\n\\n        IFHEAuctionEngine(engine_).initialize(auctionQuantity_, maxBidCount_);\\n\\n        // Keep a copy of the iterator\\n        _iterator = IFHEAuctionEngine(engine_).iterator();\\n    }\\n\\n    /**\\n     * @notice Modifier to make a function callable only when the caller is a registered bidder.\\n     *\\n     * @notice Requirements:\\n     * - The auction must have started.\\n     * - Must be used as a final modifier as it is not checking if the auction is initialized\\n     */\\n    modifier onlyBidder() {\\n        _checkBidder();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Reverts if the caller is not a registered bidder\\n     */\\n    function _checkBidder() internal view {\\n        if (!_registered(msg.sender)) {\\n            revert BidderNotRegistered(msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns true if `bidder` is a registered bidder\\n     */\\n    function _registered(address bidder) internal view returns (bool) {\\n        return IFHEAuctionEngine(_engine).bidderId(bidder) != 0;\\n    }\\n\\n    /**\\n     * @notice Starts the auction. (see `TimedAuction._start`).\\n     * At start, {auctionQuantity} tokens will be transferred from the {beneficiary} to the current auction contract as\\n     * a deposit. If the auction contract is unable to execute the transfer operation, the function will revert.\\n     *\\n     * @notice Requirements:\\n     * - The auction must be initialized.\\n     * - The auction must not have already started.\\n     * - The caller must be the auction contract owner.\\n     * - The {beneficiary} must have approved the transfer of at least {auctionQuantity} tokens to\\n     * the current auction contract.\\n     *\\n     * @param durationInSeconds The duration of the auction in seconds.\\n     * @param stoppable Indicates whether the auction can be manually stopped.\\n     */\\n    function start(uint256 durationInSeconds, bool stoppable) external onlyOwner nonReentrant {\\n        _start(durationInSeconds, stoppable);\\n        _transferAuctionTokenFrom(_beneficiary, auctionQuantity());\\n    }\\n\\n    /**\\n     * @notice Closes the auction\\n     *\\n     * @notice Requirements:\\n     * - The auction must be open (ie. accepting bids)\\n     * - The auction must be `stoppable`\\n     * - The caller must be the auction contract owner.\\n     */\\n    function stop() external onlyOwner nonReentrant {\\n        _stop();\\n        IFHEAuctionEngine(_engine).close();\\n    }\\n\\n    /**\\n     * @notice Performs a partial computation of the auction results, processing up to `iter` iterations.\\n     * This function incrementally contributes to finalizing the auction outcome and is publicly accessible\\n     * with no access restrictions.\\n     *\\n     * @dev Requirements:\\n     * - The auction must be closed before computation can proceed.\\n     *\\n     * @param iter The maximum number of computation iterations to execute in this call.\\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\\n     * @return code A status code indicating the result of the computation:\\n     *      - `0`: Additional iterations are required to complete the computation.\\n     *      - `1`: The auction computation has successfully completed.\\n     *      - `2`: Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of iterations completed before this function call.\\n     * @return endIterProgress The total number of iterations completed after this function call.\\n     *\\n     * @dev The total number of iterations executed in this call is given by:\\n     *      `endIterProgress - startIterProgress`.\\n     */\\n    function computeAuction(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        whenClosed\\n        nonReentrant\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        (code, startIterProgress, endIterProgress) =\\n            IFHEAuctionEngine(_engine).computeAuctionIterations(iter, stopIfReadyForBlindClaim);\\n        emit ComputeAuctionCycles(iter, code, startIterProgress, endIterProgress);\\n    }\\n\\n    /**\\n     * @notice Returns the auction computation iterations progress.\\n     */\\n    function computedIterations() external view returns (uint64) {\\n        return FHEAuctionEngineIterator(_iterator).iterProgress();\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to award a prize to a winning bidder.\\n     * `minIterationsForPrizeAward()` < `minIterationsForClaim()`\\n     */\\n    function minIterationsForPrizeAward() external view returns (uint64) {\\n        return FHEAuctionEngineIterator(_iterator).minIterationsForPrizeAward();\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to execute a claim.\\n     * `minIterationsForClaim()` > `minIterationsForPrizeAward()`\\n     */\\n    function minIterationsForClaim() external view returns (uint64) {\\n        return FHEAuctionEngineIterator(_iterator).iterProgressMax();\\n    }\\n\\n    /**\\n     * @notice Reverts if `amount` is less than the required minimum deposit amount of payment tokens.\\n     */\\n    function _requireSufficientPaymentDeposit(uint256 amount) internal view {\\n        if (amount < _minimumPaymentDeposit) {\\n            revert InsufficientPaymentDeposit(amount, _minimumPaymentDeposit);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the address of the auction engine used to compute auction prizes. Returns the zero address if\\n     * the auction is not yet initialized.\\n     */\\n    function engine() public view returns (address) {\\n        return _engine;\\n    }\\n\\n    /**\\n     * @notice Returns the minimum amount of payment tokens a bidder must deposit before placing any bid.\\n     */\\n    function minimumDeposit() public view returns (uint256) {\\n        return _minimumPaymentDeposit;\\n    }\\n\\n    /**\\n     * @notice Returns the penalty fee (in payment tokens) charged to a bidder for insufficient balance\\n     * to pay their auction prize at the end of the auction.\\n     */\\n    function paymentPenalty() public view returns (uint256) {\\n        return _paymentPenalty;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the {IERC20} token being auctioned.\\n     */\\n    function auctionToken() public view returns (address) {\\n        return address(_auctionToken);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the auction beneficiary, who will receive the proceeds of the auction.\\n     */\\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    /**\\n     * @notice Returns the total amount of `auctionToken` available for auction.\\n     */\\n    function auctionQuantity() public view returns (uint256) {\\n        return IFHEAuctionEngine(_engine).totalQuantity();\\n    }\\n\\n    /**\\n     * @notice Returns the maximum allowable price for each bid.\\n     */\\n    function maximumPrice() public view returns (uint256) {\\n        return IFHEAuctionEngine(_engine).maximumPrice();\\n    }\\n\\n    /**\\n     * @notice Returns the total number of bidders.\\n     */\\n    function bidCount() public view returns (uint16) {\\n        return IFHEAuctionEngine(_engine).getBidCount();\\n    }\\n\\n    /**\\n     * @notice Returns the maximum number of bidders\\n     */\\n    function maximumBidCount() public view returns (uint16) {\\n        return IFHEAuctionEngine(_engine).getMaximumBidCount();\\n    }\\n\\n    /**\\n     * @notice Returns the encrypted bid of the caller.\\n     * @return price The unit price (encrypted) that the caller has offered to pay per token being auctioned.\\n     * @return quantity The total quantity (encrypted) of tokens the caller has bidded for.\\n     */\\n    function getBid() public view returns (euint256 price, euint256 quantity) {\\n        price = _bidderToBid[msg.sender].price;\\n        quantity = _bidderToBid[msg.sender].quantity;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the caller is a registered bidder, `false` othewise.\\n     */\\n    function registered() public view returns (bool) {\\n        return _registered(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Retrieves the bidder address associated with the specified bid ID.\\n     * @param id The ID of the bid to retrieve.\\n     * @return bidder The address of the bidder.\\n     */\\n    function _getBidderById(uint16 id) internal view returns (address) {\\n        return IFHEAuctionEngine(_engine).getBidderById(id);\\n    }\\n\\n    /**\\n     * @notice Places a bid with encrypted values.\\n     * @param inPrice The encrypted unit price the caller offers to pay per token being auctioned.\\n     * @param inQuantity The encrypted total quantity of tokens the caller is bidding for.\\n     * @param inputProof The fhEVM proof for the encrypted input.\\n     *\\n     * Requirements:\\n     * - The auction must be open and accepting bids.\\n     * - The caller must not have already placed a bid.\\n     */\\n    function bid(einput inPrice, einput inQuantity, bytes calldata inputProof) external nonReentrant whenIsOpen {\\n        _bid(msg.sender, inPrice, inQuantity, inputProof);\\n    }\\n\\n    /**\\n     * @notice Internal function without access restriction.\\n     * @param bidder address of the bidder\\n     * @param inPrice The encrypted unit price the `bidder` offers to pay per token being auctioned.\\n     * @param inQuantity The encrypted total quantity of tokens the `bidder` is bidding for.\\n     * @param inputProof The fhEVM proof for the encrypted input.\\n     *\\n     * Requirements:\\n     * - The caller must not have already placed a bid.\\n     *\\n     * Gas cost: max 865_000, min 815_000\\n     */\\n    function _bid(address bidder, einput inPrice, einput inQuantity, bytes calldata inputProof) internal {\\n        _checkBidderPaymentDeposit(bidder);\\n\\n        Bid memory newBid =\\n            Bid({price: TFHE.asEuint256(inPrice, inputProof), quantity: TFHE.asEuint256(inQuantity, inputProof)});\\n\\n        address engineAddr = _engine;\\n        TFHE.allowTransient(newBid.price, engineAddr);\\n        TFHE.allowTransient(newBid.quantity, engineAddr);\\n\\n        // will revert if `bidder` has already placed a bid\\n        IFHEAuctionEngine(_engine).addBid(bidder, newBid.price, newBid.quantity);\\n\\n        TFHE.allow(newBid.price, bidder);\\n        TFHE.allow(newBid.quantity, bidder);\\n        TFHE.allowThis(newBid.price);\\n        TFHE.allowThis(newBid.quantity);\\n\\n        _bidderToBid[bidder] = newBid;\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //               \\u2b50\\ufe0f Claim functions (Pull prize awarding) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Returns `true` if the caller's auction prize is ready to be claimed, `false` otherwise.\\n     *\\n     * @notice Requirements:\\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\\n     * - The caller must be a registered bidder.\\n     * - see {_canClaim} for additional requirements.\\n     */\\n    function canClaim() public view whenClosed onlyBidder returns (bool) {\\n        return _canClaim(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the bidder can claim their auction prize, `false` otherwise.\\n     * Internal function without access restriction.\\n     * This function is meant to be overriden to add extra conditions for a successfull claim.\\n     *\\n     * @notice Conditions for a successful claim:\\n     * - All bidders' won quantities have been computed by the auction `_engine`.\\n     * - The `bidder` has not yet claimed their prize.\\n     *\\n     * @param bidder address of the bidder\\n     */\\n    function _canClaim(address bidder) internal view returns (bool) {\\n        if (claimCompleted(bidder)) {\\n            // Cannot claim twice\\n            return false;\\n        }\\n\\n        if (!IFHEAuctionEngine(_engine).canClaim()) {\\n            return false;\\n        }\\n\\n        return _canAward();\\n    }\\n\\n    /**\\n     * @notice Claim the caller's won quantity of token sold in the auction at the final uniform price\\n     *\\n     * @notice Requirements:\\n     * - The auction must be closed.\\n     * - All bidders won quantities must have been computed by the auction engine.\\n     * - The caller sould not have already successfully claimed its price.\\n     */\\n    function claim() external nonReentrant whenClosed {\\n        address bidder = msg.sender;\\n\\n        uint16 id = IFHEAuctionEngine(_engine).bidderId(bidder);\\n        if (id == 0) {\\n            revert BidderNotRegistered(bidder);\\n        }\\n\\n        if (claimCompleted(bidder)) {\\n            // the prize has already been claimed successfully\\n            revert AlreadyClaimed(bidder);\\n        }\\n\\n        if (!_canAward()) {\\n            revert NotReadyForBidderClaim(bidder);\\n        }\\n\\n        (euint256 validatedPrice, euint256 wonQuantity) =\\n            IFHEAuctionEngine(_engine).validatedPriceAndWonQuantityById(id);\\n        if (euint256.unwrap(wonQuantity) == 0) {\\n            revert NotReadyForBidderClaim(bidder);\\n        }\\n\\n        _awardWinningBidForBidder(bidder, id, validatedPrice, wonQuantity);\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the `bidder` has successfully claimed their auction prize, `false` otherwise.\\n     * @param bidder The address of the bidder whose claim status is being checked.\\n     * @return completed A boolean indicating whether the bidder's auction prize has been successfully claimed.\\n     */\\n    function claimCompleted(address bidder) public view returns (bool) {\\n        return _claimCompleted[bidder] == YES;\\n    }\\n\\n    /**\\n     * @notice Returns the number of completed claims.\\n     */\\n    function totalClaimsCompleted() public view returns (uint16) {\\n        return _claimCompletedCount;\\n    }\\n\\n    /**\\n     * @notice Marks the claim as completed for the specified bidder.\\n     *\\n     * This function updates the internal state to reflect that the bidder has successfully claimed\\n     * their auction prize. It will revert if the bidder has already claimed their prize.\\n     *\\n     * @notice Requirements:\\n     * - The bidder must not have already completed the claim.\\n     *\\n     * @param bidder The address of the bidder whose claim is being marked as completed.\\n     */\\n    function _markClaimCompleted(address bidder) internal {\\n        if (claimCompleted(bidder)) {\\n            revert AlreadyClaimed(bidder);\\n        }\\n        _claimCompleted[bidder] = YES;\\n        _claimCompletedCount++;\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //              \\u2b50\\ufe0f Award functions (Push prize awarding) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Returns `true` if the auction prize ranked at position `rank` is ready to be awarded, `false` otherwise.\\n     *\\n     * @notice Requirements:\\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\\n     * - see {_canAwardPrizeByRank} for additional requirements.\\n     *\\n     * @param rank The zero-based rank of the unidentified bidder for whom the prize is being claimed.\\n     */\\n    function canAwardPrizeAtRank(uint16 rank) public view whenClosed returns (bool) {\\n        if (isPrizeAtRankAwarded(rank)) {\\n            // Cannot award rank twice\\n            return false;\\n        }\\n\\n        return _canAwardPrizeByRank();\\n    }\\n\\n    /**\\n     * @dev Internal function, should be overriden by derived contracts to add extra requirements.\\n     */\\n    function _canAwardPrizeByRank() internal view returns (bool) {\\n        if (!IFHEAuctionEngine(_engine).canAward()) {\\n            return false;\\n        }\\n\\n        return _canAward();\\n    }\\n\\n    /**\\n     * @notice Distributes the auction prize to the bidder ranked at position `rank`.\\n     * The prize is awarded to the bidder at the final uniform price determined by the auction.\\n     * The caller acts as an intermediary and does not directly receive the prize.\\n     *\\n     * @dev Requirements:\\n     * - The auction must be closed.\\n     * - The auction engine must have computed the final uniform price.\\n     * - The auction engine must have computed the final winning quantities for all bidders.\\n     * - The specified rank must not have already received its prize.\\n     *\\n     * @param rank The zero-based rank of the bidder to whom the prize is being distributed.\\n     */\\n    function awardPrizeAtRank(uint16 rank) external nonReentrant whenClosed {\\n        if (isPrizeAtRankAwarded(rank)) {\\n            revert PrizeAlreadyAwardedAtRank(rank);\\n        }\\n\\n        _awardPrizeAtRank(rank);\\n    }\\n\\n    /**\\n     * @dev Internal function to process a claim for the bid ranked at `rank`.\\n     */\\n    function _awardPrizeAtRank(uint16 rank) internal {\\n        if (!_canAwardPrizeByRank()) {\\n            revert NotReadyForPrizeAwarding();\\n        }\\n\\n        (euint16 id, euint256 validatedPrice, euint256 wonQuantity) = IFHEAuctionEngine(_engine).getWonBidByRank(rank);\\n        if (euint256.unwrap(wonQuantity) == 0) {\\n            revert NotReadyForPrizeAwarding();\\n        }\\n\\n        _awardWinningBidAtRank(rank, id, validatedPrice, wonQuantity);\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the prize for the bidder at the specified `rank` has been successfully\\n     * awarded via the {awardPrizeAtRank} function, `false` otherwise.\\n     * This indicates whether the prize for the bidder ranked at `rank` has already been awarded.\\n     *\\n     * @param rank The zero-based rank of the bidder.\\n     * @return completed `true` if the prize has been awarded, `false` otherwise.\\n     */\\n    function isPrizeAtRankAwarded(uint16 rank) public view returns (bool) {\\n        return _prizeAtRankAwarded[rank] == YES;\\n    }\\n\\n    function _markPrizeAtRankAwarded(uint16 rank) internal {\\n        if (isPrizeAtRankAwarded(rank)) {\\n            revert PrizeAlreadyAwardedAtRank(rank);\\n        }\\n        _prizeAtRankAwarded[rank] = YES;\\n        _prizeAtRankAwardedCount++;\\n    }\\n\\n    /**\\n     * @dev See {TimedAuction-_canTerminateAfterStart}.\\n     */\\n    function _canTerminateAfterStart() internal view override returns (bool) {\\n        return _claimCompletedCount == bidCount() || _prizeAtRankAwardedCount == bidCount();\\n    }\\n\\n    /**\\n     * @notice Terminates the auction.\\n     * An auction can be terminated if it has not yet started, `bidCount` is zero, or all bids have been claimed.\\n     * When terminated, all tokens being auctioned are transferred back to the `beneficiary`.\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the auction contract owner.\\n     * - The auction must be in a terminable state (see `whenTerminable`).\\n     */\\n    function terminate() external onlyOwner nonReentrant {\\n        _terminate();\\n        _transferAuctionTokenTo(_beneficiary, _auctionToken.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @notice Internal function with no access restrictions.\\n     * Transfers `amount` of the auctioned tokens from the auction's contract account to the `to` address.\\n     *\\n     * @param to The recipient's address.\\n     * @param amount The amount of auctioned tokens to transfer to the `to` address.\\n     */\\n    function _transferAuctionTokenTo(address to, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        uint256 balanceBefore = _auctionToken.balanceOf(to);\\n        _auctionToken.transfer(to, amount);\\n        uint256 balanceAfter = _auctionToken.balanceOf(to);\\n\\n        // Debug\\n        require((balanceAfter - balanceBefore) == amount, \\\"Panic:(balanceAfter - balanceBefore) != amount\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function with no access restrictions. Handles the transfer of `amount` ERC20 auction tokens\\n     * from the `from`'s account into the auction contract.\\n     *\\n     * This function utilizes the ERC20 allowance mechanism and calls {IERC20-transferFrom} to transfer tokens\\n     * from the source address to the auction contract. It assumes that the source address has approved the auction\\n     * contract to spend the specified `amount` of tokens in advance.\\n     *\\n     * @param from The address of the source account.\\n     * @param amount The amount of ERC20 tokens to be transferred.\\n     */\\n    function _transferAuctionTokenFrom(address from, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        IERC20 aToken = _auctionToken;\\n        uint256 balanceBefore = aToken.balanceOf(address(this));\\n        bool succeeded = aToken.transferFrom(from, address(this), amount);\\n        if (!succeeded) {\\n            revert DepositFailed(address(aToken), from, amount);\\n        }\\n        uint256 balanceAfter = aToken.balanceOf(address(this));\\n\\n        if (balanceAfter - balanceBefore != amount) {\\n            revert DepositFailed(address(aToken), from, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Cancels the caller's bid.\\n     *\\n     * @notice Requirements:\\n     * - The caller must be a registered bidder.\\n     * - The auction must be open, meaning it is currently accepting bids.\\n     */\\n    function cancelBid() external nonReentrant whenIsOpen onlyBidder {\\n        _bidderToBid[msg.sender] = Bid({price: euint256.wrap(0), quantity: euint256.wrap(0)});\\n        IFHEAuctionEngine(_engine).removeBid(msg.sender);\\n\\n        _cancelBid(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Returns the decrypted final uniform auction price. The function returns `0` if\\n     * the auction is not completed and the price is not yet available. Non zero otherwise.\\n     */\\n    function clearUniformPrice() public view returns (uint256) {\\n        return _clearUniformPrice;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is ready to decrypt the final auction uniform price\\n     *\\n     * @notice Requirements:\\n     * - The auction contract must be initialized.\\n     */\\n    function canDecryptUniformPrice() public view whenInitialized returns (bool) {\\n        return IFHEAuctionEngine(_engine).canDecryptUniformPrice();\\n    }\\n\\n    /**\\n     * @notice Initiate the decryption of the auction final uniform price. The function is public since the uniform \\n     * price is publicly available via {clearUniformPrice}\\n     * @notice Requirements:\\n     * - Can only be called after the auction ends and the uniform price has been computed by the engine\\n     */\\n    function decryptUniformPrice() external nonReentrant whenInitialized {\\n        euint256 pu = IFHEAuctionEngine(_engine).getUniformPrice();\\n        if (!TFHE.isInitialized(pu)) {\\n            revert UniformPriceNotReadyToDecrypt();\\n        }\\n\\n        // Debug\\n        require(TFHE.isAllowed(pu, address(this)), \\\"Panic: TFHE.isAllowed(pu, address(this)) == false\\\");\\n\\n        uint256[] memory cts = new uint256[](1);\\n        cts[0] = Gateway.toUint256(pu);\\n        Gateway.requestDecryption(cts, this.callbackDecryptUniformPrice.selector, 0, block.timestamp + 100, false);\\n    }\\n\\n    /**\\n     * @notice Callback function to set the decrypted auction final uniform price.\\n     * @notice Can only be called by the Gateway\\n     * @param resultDecryption The decrypted auction final uniform price\\n     */\\n    function callbackDecryptUniformPrice(uint256, /*requestID*/ uint256 resultDecryption) external onlyGateway {\\n        _clearUniformPrice = resultDecryption;\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //                     \\u2b50\\ufe0f Abstract functions \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Returns `true` if the auction's payment token is the native EVM token\\n     */\\n    function isNative() public pure virtual returns (bool);\\n\\n    /**\\n     * @dev Abstract internal function. Should revert if the `bidder`'s deposit amount of payment tokens is invalid.\\n     */\\n    function _checkBidderPaymentDeposit(address bidder) internal view virtual;\\n\\n    /**\\n     * @dev Abstract internal function. Should return `true` if the auction is ready to award prizes. \\n     */\\n    function _canAward() internal view virtual returns (bool);\\n\\n    /**\\n     * @dev Abstract internal function to process a claim for the bid placed by bidder `bidder`.\\n     * Must be implemented by derived contracts to handle claims based on the bidder address, clear ID,\\n     * encrypted validated price, and encrypted won quantity.\\n     */\\n    function _awardWinningBidForBidder(address bidder, uint16 id, euint256 validatedPrice, euint256 wonQuantity) internal virtual;\\n\\n    /**\\n     * @dev Abstract internal function to process the distribution of the winning bid at a specified rank.\\n     * Derived contracts must implement this function to handle the distribution logic based on the rank, encrypted ID,\\n     * validated price, and won quantity.\\n     */\\n    function _awardWinningBidAtRank(uint16 rank, euint16 id, euint256 validatedPrice, euint256 wonQuantity) internal virtual;\\n\\n    /**\\n     * @dev Abstract internal function without access restrictions.\\n     * @dev This function is intended to be overridden in derived contracts to implement\\n     * additional operations that should occur when a bid is canceled.\\n     *\\n     * @param bidder The address of the bidder whose bid is being canceled.\\n     */\\n    function _cancelBid(address bidder) internal virtual;\\n}\\n\",\"keccak256\":\"0xe7826fa42275b7a30648407a5e10d867df0ced770019cb5d329cdaac1d19149e\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/FHEAuctionNative.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {einput} from \\\"fhevm/lib/TFHE.sol\\\";\\nimport {FHEAuction} from \\\"./FHEAuction.sol\\\";\\nimport {FHEAuctionBase} from \\\"./FHEAuctionBase.sol\\\";\\nimport {FHEAuctionBlindClaimable} from \\\"./extensions/FHEAuctionBlindClaimable.sol\\\";\\n\\ncontract FHEAuctionNative is FHEAuction, FHEAuctionBlindClaimable {\\n    /**\\n     * @dev See {FHEAuctionBase-constructor}\\n     */\\n    constructor(uint256 minimumPaymentBalance, uint256 paymentPenalty)\\n        FHEAuctionBase(minimumPaymentBalance, paymentPenalty)\\n    {}\\n\\n    /**\\n     * @dev See {FHEAuctionBase-isNative}.\\n     */\\n    function isNative() public pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Deposits a specified amount of ETH and places a bid with encrypted values in a single\\n     * transaction.\\n     *\\n     * @notice See {FHEAuctionERC20-bidWithDeposit}\\n     */\\n    function bidWithDeposit(einput inPrice, einput inQuantity, bytes calldata inputProof)\\n        external\\n        payable\\n        whenIsOpen\\n        nonReentrant\\n    {\\n        address bidder = msg.sender;\\n        uint256 newBalance = balanceOf(bidder) + msg.value;\\n        _requireSufficientPaymentDeposit(newBalance);\\n        _updatePaymentTokenAfterDeposit(bidder, msg.value);\\n\\n        _bid(bidder, inPrice, inQuantity, inputProof);\\n    }\\n\\n    /**\\n     * @notice Deposits a specified amount of ETH to the caller's account into the auction contract.\\n     * @notice Requirements:\\n     * - The auction should be open (meaning accepting new bids)\\n     */\\n    function deposit() external payable whenIsOpen nonReentrant {\\n        _updatePaymentTokenAfterDeposit(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` of ETH from the auction contract account to account `to`.\\n     * @dev See {FHEAuction-_transferPaymentTokenTo}.\\n     */\\n    function _transferPaymentTokenTo(address to, uint256 amount) internal override {\\n        // Native withdraw\\n        (bool success,) = to.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert WithdrawFailed();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the balance of ETH owned by a specified address (`account`).\\n     * @dev See {FHEAuction-_paymentTokenBalanceOf}.\\n     */\\n    function _paymentTokenBalanceOf(address account) internal view override returns (uint256) {\\n        return account.balance;\\n    }\\n}\\n\",\"keccak256\":\"0xdb9fa178bc235a7a9f6ff6e0f8d6e2d9365d6fb0e8d49a2b39076a22eb5a4569\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {IFHEAuctionBase} from \\\"./IFHEAuctionBase.sol\\\";\\n\\ninterface IFHEAuction is IFHEAuctionBase {\\n    function balanceOf(address bidder) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea97d1fa958167d13730897a14fa6df3a6d4f03a43482c9d99a13f6fb73da673\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuctionBase.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {ITimedAuction} from \\\"../ITimedAuction.sol\\\";\\n\\ninterface IFHEAuctionBase is ITimedAuction {}\\n\",\"keccak256\":\"0x7fdc46ad5a85666ee01b04e640117a98a0848b4e27c84dc7a1ab3cf9c808ee67\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/extensions/FHEAuctionBlindClaimable.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {IFHEAuctionEngine} from \\\"../../engines/IFHEAuctionEngine.sol\\\";\\nimport {FHEAuctionBase} from \\\"../FHEAuctionBase.sol\\\";\\n\\n/**\\n * Experimental\\n */\\nabstract contract FHEAuctionBlindClaimable is\\n    FHEAuctionBase\\n{\\n    uint16 private _blindClaimRequestCount;\\n\\n    mapping(address bidder => uint16) private _bidderToBlindClaimRankPlusOne;\\n\\n    /**\\n     * @notice Returns the total number of blind claim requests made so far.\\n     *\\n     * The number of remaining bidders who have not yet performed a blind claim can be calculated as:\\n     * `bidCount() - totalBlindClaimsRequested()`.\\n     */\\n    function totalBlindClaimsRequested() public view returns (uint16) {\\n        return _blindClaimRequestCount;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is ready for blind claim, `false` otherwise.\\n     *\\n     * @notice Conditions for a successful blind claim:\\n     * - The auction must be closed (ie. the auction is not accepting any additional bid).\\n     * - The engine must be ready for blind claim.\\n     * - The caller must be a registered bidder.\\n     */\\n    function canBlindClaim() public view whenClosed onlyBidder returns (bool) {\\n        return _canBlindClaim();\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the auction is ready for blind claim, `false` otherwise.\\n     * Internal function without access restriction.\\n     * This function is meant to be overriden to add extra conditions for a successfull claim.\\n     *\\n     * @notice Conditions for a successful claim:\\n     * - All ranked won quantities have been computed by the auction `_engine`.\\n     */\\n    function _canBlindClaim() internal view returns (bool) {\\n        return _canAwardPrizeByRank();\\n    }\\n\\n    /**\\n     * @notice Allows a registered bidder to claim the auction prize on behalf of an anonymous bidder ranked at\\n     * position `rank`. The prize is awarded to the unidentified bidder at the final uniform price determined\\n     * by the auction. The caller acts as an intermediary and does not directly receive the prize.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be a registered bidder.\\n     * - The auction must be closed.\\n     * - The auction engine must have finalized the computation of winning quantities for all bidders.\\n     * - The specified rank must not have already been claimed.\\n     *\\n     * @dev Each bidder is assigned a unique and constant claim rank. A bidder can claim the same rank multiple times.\\n     * If the bidder has not yet requested a blind claim, they are assigned the next available claim rank.\\n     */\\n    function blindClaim() external nonReentrant whenClosed {\\n        address bidder = msg.sender;\\n\\n        uint16 blindRankPlusOne = _bidderToBlindClaimRankPlusOne[bidder];\\n\\n        if (blindRankPlusOne == 0) {\\n            uint16 id = IFHEAuctionEngine(engine()).bidderId(bidder);\\n            if (id == 0) {\\n                revert BidderNotRegistered(bidder);\\n            }\\n\\n            blindRankPlusOne = _blindClaimRequestCount + 1;\\n            _bidderToBlindClaimRankPlusOne[bidder] = blindRankPlusOne;\\n            _blindClaimRequestCount = blindRankPlusOne;\\n        }\\n\\n        if (isPrizeAtRankAwarded(blindRankPlusOne - 1)) {\\n            return;\\n        }\\n\\n        _awardPrizeAtRank(blindRankPlusOne - 1);\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the caller has already executed a blind claim, `false` otherwise.\\n     */\\n    function hasBlindClaimed() external view returns (bool) {\\n        return _bidderToBlindClaimRankPlusOne[msg.sender] != 0;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the prize for the unidentified bidder assigned to the caller has been successfully\\n     * claimed via {blindClaim}, `false` otherwise.\\n     * @return completed `true` if the prize has been successfully claimed, `false` otherwise.\\n     */\\n    function blindClaimCompleted() external view returns (bool) {\\n        uint16 blindRankPlusOne = _bidderToBlindClaimRankPlusOne[msg.sender];\\n        if (blindRankPlusOne == 0) {\\n            return false;\\n        }\\n        return isPrizeAtRankAwarded(blindRankPlusOne - 1);\\n    }\\n}\\n\",\"keccak256\":\"0x6165dea9dfb901aff4dc57a53741f0179a76ce1a6bb05bbec90b3f88c197b301\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/factories/FHEAuctionFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {FHEAuctionEngineFactory} from \\\"../../engines/factories/FHEAuctionEngineFactory.sol\\\";\\nimport {FHEAuctionEngine} from \\\"../../engines/FHEAuctionEngine.sol\\\";\\n\\nabstract contract FHEAuctionFactory is Ownable2Step {\\n    struct FHEAuctionFactoryDetails {\\n        FHEAuctionEngineFactory enginePriceIdFactory;\\n        FHEAuctionEngineFactory enginePriceQuantityIdFactory;\\n        FHEAuctionEngineFactory enginePriceRandomFactory;\\n        FHEAuctionEngineFactory engineProRataFactory;\\n    }\\n\\n    mapping(uint8 => FHEAuctionEngineFactory) private _engineFactories;\\n    mapping(bytes32 => address) private _auctionDeployed;\\n    uint256 private _auctionDeployedCount;\\n\\n    constructor(FHEAuctionFactoryDetails memory details_) Ownable(msg.sender) {\\n        if (address(details_.enginePriceIdFactory) != address(0)) {\\n            if (details_.enginePriceIdFactory.owner() != msg.sender) {\\n                revert OwnableUnauthorizedAccount(_msgSender());\\n            }\\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceId)] = details_.enginePriceIdFactory;\\n        }\\n\\n        if (address(details_.enginePriceQuantityIdFactory) != address(0)) {\\n            if (details_.enginePriceQuantityIdFactory.owner() != msg.sender) {\\n                revert OwnableUnauthorizedAccount(_msgSender());\\n            }\\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceQuantityId)] =\\n                details_.enginePriceQuantityIdFactory;\\n        }\\n\\n        if (address(details_.enginePriceRandomFactory) != address(0)) {\\n            if (details_.enginePriceRandomFactory.owner() != msg.sender) {\\n                revert OwnableUnauthorizedAccount(_msgSender());\\n            }\\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.PriceRandom)] = details_.enginePriceRandomFactory;\\n        }\\n\\n        if (address(details_.engineProRataFactory) != address(0)) {\\n            if (details_.engineProRataFactory.owner() != msg.sender) {\\n                revert OwnableUnauthorizedAccount(_msgSender());\\n            }\\n            _engineFactories[uint8(FHEAuctionEngine.TieBreakingRule.ProRata)] = details_.engineProRataFactory;\\n        }\\n    }\\n\\n    function _getEngineFactory(uint8 tieBreakingRule) internal view returns (FHEAuctionEngineFactory) {\\n        return _engineFactories[tieBreakingRule];\\n    }\\n\\n    function _getAuction(bytes32 deploySalt) internal view returns (address) {\\n        return _auctionDeployed[deploySalt];\\n    }\\n\\n    function _setAuction(bytes32 deploySalt, address auctionAddr) internal {\\n        require(_auctionDeployed[deploySalt] == address(0), \\\"Auction already deployed\\\");\\n        _auctionDeployed[deploySalt] = auctionAddr;\\n        _auctionDeployedCount += 1;\\n    }\\n\\n    function count() external view returns (uint256) {\\n        return _auctionDeployedCount;\\n    }\\n\\n    function isNative() public view virtual returns (bool);\\n    function _getCode() internal view virtual returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5c8a1d399c9171f101b18853032186561996399c6af74e14688734c6cb283775\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/factories/FHEAuctionNativeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Create2} from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {FHEAuctionFactory} from \\\"./FHEAuctionFactory.sol\\\";\\nimport {FHEAuctionNative} from \\\"../FHEAuctionNative.sol\\\";\\nimport {FHEAuctionBase} from \\\"../FHEAuctionBase.sol\\\";\\n\\ncontract FHEAuctionNativeFactory is FHEAuctionFactory {\\n    constructor(FHEAuctionFactoryDetails memory details_) FHEAuctionFactory(details_) {}\\n\\n    event FHEAuctionNativeDeployed(\\n        address indexed auction_, bytes32 indexed salt_, address beneficiary_, address auctionToken_\\n    );\\n\\n    function isNative() public view virtual override returns (bool) {\\n        return true;\\n    }\\n\\n    function getAuction(bytes32 salt_, address beneficiary_, address auctionToken_) external view returns (address) {\\n        return _getAuction(_hashSalt(salt_, beneficiary_, auctionToken_));\\n    }\\n\\n    function _getCode() internal view virtual override returns (bytes memory) {\\n        return type(FHEAuctionNative).creationCode;\\n    }\\n\\n    function _hashSalt(bytes32 salt_, address beneficiary_, address auctionToken_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(salt_, beneficiary_, auctionToken_));\\n    }\\n\\n    function computeAuctionAddress(\\n        bytes32 salt_,\\n        address beneficiary_,\\n        address auctionToken_,\\n        uint256 minimumPaymentDeposit_,\\n        uint256 paymentPenalty_\\n    ) public view returns (address) {\\n        bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_);\\n        bytes memory code = _getCode();\\n        bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_);\\n        bytes memory bytecode = abi.encodePacked(code, constructData);\\n        return Create2.computeAddress(deploySalt, keccak256(bytecode));\\n    }\\n\\n    function createNewAuction(\\n        address auctionOwner_,\\n        bytes32 salt_,\\n        address beneficiary_,\\n        uint256 auctionQuantity_,\\n        address auctionToken_,\\n        uint16 maxBidCount_,\\n        uint8 tieBreakingRule_,\\n        uint256 minimumPaymentDeposit_,\\n        uint256 paymentPenalty_\\n    ) public returns (address) {\\n        address auctionAddr;\\n        {\\n            bytes32 deploySalt = _hashSalt(salt_, beneficiary_, auctionToken_);\\n\\n            require(_getAuction(deploySalt) == address(0), \\\"auction already deployed\\\");\\n\\n            bytes memory code = _getCode();\\n            bytes memory constructData = abi.encode(minimumPaymentDeposit_, paymentPenalty_);\\n            bytes memory bytecode = abi.encodePacked(code, constructData);\\n\\n            // Reentrancy\\n            address computedAuctionAddr = Create2.computeAddress(deploySalt, keccak256(bytecode));\\n            _setAuction(deploySalt, computedAuctionAddr);\\n\\n            auctionAddr = Create2.deploy(0, deploySalt, bytecode);\\n\\n            // Debug\\n            require(auctionAddr == computedAuctionAddr, \\\"Panic: auctionAddr != computedAuctionAddr\\\");\\n        }\\n\\n        address engine = _getEngineFactory(tieBreakingRule_).createNewEngine(auctionAddr);\\n\\n        FHEAuctionBase auction = FHEAuctionBase(auctionAddr);\\n\\n        auction.initialize(engine, beneficiary_, IERC20(auctionToken_), auctionQuantity_, maxBidCount_);\\n        auction.transferOwnership(auctionOwner_);\\n\\n        emit FHEAuctionNativeDeployed(auctionAddr, salt_, beneficiary_, address(auctionToken_));\\n\\n        return auctionAddr;\\n    }\\n}\\n\",\"keccak256\":\"0xd80d4b6c7a535cf49ffead66d22582e7a89d78d7a904bb215096eacd3fac77d8\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IFHEAuctionEngine} from \\\"./IFHEAuctionEngine.sol\\\";\\nimport {IFHEAuction} from \\\"../auctions/IFHEAuction.sol\\\";\\nimport {FHEAuctionEngineIterator} from \\\"./FHEAuctionEngineIterator.sol\\\";\\nimport {\\n    FourStepsIterator,\\n    IFourStepsIterable,\\n    S_FINISHED,\\n    S_NOT_FINISHED,\\n    E_NOT_ENOUGH_GAS\\n} from \\\"../FourStepsIterator.sol\\\";\\n\\n/**\\n * @notice ## Engine Architecture\\n *\\n * ### Incremental Computation\\n *\\n * - A uniform price auction requires an FHE-based sorting operation, which has a computational complexity\\n *   of O(N^2), where N is the number of bidders. As a result, the overall auction computation consumes\\n *   a significant amount of both native and FHE gas.\\n *\\n * - To overcome these gas cost limitations, the implementation adopts an incremental batch-processing mechanism,\\n *   allowing the full computation to be executed iteratively across multiple smaller transactions, rather\\n *   than in a single execution. This ensures computations remain gas-efficient and\\n *   prevents exceeding blockchain transaction limits as well as fhEVM limits.\\n *\\n * - Since the auction results cannot be determined in a single transaction, a dedicated contract,\\n *   {FHEAuctionEngineIterator}, is responsible for managing the paging mechanism. It orchestrates the\\n *   progressive execution of auction computation cycles until completion.\\n *\\n * - A drawback of such iterative approach is the extra native gas cost required to read/write additional state\\n *   variables required to save the computation status between two consecutive computation transactions.\\n *\\n * ### Contract Size Limit\\n *\\n * Due to the maximum contract size restrictions, the auction engine is modularized across multiple contracts:\\n *\\n * - Core Engine: `FHEAuctionEngine`, the base contract.\\n * - Tie-Breaking Implementations: Four specialized contracts inherit from `FHEAuctionEngine`, each\\n *   implementing a different tie-breaking rule:\\n *      - `FHEAuctionEnginePriceId`\\n *      - `FHEAuctionEnginePriceQuantityId`\\n *      - `FHEAuctionEnginePriceRandom`\\n *      - `FHEAuctionEngineProRata`\\n * - Computation Manager: `FHEAuctionEngineIterator`, responsible for orchestrating the incremental\\n *   computation process.\\n *\\n * @notice ## Algorithm for Bid Validation and Ranking\\n *\\n * ### Approach\\n *\\n * A bit-level strategy would have been optimal in terms of FHE cost; however, the resulting native gas cost\\n * would be overwhelming. The primary reason is that the current version of TFHE library lacks batch functions\\n * or high-level bitwise operations (such as array manipulations or tensor operations).\\n * As a result, a more \\\"brute force\\\" approach manipulating encrypted integers is necessary.\\n *\\n * The algorithm consists in 4 steps, with the last one beeing optional.\\n *\\n *  |  Steps                     |  Cost    |\\n *  |----------------------------|----------|\\n *  |  1. Bid validation         |  O(N)    |\\n *  |  2. Bid ranking            |  O(N^2)  |\\n *  |  3. Won Quantities by rank |  O(N)    |\\n *  |  4. Won Quantities by id   |  O(N^2)  |\\n *\\n * ### Step 1: Bid validation. O(N)\\n *\\n * The first step is to sanitize the list of registered bids by evaluating each one individually. If a bid fails to meet\\n * the engine's validation criteria, it is marked as invalid, with both the price and quantity set to zero\\n * (i.e., `price = 0` and `quantity = 0`).\\n *\\n * Registered bids are indexed starting from `1` up to `bidCount`. Therefore, an index of `0` indicates that no bid\\n * exists. For each valid bid at index `i` (where `1 <= i <= bidCount`), the following two conditions must always hold:\\n *\\n * 1. `0 < price(i) <= Maximum Price`\\n * 2. `0 < quantity(i) <= Total Quantity`\\n *\\n * ### Step 2: Bid ranking (sort). O(N^2)\\n *\\n * - In this step, we determine the price and quantity of the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`. The bid ranked at position `0` is the highest-ranked bid, which is determined based on the selected\\n * ranking criteria. The ranking is strict, meaning no two bids can share the same rank. To achieve this, the bid\\n * set is provided with a strict order relation, ensuring a clear distinction between each bid's position in the ranking.\\n *\\n * - The final list of ranked bids is constructed through an iterative process. Specifically, the bid at index `k+1` is\\n * inserted into an existing list of ranked bids of length `k`, resulting in a new list of length `k+1`. During each\\n * insertion, the bid is placed in its correct position, ensuring that the relationship `Bid(k) > Bid(k+1)` holds true\\n * according to the selected comparison criteria.\\n *\\n * - The comparison function used to rank bids depends on two factors: the bid price and the auction engine's specified\\n * tie-breaking rule. This ensures that bids are ranked in a consistent and predictable manner.\\n *\\n * - Finally, the computational complexity of this bid ranking operation is `N(N-1)/2 = O(N^2)`, where `N` represents the\\n * total number of bids. This complexity arises from the need to perform pairwise comparisons and insert each bid into the\\n * correct position within the sorted list.\\n *\\n * ### Step 3: Ranked bid won quantities and uniform price calculation. O(N)\\n *\\n * - In the third step, we determine the final quantity for the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`, as well as the auction's final uniform price. A winning bid will have a strictly positive quantity,\\n * while a losing bid will have a quantity of zero.\\n *\\n * - Since the bids are ranked in strict order, the quantity for each winning bid can be determined deterministically,\\n * without the need for tie-breaking.\\n *\\n * - The uniform price is calculated as the price of the lowest winning bid.\\n *\\n * - The computational complexity O(N), linear in the number of bids.\\n *\\n * ### Step 4 (Optional): Inverting ranking to index vector. O(N^2)\\n *\\n * - This step generates an index vector that maps the ranking of bids back to their original positions in the\\n * ranked list. Each position in the index vector corresponds to the original index of a bid in the ranked list.\\n *\\n * - The purpose of this step is to facilitate lookup or processing based on the original bid order.\\n *\\n * - This step is optional and can be skipped to minimize computation cost and if auction prizes can delivered directly\\n * based on ranking positions rather than requiring bidder addresses.\\n */\\nabstract contract FHEAuctionEngine is SepoliaZamaFHEVMConfig, Ownable, IFourStepsIterable, IFHEAuctionEngine {\\n    uint256 public constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint256 public constant MIN_GAS_PER_BV_CYCLE = 165_000;\\n    uint256 public constant MIN_GAS_PER_RB_CYCLE = 420_000;\\n    uint256 public constant MIN_GAS_PER_RWQ_CYCLE = 250_000;\\n    uint256 public constant MIN_GAS_PER_WQ_CYCLE = 160_000;\\n\\n    euint256 constant DUMMY_EUINT256_MEMORY = euint256.wrap(uint32(0xdeadbeef));\\n    euint16 constant DUMMY_EUINT16_MEMORY = euint16.wrap(uint32(0xdeadbeef));\\n\\n    enum TieBreakingRule {\\n        PriceId,\\n        PriceQuantityId,\\n        PriceRandom,\\n        ProRata\\n    }\\n\\n    struct ABid {\\n        euint256 price;\\n        euint256 quantity;\\n        euint256 rand;\\n        euint16 id;\\n    }\\n\\n    FHEAuctionEngineIterator _iterator;\\n\\n    uint256 private _totalQuantity;\\n    TieBreakingRule private _tieBreakingRule;\\n    bool private _auctionIsClosed;\\n\\n    uint16 private _maxBidCount;\\n    uint16 private _bidCount;\\n    uint16 private _nextId;\\n\\n    // 1 <= id < _nextId\\n    mapping(address bidder => uint16 id) private _bidderToId;\\n    mapping(uint16 id => address bidder) private _idToBidder;\\n\\n    // 1 <= idxPlusOne <= _bidCount\\n    mapping(uint16 idxPlusOne => uint16 id) private _indexPlusOneToId;\\n    mapping(uint16 id => uint16 idxPlusOne) private _idToIndexPlusOne;\\n\\n    // 1 <= id < _nextId\\n    mapping(uint16 id => ABid bid) private _idToBid;\\n\\n    euint256 private _cumulativeQuantity;\\n    euint256 private _uniformPrice;\\n\\n    ///@dev A precomputed zero euint256 to minimize the `TFHE.asEuint256(0)` calls\\n    euint256 private immutable _eZeroU256;\\n\\n    // Step 2: Bid ranking. O(N^2)\\n    // ===========================\\n\\n    ///@dev Index from which the computation of step #2 should resume.\\n    uint16 private _resumeIdxRB;\\n\\n    ///@dev Temporary saved did data required when the computation of step #2 should resume.\\n    ABid private _cursorRB;\\n\\n    ///@dev Total number of ranked bids that have been computed so far.\\n    ///@dev 0 <= _rankedBidCount <= _bidCount\\n    uint16 private _rankedBidCount;\\n\\n    ///@dev Array of bids sorted by rank order, where entry k contains the bid placed by bidder ranked at position k.\\n    ///@dev 0 <= rank < _rankedBidCount\\n    ABid[] private _rankedBids;\\n\\n    // Step 3: Ranked bid won quantity and uniform price calculation. O(N)\\n    // ===================================================================\\n\\n    ///@dev Array of final won quantities sorted by rank order, where entry k contains the won quantity for bidder\\n    /// ranked at position k.\\n    euint256[] private _rankedWonQuantities;\\n\\n    // Step 4: Inverting ranking to index vector. O(N)\\n    // ===============================================\\n\\n    ///@dev Index of the bidder whose final won quantity is being computed\\n    uint16 private _idxWQ;\\n\\n    ///@dev Index from which the computation of the final won quantity should resume\\n    uint16 private _resumeIdxWQ;\\n\\n    ///@dev `true` if all won quantities have been computed\\n    bool private _wonQuantitiesByIdReady;\\n\\n    ///@dev `true` if all ranked won quantities have been computed\\n    bool private _wonQuantitiesByRankReady;\\n\\n    ///@dev Current computed final won quantity for the bidder at index `_idxWQ`\\n    euint256 private _quantityWQ;\\n\\n    ///@dev Array of final won quantities, where entry k contains the won quantity for bidder with index = k + 1\\n    euint256[] private _wonQuantities;\\n\\n    error ExpectedNotClosed();\\n    error ExpectedClosed();\\n    error IndexOutOfBounds(uint16 idx, uint16 count);\\n    error RankOutOfBounds(uint16 rank, uint16 rankCount);\\n    error InvalidIterator();\\n    error InvalidId(uint16 id);\\n    error BidderAlreadyRegistered(address bidder);\\n    error TooManyBids();\\n    error WonQuantitiesByRankNotReady();\\n    error WonQuantitiesByIdNotReady();\\n    error NotEnoughGas(uint256 gasLeft, uint256 gasNeeded);\\n    error UnauthorizedIterator();\\n    // Debug\\n    error DebugEngineError(uint16 code);\\n\\n    /**\\n     * @dev Ensures the auction engine not closed before executing the function.\\n     */\\n    modifier whenNotClosed() {\\n        if (_auctionIsClosed) revert ExpectedNotClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Ensures the auction engine is closed before executing the function.\\n     */\\n    modifier whenClosed() {\\n        if (!_auctionIsClosed) revert ExpectedClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the iterator.\\n     */\\n    modifier onlyIterator() {\\n        if (address(_iterator) != msg.sender) {\\n            revert UnauthorizedIterator();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @param auctionOrInitialOwner_ The address of the `FHEAuctionBase` contract that owns this auction engine or the\\n     * address of the initial owner. If the engine initial owner is not the auction contract, a transfer ownership must\\n     * be performed to give ownership to the auction contract.\\n     * @param tieBreakingRule_ The tie-breaking rule used by the auction engine to resolve ties.\\n     * @param iterator_ The addre.\\n     */\\n    constructor(address auctionOrInitialOwner_, uint8 tieBreakingRule_, address iterator_)\\n        Ownable(auctionOrInitialOwner_)\\n    {\\n        if (iterator_ == address(0) || Ownable(iterator_).owner() != auctionOrInitialOwner_) {\\n            revert InvalidIterator();\\n        }\\n\\n        _iterator = FHEAuctionEngineIterator(iterator_);\\n        _tieBreakingRule = TieBreakingRule(tieBreakingRule_);\\n\\n        euint256 eZero = TFHE.asEuint256(0);\\n        TFHE.allowThis(eZero);\\n\\n        _eZeroU256 = eZero;\\n        _cumulativeQuantity = eZero;\\n        _uniformPrice = eZero;\\n\\n        // A bit counter intuitive.\\n        // Mainly to ensure that computation iterations have a constant gas cost\\n        _cursorRB.price = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.quantity = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.id = DUMMY_EUINT16_MEMORY;\\n        _resumeIdxRB = uint16(0xdead);\\n\\n        _quantityWQ = eZero;\\n        _nextId = 1;\\n        _maxBidCount = type(uint16).max;\\n    }\\n\\n    /**\\n     * @notice Initializes the auction engine with a specified quantity of items.\\n     * The `FHEAuctionEngine` contract is intended for internal use by its owner and is not designed to be\\n     * used by other contracts. It does not include protections against reentrancy or multiple initializations.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner (a contract of type `FHEAuctionBase`).\\n     * - The engine must not be in a closed state.\\n     *\\n     * @param totalQuantity_ The total quantity of items to be auctioned.\\n     */\\n    function initialize(uint256 totalQuantity_, uint16 maxBidCount_) external onlyOwner whenNotClosed {\\n        _totalQuantity = totalQuantity_;\\n        _maxBidCount = maxBidCount_;\\n    }\\n\\n    /**\\n     * @notice Returns the auction contract associated with this engine.\\n     * @dev The auction contract is required to be the owner of the engine.\\n     * @return The auction contract interface.\\n     */\\n    function _auction() internal view returns (IFHEAuction) {\\n        return IFHEAuction(owner());\\n    }\\n\\n    /**\\n     * @notice Returns the engine iterator address. The iterator's owner is the engine itself.\\n     */\\n    function iterator() public view returns (address) {\\n        return address(_iterator);\\n    }\\n\\n    /**\\n     * @notice Returns total quantity of items to be auctioned.\\n     */\\n    function totalQuantity() external view returns (uint256) {\\n        return _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum allowable price for each bid.\\n     * This value ensures that subsequent TFHE arithmetic operations will not overflow.\\n     */\\n    function maximumPrice() public view returns (uint256) {\\n        return MAX_UINT256 / _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the tie-breaking rule used to resolve winning ties.\\n     */\\n    function tieBreakingRule() external view returns (uint8) {\\n        return uint8(_tieBreakingRule);\\n    }\\n\\n    /**\\n     * @notice Returns the total number of bids.\\n     */\\n    function getBidCount() public view returns (uint16) {\\n        return _bidCount;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum number of bids.\\n     */\\n    function getMaximumBidCount() public view returns (uint16) {\\n        return _maxBidCount;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bid index. Reverts if the index is out of bounds.\\n     * @param index The zero-based index of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByIndex(uint16 index) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        if (index >= _bidCount) {\\n            revert IndexOutOfBounds(index, _bidCount);\\n        }\\n\\n        id = _indexPlusOneToId[index + 1];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bidder address.\\n     * @param bidder The address of the bidder whose bid is being retrieved.\\n     * @return id The clear ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByBidder(address bidder) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        id = _bidderToId[bidder];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Returns the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` is the highest-ranked (winning) bid. Reverts if `rank` is out of bounds.\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (rank >= _rankedBidCount) {\\n            revert RankOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedBids[rank].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` represents the highest-ranked (winning) bid.\\n     * The function reverts if:\\n     * - The ranked won quantities computation is not complete.\\n     * - The provided `rank` is out of bounds.\\n     *\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid at the specified rank.\\n     * @return price The encrypted price of the bid at the specified rank.\\n     * @return quantity The encrypted quantity won by the bid at the specified rank.\\n     */\\n    function getWonBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (!_wonQuantitiesByRankReady) {\\n            // step #3 is not yet completed\\n            revert WonQuantitiesByRankNotReady();\\n        }\\n\\n        if (rank >= _rankedBidCount) {\\n            revert IndexOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedWonQuantities[rank];\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the uniform price is ready for decryption.\\n     */\\n    function canDecryptUniformPrice() external view returns (bool) {\\n        // uniformPrice is computed during step #3\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns the encrypted uniform price if computations are complete;\\n     * otherwise, returns zero (uninitialized `euint256`).\\n     * @return price the encrypted uniform price. The engine owner has TFHE permissions to access `price`.\\n     */\\n    function getUniformPrice() public view returns (euint256 price) {\\n        // uniformPrice is computed during step #3\\n        if (_wonQuantitiesByRankReady) {\\n            price = _uniformPrice;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the computation of all won quantities is complete (step #4),\\n     * allowing bidders to claim their auction prizes.\\n     */\\n    function canClaim() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function canAward() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function wonQuantitiesByRankReady() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #4),\\n     */\\n    function wonQuantitiesByIdReady() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns the validated price and the encrypted won quantity associated with the bid identified by `id`.\\n     *\\n     * @notice Requirements:\\n     * - The computation of all won quantities must be complete (step #4).\\n     * - `id` must be a valid ID.\\n     *\\n     * @param id The bid ID.\\n     * @return validatedPrice The encrypted validated price of the bid.\\n     * @return wonQuantity The encrypted won quantity of the bid.\\n     *\\n     * @dev The owning auction contract has TFHE access permissions on both `wonQuantity` and `validatedPrice`.\\n     */\\n    function validatedPriceAndWonQuantityById(uint16 id)\\n        external\\n        view\\n        returns (euint256 validatedPrice, euint256 wonQuantity)\\n    {\\n        if (_wonQuantitiesByIdReady) {\\n            uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n            if (idxPlusOne == 0 || idxPlusOne > _bidCount) {\\n                revert InvalidId(id);\\n            }\\n\\n            // owner has TFHE permissions.\\n            validatedPrice = _idToBid[id].price;\\n            wonQuantity = _wonQuantities[idxPlusOne - 1];\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the bid ID associated with the specified `bidder` address.\\n     */\\n    function bidderId(address bidder) external view returns (uint16) {\\n        return _bidderToId[bidder];\\n    }\\n\\n    /**\\n     * @notice Returns the bidder address associated with the specified `id`.\\n     */\\n    function getBidderById(uint16 id) external view returns (address) {\\n        return _idToBidder[id];\\n    }\\n\\n    /**\\n     * @notice Removes a bidder's bid from the list of bids\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not be closed. (ie still accepting new bids)\\n     */\\n    function removeBid(address bidder) external onlyOwner whenNotClosed {\\n        uint16 id = _bidderToId[bidder];\\n        if (id == 0) {\\n            return;\\n        }\\n\\n        // Debug\\n        if (!(_bidCount > 0)) revert DebugEngineError(4);\\n\\n        uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n        // Debug\\n        if (!(idxPlusOne > 0)) revert DebugEngineError(5);\\n\\n        // remove bidder address\\n        _bidderToId[bidder] = 0;\\n        _idToBidder[id] = address(0);\\n\\n        // swap id with last id\\n        if (idxPlusOne < _bidCount) {\\n            uint16 lastId = _indexPlusOneToId[_bidCount];\\n\\n            // Debug\\n            if (!(lastId > 0)) revert DebugEngineError(6);\\n\\n            _indexPlusOneToId[idxPlusOne] = lastId;\\n            _idToIndexPlusOne[lastId] = idxPlusOne;\\n        }\\n\\n        // remove id\\n        _indexPlusOneToId[_bidCount] = 0;\\n        _idToIndexPlusOne[id] = 0;\\n        _idToBid[id] =\\n            ABid({price: euint256.wrap(0), quantity: euint256.wrap(0), id: euint16.wrap(0), rand: euint256.wrap(0)});\\n\\n        _bidCount--;\\n    }\\n\\n    /**\\n     * @notice Mark the auction engine as closed. When the engine is closed, it can no more accept new bids.\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not already be closed.\\n     */\\n    function close() external onlyOwner whenNotClosed {\\n        _close(false);\\n    }\\n\\n    function _close(bool onlyBlindClaim) internal {\\n        _auctionIsClosed = true;\\n        _iterator.initializeFourSteps(_bidCount, 2_456_000, _rankFheGasCostPerIdx(), 1_469_000, 101_000, onlyBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Executes a batch of auction computation cycles, processing up to `iter` cycles in a single call.\\n     * This function allows incremental processing of the auction results until completion.\\n     *\\n     * @dev If the auction is not yet closed, it will be closed before starting the computation.\\n     *\\n     * @notice Requirements:\\n     * - Only the contract owner can call this function.\\n     *\\n     * @param iter The maximum number of computation cycles to execute in this call.\\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of computation cycles completed before this function call.\\n     * @return endIterProgress The total number of computation cycles completed after this function call.\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        if (!_auctionIsClosed) {\\n            _close(false);\\n        }\\n        (code, startIterProgress, endIterProgress) = _iterator.computeAuctionIterations(iter, stopIfReadyForBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Adds a new bid to the list of bids.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine must not be closed.\\n     *\\n     * @param bidder The address of the bidder placing the new bid.\\n     * @param ePrice The encrypted price of the bid.\\n     * @param eQuantity The encrypted quantity of the bid.\\n     */\\n    function addBid(address bidder, euint256 ePrice, euint256 eQuantity) external onlyOwner whenNotClosed {\\n        if (_bidderToId[bidder] != 0) {\\n            revert BidderAlreadyRegistered(bidder);\\n        }\\n\\n        if (_bidCount == _maxBidCount) {\\n            revert TooManyBids();\\n        }\\n\\n        uint16 nextId = _nextId;\\n        _nextId = nextId + 1;\\n\\n        uint16 nextIdxPlusOne = _bidCount + 1;\\n        _bidCount = nextIdxPlusOne;\\n\\n        euint256 zero = _eZeroU256;\\n        ebool priceTooHigh = TFHE.gt(ePrice, maximumPrice());\\n        ePrice = TFHE.select(priceTooHigh, zero, ePrice);\\n        eQuantity = TFHE.min(eQuantity, _totalQuantity);\\n\\n        ebool ePriceIsZero = TFHE.eq(ePrice, zero);\\n        ebool eQuantityIsZero = TFHE.eq(eQuantity, zero);\\n\\n        ePrice = TFHE.select(eQuantityIsZero, zero, ePrice);\\n        eQuantity = TFHE.select(ePriceIsZero, zero, eQuantity);\\n\\n        euint256 eRand = euint256.wrap(0);\\n        euint16 eId = TFHE.asEuint16(nextId);\\n\\n        if (_tieBreakingRule == TieBreakingRule.PriceRandom) {\\n            eRand = TFHE.randEuint256();\\n            TFHE.allowThis(eRand);\\n        }\\n\\n        TFHE.allowThis(ePrice);\\n        TFHE.allowThis(eQuantity);\\n        TFHE.allowThis(eId);\\n\\n        _indexPlusOneToId[nextIdxPlusOne] = nextId;\\n        _idToIndexPlusOne[nextId] = nextIdxPlusOne;\\n\\n        _bidderToId[bidder] = nextId;\\n        _idToBidder[nextId] = bidder;\\n\\n        _idToBid[nextId] = ABid({price: ePrice, quantity: eQuantity, rand: eRand, id: eId});\\n\\n        // Bidder pays for memory allocation\\n        ABid memory _emptySortedBid;\\n        _emptySortedBid.price = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.quantity = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.rand = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.id = eId;\\n\\n        _rankedBids.push(_emptySortedBid);\\n        _rankedWonQuantities.push(DUMMY_EUINT256_MEMORY);\\n        _wonQuantities.push(DUMMY_EUINT256_MEMORY);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //                  \\u2b50\\ufe0f Step 1/4: Bid Validation O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #1.\\n     *\\n     * - Returns `E_NOT_ENOUGH_GAS` if the `chunckSize` iterations could not be completed due to insufficient gas.\\n     * - Returns `S_NOT_FINISHED` if the iterations were completed but the computation step is not yet finished.\\n     * - Returns `S_FINISHED` if the iterations were completed (or fewer iterations were needed) and the bid ranking step has been completed.\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #1. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x mul(euint256, euint256) : 1 x 2_045_000\\n     * - 1x le(euint256, uint256)   : 1 x   231_000\\n     * - 2x select(euint256)        : 2 x    90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 2_456_000\\n     */\\n    function _runStep1(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Gas cost ~= 2_400\\n        uint16 toIdx = uint16(progress + iter);\\n\\n        euint256 ePrice;\\n        euint256 eQuantity;\\n\\n        IFHEAuction auction = _auction();\\n\\n        // From start to beginning of the loop : Gas cost ~= 2_600\\n        // 1x loop iter ~= 153_000 gas\\n        // After loop ~= 3_000 gas\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        for (uint16 idx = uint16(progress); idx < toIdx; ++idx) {\\n            uint16 bidId = _indexPlusOneToId[idx + 1];\\n\\n            // Debug\\n            if (!(bidId > 0)) revert DebugEngineError(7);\\n\\n            ABid storage b = _idToBid[bidId];\\n            ePrice = b.price;\\n            eQuantity = b.quantity;\\n            // ePrice = _idToBid[bidId].price;\\n            // eQuantity = _idToBid[bidId].quantity;\\n\\n            // Cannot overflow\\n            euint256 minBalance = TFHE.mul(ePrice, eQuantity);\\n\\n            ebool enoughBalance = TFHE.le(minBalance, auction.balanceOf(_idToBidder[bidId]));\\n\\n            ePrice = TFHE.select(enoughBalance, ePrice, _eZeroU256);\\n            eQuantity = TFHE.select(enoughBalance, eQuantity, _eZeroU256);\\n\\n            // _idToBid[bidId].price = ePrice;\\n            // _idToBid[bidId].quantity = eQuantity;\\n            b.price = ePrice;\\n            b.quantity = eQuantity;\\n\\n            TFHE.allowThis(ePrice);\\n            TFHE.allowThis(eQuantity);\\n            TFHE.allow(ePrice, address(auction));\\n            TFHE.allow(eQuantity, address(auction));\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            code = S_FINISHED;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //             \\u2b50\\ufe0f Step 2/4: Sort Bids by Rank Order O(N^2) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @dev Returns the FHE Gas cost per iteration consumed by the `_rankFromIdxToIdx` function.\\n     */\\n    function _rankFheGasCostPerIdx() internal pure virtual returns (uint32);\\n\\n    /**\\n     * @dev Performs a ranking pass from index `fromIdx` to index `toIdx`. The FHE Gas cost can be evaluated using the\\n     * `_rankFheGasCostPerIdx` function.\\n     */\\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual;\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #2.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #2. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev Total FHE Gas Cost per iteration : `_rankFheGasCostPerIdx()`\\n     */\\n    function _runStep2(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < 2 * MIN_GAS_PER_RB_CYCLE) {\\n            // If we do not have enough gas left to perform `one TFHE cycle` + `one sort completion`\\n            // it is probably safe to interrupt at this point to avoid any accidental revert due to insufficient gas\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 rankedBidCount = _rankedBidCount;\\n        uint16 resumeIdx;\\n\\n        // We want to optimize the following calls:\\n        // - TFHE.allow(...) which cost about 25_000 gas\\n        // - SSTORE operations\\n        // We use the following 2 flags to minimize those calls.\\n        bool cursorAllowNeeded = false;\\n        bool cursorUpdateNeeded = false;\\n\\n        ABid memory cursor;\\n\\n        // We pick the first registered bid and store it at the first place of\\n        // the sorted bid list.\\n        if (rankedBidCount == 0) {\\n            // The first bid id is equal to `1`\\n            // (See the bid() function and the above remark (3))\\n            _rankedBids[0] = _idToBid[_indexPlusOneToId[1]];\\n\\n            // if there is only one single bidder, the sort is over\\n            if (_bidCount == 1) {\\n                _rankedBidCount = 1;\\n                return (S_FINISHED, 1);\\n            }\\n\\n            // if there are more than one bidder,\\n            // load the second unsorted bid into the cursor and setup the cursor position to zero\\n            rankedBidCount = 1;\\n            resumeIdx = 0;\\n            cursor = _idToBid[_indexPlusOneToId[2]];\\n            cursorUpdateNeeded = true;\\n        } else {\\n            // If the function is called to resume the sort operation, then\\n            // start from the last position stored in the cursor.\\n            resumeIdx = _resumeIdxRB;\\n            cursor = _cursorRB;\\n        }\\n\\n        uint8 code = S_NOT_FINISHED;\\n        uint32 count = 0;\\n\\n        while (count < iter) {\\n            uint32 toIdx = resumeIdx + uint16(iter - count);\\n            if (toIdx > rankedBidCount) {\\n                toIdx = rankedBidCount;\\n            }\\n\\n            // We want to make sure we have enough gas to compute the following:\\n            // - `toIdx - resumeIdxRB` cycles of TFHE operations\\n            // - 1 extra gas quantity to finish the current sort pass.\\n            if (gasleft() < (toIdx - resumeIdx + 1) * MIN_GAS_PER_RB_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            // since resumeIdx < toIdx, the cursor will always be modified\\n            // therefore we must invalidate the storage `_cursorRB` struct.\\n            _rankFromIdxToIdx(resumeIdx, uint16(toIdx), cursor);\\n\\n            count += (toIdx - resumeIdx);\\n\\n            // invalidate the storage `_cursorRB`\\n            cursorUpdateNeeded = true;\\n\\n            // We have reached the end of the currently sorted bids.\\n            // We must do the following:\\n            // 1. append the bid cursor to end of the sorted list.\\n            // 2. load the cursor with the next unsorted bid\\n            // 3. set the cursor position to zero.\\n            if (toIdx == rankedBidCount) {\\n                _rankedBids[rankedBidCount] = cursor;\\n                rankedBidCount++;\\n\\n                _allowBid(cursor);\\n\\n                // If all the registered bids have been sorted, then the sort operation\\n                // is completed.\\n                if (rankedBidCount == _bidCount) {\\n                    // Debug\\n                    if (!(progress + count == progressMax)) revert DebugEngineError(8);\\n\\n                    _rankedBidCount = rankedBidCount;\\n                    return (S_FINISHED, count);\\n                }\\n\\n                // restart from the beginning with the next unsorted bid.\\n                // The next unsorted bid index is equal to `rankedBidCount`\\n                resumeIdx = 0;\\n                cursor = _idToBid[_indexPlusOneToId[rankedBidCount + 1]];\\n\\n                // since the values stored in the cursor are already allowed, there\\n                // will be no need to perform any TFHE.allow() call.\\n                cursorAllowNeeded = false;\\n            } else {\\n                // Debug\\n                if (!(count == iter)) revert DebugEngineError(9);\\n\\n                resumeIdx = uint16(toIdx);\\n\\n                // a TFHE.allow call must be executed on the new cursor values\\n                cursorAllowNeeded = true;\\n            }\\n        }\\n\\n        // Debug\\n        if (!(progress + count < progressMax)) revert DebugEngineError(10);\\n\\n        // Perform TFHE.allow if needed\\n        if (cursorAllowNeeded) {\\n            _allowBid(cursor);\\n        }\\n\\n        // Save the new cursor if needed\\n        if (cursorUpdateNeeded) {\\n            _cursorRB = cursor;\\n        }\\n\\n        // Save the new _rankedBidCount value\\n        _rankedBidCount = rankedBidCount;\\n\\n        // Save the new cursor position\\n        _resumeIdxRB = resumeIdx;\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //            \\u2b50\\ufe0f Step 3/4: Compute Ranked Won Quantities O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #3.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The maximum progress value for the step #3 which is equal to `_bidCount`.\\n     * (`progress` + `iter` <= `progressMax`)\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x lt(euint256, euint256)  : 1 x 231_000\\n     * - 1x gt(euint256, euint256)  : 1 x 231_000\\n     * - 1x and                     : 1 x  44_000\\n     * - 1x sub(euint256, euint256) : 1 x 253_000\\n     * - 1x min(euint256, euint256) : 1 x 277_000\\n     * - 1x add(euint256, euint256) : 1 x 253_000\\n     * - 2x select(euint256)        : 2 x  90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 1_469_000\\n     */\\n    function _runStep3(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        // Average gas cost:\\n        // - first iteration : 113_000 gas\\n        // - single iteration : 225_000 gas\\n        if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Debug\\n        if (!(_rankedBidCount == _bidCount && _rankedBids.length >= _bidCount)) revert DebugEngineError(11);\\n\\n        uint16 from = uint16(progress);\\n        uint16 to = uint16(from + iter);\\n\\n        address auctionAddr = address(_auction());\\n        euint256 cumulativeQuantity;\\n        euint256 uniformPrice;\\n\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        if (from == 0) {\\n            cumulativeQuantity = _rankedBids[0].quantity;\\n            uniformPrice = _rankedBids[0].price;\\n\\n            euint256 wonQuantity = TFHE.min(cumulativeQuantity, _totalQuantity);\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[0].id, auctionAddr);\\n            TFHE.allow(_rankedBids[0].price, auctionAddr);\\n\\n            _rankedWonQuantities[0] = wonQuantity;\\n\\n            if (to == 1) {\\n                _cumulativeQuantity = cumulativeQuantity;\\n                _uniformPrice = uniformPrice;\\n\\n                if (to == progressMax) {\\n                    TFHE.allow(uniformPrice, auctionAddr);\\n                    code = S_FINISHED;\\n                    _wonQuantitiesByRankReady = true;\\n                }\\n\\n                return (code, 1);\\n            }\\n\\n            from = 1;\\n            count = 1;\\n        } else {\\n            // Gas cost ~= 4_000\\n            cumulativeQuantity = _cumulativeQuantity;\\n            uniformPrice = _uniformPrice;\\n        }\\n\\n        // Here: 1 <= from < to\\n\\n        // Possible gas cost from start up to this point:\\n        //   - Branch #1 : 13_000 gas (from != 0)\\n        //   - Branch #2 : 73_000 gas (from == 0 && to != 1)\\n        //\\n        // 1x loop iter ~= 155_000 gas\\n        // After loop ~= 60_000 gas\\n        for (uint16 k = from; k < to; ++k) {\\n            if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            euint256 bidQuantity = _rankedBids[k].quantity;\\n            euint256 bidPrice = _rankedBids[k].price;\\n\\n            // Formula:\\n            // Wk = (C(k-1) < Q) ? min(Q - C(k-1), q_k) : 0\\n            ebool isValid = TFHE.lt(cumulativeQuantity, _totalQuantity);\\n\\n            // Price = 0 means the bid is invalid\\n            // pk = 0 => qk = 0\\n            isValid = TFHE.and(isValid, TFHE.gt(bidPrice, _eZeroU256));\\n\\n            euint256 remainingQuantity = TFHE.sub(_totalQuantity, cumulativeQuantity);\\n            euint256 wonQuantity = TFHE.select(isValid, TFHE.min(remainingQuantity, bidQuantity), _eZeroU256);\\n\\n            cumulativeQuantity = TFHE.add(cumulativeQuantity, bidQuantity);\\n            uniformPrice = TFHE.select(isValid, bidPrice, uniformPrice);\\n\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[k].id, auctionAddr);\\n            TFHE.allow(_rankedBids[k].price, auctionAddr);\\n\\n            _rankedWonQuantities[k] = wonQuantity;\\n\\n            count++;\\n        }\\n\\n        // Allow cost ~= 48_000 gas\\n        if (count > 0) {\\n            TFHE.allowThis(cumulativeQuantity);\\n            TFHE.allowThis(uniformPrice);\\n        }\\n\\n        // Storage cost ~= 9_000 gas\\n        _cumulativeQuantity = cumulativeQuantity;\\n        _uniformPrice = uniformPrice;\\n\\n        // Debug\\n        if (!(progress + count <= progressMax)) revert DebugEngineError(13);\\n\\n        if (progress + count == progressMax) {\\n            TFHE.allow(uniformPrice, auctionAddr);\\n            code = S_FINISHED;\\n            _wonQuantitiesByRankReady = true;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //        \\u2b50\\ufe0f Step 4/4: Compute Won Quantities O(N^2) (Optional) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `iter` iteration cycles for the step #4.\\n     * see function {computeValidation}\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x eq(euint16, euint16)  : 1 x 54_000\\n     * - 1x select(euint16)       : 1 x 47_000\\n     *\\n     * Total FHE Gas Cost per iteration : 101_000\\n     */\\n    function _runStep4(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 idxWQ = _idxWQ;\\n        uint16 resumeIdxWQ = _resumeIdxWQ;\\n        euint256 quantity = _quantityWQ;\\n\\n        // Debug\\n        if (\\n            !(\\n                idxWQ < _bidCount && resumeIdxWQ < _bidCount\\n                    && (idxWQ * _bidCount + resumeIdxWQ + iter <= _bidCount * _bidCount)\\n            )\\n        ) {\\n            revert DebugEngineError(14);\\n        }\\n        // Debug\\n        if (!(progress == idxWQ * _bidCount + resumeIdxWQ)) revert DebugEngineError(15);\\n\\n        uint16 idx = idxWQ;\\n        uint16 resumeIdx = resumeIdxWQ;\\n        uint32 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n        address auctionAddr = address(_auction());\\n\\n        while (count < iter) {\\n            ebool eq_id = TFHE.eq(_rankedBids[resumeIdx].id, _indexPlusOneToId[idx + 1]);\\n            quantity = TFHE.select(eq_id, _rankedWonQuantities[resumeIdx], quantity);\\n\\n            resumeIdx++;\\n\\n            if (resumeIdx == _bidCount) {\\n                // store won quantity\\n                _wonQuantities[idx] = quantity;\\n                TFHE.allowThis(quantity);\\n                TFHE.allow(quantity, auctionAddr);\\n\\n                // reset cursor\\n                idx += 1;\\n                resumeIdx = 0;\\n                quantity = _eZeroU256;\\n            }\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            // Debug\\n            if (!(idx == _bidCount && resumeIdx == 0)) revert DebugEngineError(18);\\n\\n            //could be removed\\n            _idxWQ = _bidCount;\\n            //not necessary ?\\n            //_resumeIdxWQ = 0;\\n            _wonQuantitiesByIdReady = true;\\n\\n            return (S_FINISHED, count);\\n        }\\n\\n        // Debug\\n        if (!(idx < _bidCount)) revert DebugEngineError(19);\\n\\n        if (resumeIdx != resumeIdxWQ) {\\n            _resumeIdxWQ = resumeIdx;\\n        }\\n\\n        if (idx != idxWQ) {\\n            _idxWQ = idx;\\n        }\\n\\n        _quantityWQ = quantity;\\n        TFHE.allowThis(quantity);\\n\\n        return (code, count);\\n    }\\n\\n    /**\\n     * @dev Returns the encrypted bid ranked at position `rank`.\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _rankedBidAt(uint16 rank) internal view returns (ABid storage bid) {\\n        bid = _rankedBids[rank];\\n    }\\n\\n    /**\\n     * @dev Sets the encrypted bid ranked at position `rank`\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _setRankedBidAt(uint16 rank, ABid memory newBid) internal {\\n        _rankedBids[rank] = newBid;\\n        _allowBid(newBid);\\n    }\\n\\n    /**\\n     * @dev Grants the engine permission to access the encrypted bid values (`price`, `quantity`, `id`, `rand`).\\n     */\\n    function _allowBid(ABid memory bid_) private {\\n        TFHE.allowThis(bid_.price);\\n        TFHE.allowThis(bid_.quantity);\\n        TFHE.allowThis(bid_.id);\\n        if (TFHE.isInitialized(bid_.rand)) {\\n            TFHE.allowThis(bid_.rand);\\n        }\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //               \\u2b50\\ufe0f IFourStepsIterable implementation \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep1(progress, iter, progressMax);\\n    }\\n\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep2(progress, iter, progressMax);\\n    }\\n\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep3(progress, iter, progressMax);\\n    }\\n\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep4(progress, iter, progressMax);\\n    }\\n}\\n\",\"keccak256\":\"0x9626d0da8f56de96a981fd9d57f69df68d4b6dab26e1a9aef31e369e5452e929\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngineIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FourStepsIterator, IFourStepsIterable} from \\\"../FourStepsIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"./FHEAuctionEngine.sol\\\";\\n\\n// For better readability, steps are named using a one-based index.\\nuint8 constant STEP_1_VALIDATION = 0;\\nuint8 constant STEP_2_SORT = 1;\\nuint8 constant STEP_3_WON_QUANTITIES_BY_RANK = 2;\\nuint8 constant STEP_4_WON_QUANTITIES_BY_ID = 3;\\n\\ncontract FHEAuctionEngineIterator is FourStepsIterator {\\n    constructor(address initialOwner) FourStepsIterator(initialOwner) {}\\n\\n    function initializeFourSteps(\\n        uint16 bidCount,\\n        uint32 step1UnitFheGasCost,\\n        uint32 step2UnitFheGasCost,\\n        uint32 step3UnitFheGasCost,\\n        uint32 step4UnitFheGasCost,\\n        bool onlyAward\\n    ) external onlyOwner {\\n        FourStepsIterator.Step[] memory fourSteps = new FourStepsIterator.Step[](4);\\n\\n        fourSteps[0].size = bidCount;\\n        fourSteps[0].nativeGasWeight = 1;\\n        fourSteps[0].unitFheGasCost = step1UnitFheGasCost;\\n\\n        fourSteps[1].size = (bidCount == 0) ? 0 : ((bidCount < 3) ? 1 : bidCount * (bidCount - 1) / 2);\\n        fourSteps[1].nativeGasWeight = 2;\\n        fourSteps[1].unitFheGasCost = step2UnitFheGasCost;\\n\\n        fourSteps[2].size = bidCount;\\n        fourSteps[2].nativeGasWeight = 1;\\n        fourSteps[2].unitFheGasCost = step3UnitFheGasCost;\\n\\n        if (!onlyAward) {\\n            fourSteps[3].size = bidCount * bidCount;\\n            fourSteps[3].nativeGasWeight = 1;\\n            fourSteps[3].unitFheGasCost = step4UnitFheGasCost;\\n        }\\n\\n        _initializeFourSteps(fourSteps);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to award a prize to a winning bidder.\\n     */\\n    function minIterationsForPrizeAward() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to finalize the auction uniform price.\\n     */\\n    function minIterationsForUniformPrice() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice see {FHEAuctionEngine-computeAuctionIterations}\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        (code, startIterProgress, endIterProgress) =\\n            _next(iter, (stopIfReadyForBlindClaim) ? STEP_3_WON_QUANTITIES_BY_RANK : STEP_4_WON_QUANTITIES_BY_ID);\\n    }\\n}\\n\",\"keccak256\":\"0xfd70821f0ffa0b950485edec665316326625b6341b26eb8909512f09a39955a8\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/IFHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {euint16, euint256} from \\\"fhevm/lib/TFHE.sol\\\";\\n\\ninterface IFHEAuctionEngine {\\n    function canClaim() external view returns (bool);\\n    function canAward() external view returns (bool);\\n    function initialize(uint256 totalQuantity, uint16 maxBidCount) external;\\n    function close() external;\\n    function bidderId(address bidder) external view returns (uint16);\\n    function getBidderById(uint16 id) external view returns (address);\\n    function addBid(address bidder, euint256 inPrice, euint256 inQuantity) external;\\n    function removeBid(address bidder) external;\\n    function canDecryptUniformPrice() external view returns (bool);\\n    function getUniformPrice() external view returns (euint256);\\n    function validatedPriceAndWonQuantityById(uint16 id) external view returns (euint256, euint256);\\n    function totalQuantity() external view returns (uint256);\\n    function maximumPrice() external view returns (uint256);\\n    function getBidCount() external view returns (uint16);\\n    function getMaximumBidCount() external view returns (uint16);\\n    function getBidByBidder(address bidder) external view returns (uint16 id, euint256 price, euint256 quantity);\\n    function getWonBidByRank(uint16 rank) external view returns (euint16 id, euint256 price, euint256 quantity);\\n    function iterator() external view returns (address);\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress);\\n}\\n\",\"keccak256\":\"0x2c97e02f19538cd99254accab76d90494135f7d91aa6b6cdf2d08ae2d62802fe\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEngineFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIterator} from \\\"../FHEAuctionEngineIterator.sol\\\";\\nimport {FHEAuctionEngineIteratorFactory} from \\\"./FHEAuctionEngineIteratorFactory.sol\\\";\\n\\nabstract contract FHEAuctionEngineFactory is Ownable2Step {\\n    FHEAuctionEngineIteratorFactory _iteratorFactory;\\n\\n    constructor(FHEAuctionEngineIteratorFactory iteratorFactory_) Ownable(msg.sender) {\\n        _iteratorFactory = iteratorFactory_;\\n    }\\n\\n    /**\\n     * @dev Deploys a new FHEAuctionEngine contract.\\n     * - engine.owner() == `auctionAddr`\\n     */\\n    function createNewEngine(address auctionAddr) public returns (address) {\\n        // Constructor requirements:\\n        // - iterator.owner() == engine.owner()\\n        // Runtime requirements:\\n        // - iterator.owner() == address(engine)\\n        // - engine.owner() == auctionAddr\\n        address iteratorAddr = _iteratorFactory.createNewIterator(address(this));\\n        address engineAddr = _createNewEngine(address(this), iteratorAddr);\\n        Ownable(iteratorAddr).transferOwnership(engineAddr);\\n        Ownable(engineAddr).transferOwnership(auctionAddr);\\n        return engineAddr;\\n    }\\n\\n    /**\\n     * @dev Abstract function, should be implemented by derived contracts\\n     */\\n    function _createNewEngine(address auction_, address iterator_) internal virtual returns (address);\\n}\\n\",\"keccak256\":\"0xbc0bea47f763b3d3cf309694469dc390c49ff7a87f90640afb527cc41b1a8fe2\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIterator} from \\\"../FHEAuctionEngineIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"../FHEAuctionEngine.sol\\\";\\n\\ncontract FHEAuctionEngineIteratorFactory is Ownable2Step {\\n    constructor() Ownable(msg.sender) {}\\n\\n    function createNewIterator(address initialOwner) public virtual returns (address) {\\n        FHEAuctionEngineIterator iterator = new FHEAuctionEngineIterator(initialOwner);\\n        return address(iterator);\\n    }\\n}\\n\",\"keccak256\":\"0x542e17a2f1034da6fcc4749ec1d65e8036db67cea3ae4ed27fda6029e915cf42\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaGatewayConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Gateway} from \\\"../gateway/lib/Gateway.sol\\\";\\n\\n/**\\n * @title   ZamaGatewayConfig.\\n * @notice  This library returns the Gateway config for different networks\\n *          with the address of the Gateway contract, which is\\n *          deployed & maintained by Zama.\\n */\\nlibrary ZamaGatewayConfig {\\n    function getSepoliaConfig() internal pure returns (address) {\\n        return 0x33347831500F1e73f0ccCBb95c9f86B94d7b1123;\\n    }\\n\\n    function getEthereumConfig() internal pure returns (address) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaGatewayConfig\\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\\n *          provided by Zama on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer other Gateways that are deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaGatewayConfig {\\n    constructor() {\\n        Gateway.setGateway(ZamaGatewayConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaGatewayConfig\\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\\n *          provided by Zama on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer other Gateways that are deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaGatewayConfig {\\n    constructor() {\\n        Gateway.setGateway(ZamaGatewayConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0xbed8bc18db61ffeb5ee31f577ab636d8563df27554e0ca66c53534f0bd82ffbd\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/gateway/GatewayCaller.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"../lib/TFHE.sol\\\";\\nimport \\\"./lib/Gateway.sol\\\";\\n\\nabstract contract GatewayCaller {\\n    modifier onlyGateway() {\\n        require(msg.sender == Gateway.gatewayContractAddress());\\n        _;\\n    }\\n    mapping(uint256 => ebool[]) private paramsEBool;\\n    mapping(uint256 => euint4[]) private paramsEUint4;\\n    mapping(uint256 => euint8[]) private paramsEUint8;\\n    mapping(uint256 => euint16[]) private paramsEUint16;\\n    mapping(uint256 => euint32[]) private paramsEUint32;\\n    mapping(uint256 => euint64[]) private paramsEUint64;\\n    mapping(uint256 => eaddress[]) private paramsEAddress;\\n    mapping(uint256 => address[]) private paramsAddress;\\n    mapping(uint256 => uint256[]) private paramsUint256;\\n    mapping(uint256 => uint256[]) private requestedHandles;\\n\\n    constructor() {}\\n\\n    function addParamsEBool(uint256 requestID, ebool _ebool) internal {\\n        paramsEBool[requestID].push(_ebool);\\n    }\\n\\n    function addParamsEUint4(uint256 requestID, euint4 _euint4) internal {\\n        paramsEUint4[requestID].push(_euint4);\\n    }\\n\\n    function addParamsEUint8(uint256 requestID, euint8 _euint8) internal {\\n        paramsEUint8[requestID].push(_euint8);\\n    }\\n\\n    function addParamsEUint16(uint256 requestID, euint16 _euint16) internal {\\n        paramsEUint16[requestID].push(_euint16);\\n    }\\n\\n    function addParamsEUint32(uint256 requestID, euint32 _euint32) internal {\\n        paramsEUint32[requestID].push(_euint32);\\n    }\\n\\n    function addParamsEUint64(uint256 requestID, euint64 _euint64) internal {\\n        paramsEUint64[requestID].push(_euint64);\\n    }\\n\\n    function addParamsEAddress(uint256 requestID, eaddress _eaddress) internal {\\n        paramsEAddress[requestID].push(_eaddress);\\n    }\\n\\n    function addParamsAddress(uint256 requestID, address _address) internal {\\n        paramsAddress[requestID].push(_address);\\n    }\\n\\n    function addParamsUint256(uint256 requestID, uint256 _uint) internal {\\n        paramsUint256[requestID].push(_uint);\\n    }\\n\\n    function saveRequestedHandles(uint256 requestID, uint256[] memory handlesList) internal {\\n        require(requestedHandles[requestID].length == 0, \\\"requested handles already saved\\\");\\n        requestedHandles[requestID] = handlesList;\\n    }\\n\\n    function loadRequestedHandles(uint256 requestID) internal view returns (uint256[] memory) {\\n        require(requestedHandles[requestID].length != 0, \\\"requested handles were not saved for this requestID\\\");\\n        return requestedHandles[requestID];\\n    }\\n\\n    function getParamsEBool(uint256 requestID) internal view returns (ebool[] memory) {\\n        return paramsEBool[requestID];\\n    }\\n\\n    function getParamsEUint4(uint256 requestID) internal view returns (euint4[] memory) {\\n        return paramsEUint4[requestID];\\n    }\\n\\n    function getParamsEUint8(uint256 requestID) internal view returns (euint8[] memory) {\\n        return paramsEUint8[requestID];\\n    }\\n\\n    function getParamsEUint16(uint256 requestID) internal view returns (euint16[] memory) {\\n        return paramsEUint16[requestID];\\n    }\\n\\n    function getParamsEUint32(uint256 requestID) internal view returns (euint32[] memory) {\\n        return paramsEUint32[requestID];\\n    }\\n\\n    function getParamsEUint64(uint256 requestID) internal view returns (euint64[] memory) {\\n        return paramsEUint64[requestID];\\n    }\\n\\n    function getParamsEAddress(uint256 requestID) internal view returns (eaddress[] memory) {\\n        return paramsEAddress[requestID];\\n    }\\n\\n    function getParamsAddress(uint256 requestID) internal view returns (address[] memory) {\\n        return paramsAddress[requestID];\\n    }\\n\\n    function getParamsUint256(uint256 requestID) internal view returns (uint256[] memory) {\\n        return paramsUint256[requestID];\\n    }\\n}\\n\",\"keccak256\":\"0xd19fd7715f0c5b479bf0cd8e3108cc8da7deae2d4fc7fb5ab089ebf2d76a0652\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/gateway/lib/Gateway.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\nimport \\\"../../lib/Impl.sol\\\";\\n\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        address aclAddress,\\n        uint256[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes[] memory signatures\\n    ) external returns (bool);\\n}\\n\\ninterface IGatewayContract {\\n    function requestDecryption(\\n        uint256[] calldata ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue,\\n        uint256 maxTimestamp,\\n        bool passSignaturesToCaller\\n    ) external returns (uint256);\\n}\\n\\nstruct GatewayConfigStruct {\\n    address GatewayContractAddress;\\n}\\n\\nlibrary Gateway {\\n    // keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.GatewayConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant GatewayLocation = 0x93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700;\\n\\n    function getGetwayConfig() internal pure returns (GatewayConfigStruct storage $) {\\n        assembly {\\n            $.slot := GatewayLocation\\n        }\\n    }\\n\\n    function setGateway(address gatewayAddress) internal {\\n        GatewayConfigStruct storage $ = getGetwayConfig();\\n        $.GatewayContractAddress = gatewayAddress;\\n    }\\n\\n    function gatewayContractAddress() internal view returns (address) {\\n        GatewayConfigStruct storage $ = getGetwayConfig();\\n        return $.GatewayContractAddress;\\n    }\\n\\n    function toUint256(ebool newCT) internal pure returns (uint256 ct) {\\n        ct = ebool.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint4 newCT) internal pure returns (uint256 ct) {\\n        ct = euint4.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint8 newCT) internal pure returns (uint256 ct) {\\n        ct = euint8.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint16 newCT) internal pure returns (uint256 ct) {\\n        ct = euint16.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint32 newCT) internal pure returns (uint256 ct) {\\n        ct = euint32.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint64 newCT) internal pure returns (uint256 ct) {\\n        ct = euint64.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint128 newCT) internal pure returns (uint256 ct) {\\n        ct = euint128.unwrap(newCT);\\n    }\\n\\n    function toUint256(eaddress newCT) internal pure returns (uint256 ct) {\\n        ct = eaddress.unwrap(newCT);\\n    }\\n\\n    function toUint256(euint256 newCT) internal pure returns (uint256 ct) {\\n        ct = euint256.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes64 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes64.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes128 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes128.unwrap(newCT);\\n    }\\n\\n    function toUint256(ebytes256 newCT) internal pure returns (uint256 ct) {\\n        ct = ebytes256.unwrap(newCT);\\n    }\\n\\n    function requestDecryption(\\n        uint256[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue,\\n        uint256 maxTimestamp,\\n        bool passSignaturesToCaller\\n    ) internal returns (uint256 requestID) {\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        IACL($.ACLAddress).allowForDecryption(ctsHandles);\\n        GatewayConfigStruct storage $$ = getGetwayConfig();\\n        requestID = IGatewayContract($$.GatewayContractAddress).requestDecryption(\\n            ctsHandles,\\n            callbackSelector,\\n            msgValue,\\n            maxTimestamp,\\n            passSignaturesToCaller\\n        );\\n    }\\n\\n    /// @dev this function is supposed to be called inside the callback function if the dev wants the dApp contract to verify the signatures\\n    /// @dev this is useful to give dev the choice not to rely on trusting the GatewayContract.\\n    /// @notice this could be used only when signatures are made available to the callback, i.e when `passSignaturesToCaller` is set to true during request\\n    function verifySignatures(uint256[] memory handlesList, bytes[] memory signatures) internal returns (bool) {\\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\\n        uint256 length = getSignedDataLength(handlesList);\\n        bytes memory decryptedResult = new bytes(length);\\n        assembly {\\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\\n        }\\n        decryptedResult = shiftOffsets(decryptedResult, handlesList);\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                $.ACLAddress,\\n                handlesList,\\n                decryptedResult,\\n                signatures\\n            );\\n    }\\n\\n    function getSignedDataLength(uint256[] memory handlesList) private pure returns (uint256) {\\n        uint256 handlesListlen = handlesList.length;\\n        uint256 signedDataLength;\\n        for (uint256 i = 0; i < handlesListlen; i++) {\\n            uint8 typeCt = uint8(handlesList[i] >> 8);\\n            if (typeCt < 9) {\\n                signedDataLength += 32;\\n            } else if (typeCt == 9) {\\n                //ebytes64\\n                signedDataLength += 128;\\n            } else if (typeCt == 10) {\\n                //ebytes128\\n                signedDataLength += 192;\\n            } else if (typeCt == 11) {\\n                //ebytes256\\n                signedDataLength += 320;\\n            } else {\\n                revert(\\\"Unsupported handle type\\\");\\n            }\\n        }\\n        signedDataLength += 32; // add offset of signatures\\n        return signedDataLength;\\n    }\\n\\n    function shiftOffsets(bytes memory input, uint256[] memory handlesList) private pure returns (bytes memory) {\\n        uint256 numArgs = handlesList.length;\\n        for (uint256 i = 0; i < numArgs; i++) {\\n            uint8 typeCt = uint8(handlesList[i] >> 8);\\n            if (typeCt >= 9) {\\n                input = subToBytes32Slice(input, 32 * i); // because we append the signatures, all bytes offsets are shifted by 0x20\\n            }\\n        }\\n        input = remove32Slice(input, 32 * numArgs);\\n        return input;\\n    }\\n\\n    function subToBytes32Slice(bytes memory data, uint256 offset) private pure returns (bytes memory) {\\n        // @note: data is assumed to be more than 32+offset bytes long\\n        assembly {\\n            let ptr := add(add(data, 0x20), offset)\\n            let val := mload(ptr)\\n            val := sub(val, 0x20)\\n            mstore(ptr, val)\\n        }\\n        return data;\\n    }\\n\\n    function remove32Slice(bytes memory input, uint256 start) private pure returns (bytes memory) {\\n        // @note we assume start+32 is less than input.length\\n        bytes memory result = new bytes(input.length - 32);\\n\\n        for (uint256 i = 0; i < start; i++) {\\n            result[i] = input[i];\\n        }\\n\\n        for (uint256 i = start + 32; i < input.length; i++) {\\n            result[i - 32] = input[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x9585a649e3001a4b8768ab6e2597b416f680bcc537309cd50b60e023e9791318\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x89d4968cd956a8931f1a8a177b3bef1c6cf88a03665083db74430add50b88f21\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
  "bytecode": "0x608060405234801562000010575f80fd5b5060405162004d7438038062004d748339810160408190526200003391620004ab565b8033806200005b57604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b620000668162000429565b5080516001600160a01b0316156200016857336001600160a01b0316815f01516001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620000c2573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620000e8919062000543565b6001600160a01b0316146200011f57335b60405163118cdaa760e01b81526001600160a01b03909116600482015260240162000052565b80515f805260026020527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b80546001600160a01b0319166001600160a01b039092169190911790555b60208101516001600160a01b0316156200025157336001600160a01b031681602001516001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620001c7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620001ed919062000543565b6001600160a01b031614620002035733620000f9565b60208181015160015f5260029091527fe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e080546001600160a01b0319166001600160a01b039092169190911790555b60408101516001600160a01b0316156200033957336001600160a01b031681604001516001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620002b0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620002d6919062000543565b6001600160a01b031614620002ec5733620000f9565b604081015160025f8190526020527f679795a0195a1b76cdebb7c51d74e058aee92919b8c3389af86ef24535e8a28c80546001600160a01b0319166001600160a01b039092169190911790555b60608101516001600160a01b0316156200042157336001600160a01b031681606001516001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000398573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190620003be919062000543565b6001600160a01b031614620003d45733620000f9565b606081015160035f5260026020527f88601476d11616a71c5be67555bd1dff4b1cbf21533d2669b768b61518cfe1c380546001600160a01b0319166001600160a01b039092169190911790555b505062000568565b600180546001600160a01b0319169055620004448162000447565b50565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b038116811462000444575f80fd5b5f60808284031215620004bc575f80fd5b604051608081016001600160401b0381118282101715620004eb57634e487b7160e01b5f52604160045260245ffd5b6040528251620004fb8162000496565b815260208301516200050d8162000496565b60208201526040830151620005228162000496565b60408201526060830151620005378162000496565b60608201529392505050565b5f6020828403121562000554575f80fd5b8151620005618162000496565b9392505050565b6147fe80620005765f395ff3fe608060405234801562000010575f80fd5b5060043610620000c8575f3560e01c806379ba5097116200007b578063dd74b3c5116200005f578063dd74b3c51462000160578063e30c39781462000177578063f2fde38b1462000189575f80fd5b806379ba509714620001455780638da5cb5b146200014f575f80fd5b80632fd8a2cc11620000af5780632fd8a2cc1462000112578063715018a6146200012957806373cfc6b21462000135575f80fd5b806306661abd14620000cc5780632711e17e14620000e2575b5f80fd5b6004546040519081526020015b60405180910390f35b620000f9620000f336600462000984565b620001a0565b6040516001600160a01b039091168152602001620000d9565b620000f962000123366004620009d7565b62000235565b62000133620005b9565b005b60405160018152602001620000d9565b62000133620005d0565b5f546001600160a01b0316620000f9565b620000f96200017136600462000a7d565b62000618565b6001546001600160a01b0316620000f9565b620001336200019a36600462000ac1565b6200064e565b5f80620001af878787620006c1565b90505f620001bc62000711565b90505f8585604051602001620001dc929190918252602082015260400190565b60405160208183030381529060405290505f82826040516020016200020392919062000b0e565b6040516020818303038152906040529050620002278482805190602001206200073d565b9a9950505050505050505050565b5f805f620002458b8b8a620006c1565b5f818152600360205260409020549091506001600160a01b031615620002b25760405162461bcd60e51b815260206004820152601860248201527f61756374696f6e20616c7265616479206465706c6f796564000000000000000060448201526064015b60405180910390fd5b5f620002bd62000711565b90505f8686604051602001620002dd929190918252602082015260400190565b60405160208183030381529060405290505f82826040516020016200030492919062000b0e565b60405160208183030381529060405290505f620003298583805190602001206200073d565b905062000337858262000754565b620003445f8684620007fe565b9550806001600160a01b0316866001600160a01b031614620003cf5760405162461bcd60e51b815260206004820152602960248201527f50616e69633a2061756374696f6e4164647220213d20636f6d7075746564417560448201527f6374696f6e4164647200000000000000000000000000000000000000000000006064820152608401620002a9565b50505050505f620003f78660ff165f908152600260205260409020546001600160a01b031690565b6040516307e1c07160e41b81526001600160a01b0384811660048301529190911690637e1c0710906024016020604051808303815f875af11580156200043f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000465919062000b26565b60405163200bd8a760e11b81526001600160a01b0380831660048301528c811660248301528a81166044830152606482018c905261ffff8a1660848301529192508391821690634017b14e9060a4015f604051808303815f87803b158015620004cc575f80fd5b505af1158015620004df573d5f803e3d5ffd5b50505050806001600160a01b031663f2fde38b8e6040518263ffffffff1660e01b81526004016200051f91906001600160a01b0391909116815260200190565b5f604051808303815f87803b15801562000537575f80fd5b505af11580156200054a573d5f803e3d5ffd5b505050508b836001600160a01b03167f6d0657c00185a9844fd840f785fbf7c952fa429da72ae8962aa3fbf21e2d04a58d8c604051620005a09291906001600160a01b0392831681529116602082015260400190565b60405180910390a350909b9a5050505050505050505050565b620005c362000897565b620005ce5f620008c5565b565b60015433906001600160a01b031681146200060a5760405163118cdaa760e01b81526001600160a01b0382166004820152602401620002a9565b6200061581620008c5565b50565b5f620006446200062a858585620006c1565b5f908152600360205260409020546001600160a01b031690565b90505b9392505050565b6200065862000897565b600180546001600160a01b0383166001600160a01b03199091168117909155620006895f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f838383604051602001620006f2939291909283526001600160a01b03918216602084015216604082015260600190565b6040516020818303038152906040528051906020012090509392505050565b606060405180602001620007259062000961565b601f1982820381018352601f90910116604052919050565b5f6200074b838330620008e0565b90505b92915050565b5f828152600360205260409020546001600160a01b031615620007ba5760405162461bcd60e51b815260206004820152601860248201527f41756374696f6e20616c7265616479206465706c6f79656400000000000000006044820152606401620002a9565b5f82815260036020526040812080546001600160a01b0319166001600160a01b0384161790556004805460019290620007f590849062000b44565b90915550505050565b5f834710156200082b5760405163cf47918160e01b815247600482015260248101859052604401620002a9565b81515f036200084d57604051631328927760e21b815260040160405180910390fd5b8282516020840186f590503d1519811516156200086f576040513d5f823e3d81fd5b6001600160a01b038116620006475760405163b06ebf3d60e01b815260040160405180910390fd5b5f546001600160a01b03163314620005ce5760405163118cdaa760e01b8152336004820152602401620002a9565b600180546001600160a01b0319169055620006158162000912565b5f604051836040820152846020820152828152600b8101905060ff8153605590206001600160a01b0316949350505050565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b613c8d8062000b6583390190565b6001600160a01b038116811462000615575f80fd5b5f805f805f60a0868803121562000999575f80fd5b853594506020860135620009ad816200096f565b93506040860135620009bf816200096f565b94979396509394606081013594506080013592915050565b5f805f805f805f805f6101208a8c031215620009f1575f80fd5b8935620009fe816200096f565b985060208a0135975060408a013562000a17816200096f565b965060608a0135955060808a013562000a30816200096f565b945060a08a013561ffff8116811462000a47575f80fd5b935060c08a013560ff8116811462000a5d575f80fd5b8093505060e08a013591506101008a013590509295985092959850929598565b5f805f6060848603121562000a90575f80fd5b83359250602084013562000aa4816200096f565b9150604084013562000ab6816200096f565b809150509250925092565b5f6020828403121562000ad2575f80fd5b813562000647816200096f565b5f81515f5b8181101562000b00576020818501810151868301520162000ae4565b505f93019283525090919050565b5f6200064462000b1f838662000adf565b8462000adf565b5f6020828403121562000b37575f80fd5b815162000647816200096f565b808201808211156200074e57634e487b7160e01b5f52601160045260245ffdfe60c060405234801562000010575f80fd5b5060405162003c8d38038062003c8d8339810160408190526200003391620002cf565b818133620001b2620000d6604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b80517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70080546001600160a01b0319167333347831500f1e73f0cccbb95c9f86b94d7b11231790556001600160a01b0381166200022657604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b620002318162000276565b50600160045581811115620002645760405163c5e0e1ed60e01b815260048101839052602481018290526044016200021d565b60a09190915260805250620002f29050565b600380546001600160a01b03838116610100818102610100600160a81b031985161790945560405193909204169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f8060408385031215620002e1575f80fd5b505080516020909101519092909150565b60805160a05161395d620003305f395f81816106d401528181610cc901528181612bfa0152612c3601525f818161061f0152612ae4015261395d5ff3fe60806040526004361061037c575f3560e01c80636b22ce24116101d3578063bb4872de116100fd578063d0aecc3a1161009d578063ec3090381161006d578063ec309038146109b0578063ec4e2727146109c7578063f2fde38b146109ed578063f7decfcc14610a0c575f80fd5b8063d0aecc3a14610968578063d0e30db01461097c578063e0f0541214610984578063e70b279d14610998575f80fd5b8063c7c3b1c1116100d8578063c7c3b1c114610905578063c9d4623f14610919578063cc42175a14610936578063cfc771b014610949575f80fd5b8063bb4872de146108c2578063bbe457ac146108d9578063bbeee6d1146108f1575f80fd5b8063844dc1191161017357806399fdb3201161014357806399fdb320146108535780639b357007146108705780639dce46121461088f578063b40a5627146108ae575f80fd5b8063844dc119146107e25780638da5cb5b14610809578063938328361461082b5780639435c8871461083f575f80fd5b8063715018a6116101ae578063715018a61461078957806373cfc6b21461079d57806378e97925146107b057806381cee591146107c3575f80fd5b80636b22ce24146106f85780636dc7a6271461074157806370a0823114610755575f80fd5b806338af3eed116102b45780634e80b9e41161025457806359bc783f1161022457806359bc783f1461067f5780635c94cb0c1461069e57806362b86754146106b2578063636bfbab146106c6575f80fd5b80634e80b9e4146106115780634e8602bd146106435780634fef7c3314610657578063597e1fb51461066b575f80fd5b806347535d7b1161028f57806347535d7b146105b65780634b585d2d146105ca5780634e6719ac146105e95780634e71d92d146105fd575f80fd5b806338af3eed1461055257806339bf9a77146105835780634017b14e14610597575f80fd5b806326562dac1161031f57806329e9e72c116102fa57806329e9e72c146104d65780632de40ce31461050b5780632e1a7d4d1461051f5780633197cbb61461053e575f80fd5b806326562dac1461045b5780632743c6951461049557806327c1c21d146104c2575f80fd5b80630c08bf881161035a5780630c08bf88146103f6578063158ef93e1461040a578063194307bf1461042057806323e45f6214610439575f80fd5b806302dda9cf1461038057806307da68f5146103a9578063099a019d146103bf575b5f80fd5b34801561038b575f80fd5b50610394610a2b565b60405190151581526020015b60405180910390f35b3480156103b4575f80fd5b506103bd610a66565b005b3480156103ca575f80fd5b50335f9081526017602052604090208054600190910154604080519283526020830191909152016103a0565b348015610401575f80fd5b506103bd610aec565b348015610415575f80fd5b506002541515610394565b34801561042b575f80fd5b506002546008161515610394565b348015610444575f80fd5b5061044d610b86565b6040519081526020016103a0565b348015610466575f80fd5b50610394610475366004613420565b6001600160a01b03165f9081526015602052604090205460ff1660011490565b3480156104a0575f80fd5b506104a9610bf1565b60405167ffffffffffffffff90911681526020016103a0565b3480156104cd575f80fd5b5061044d610c5c565b3480156104e1575f80fd5b506103946104f036600461344a565b61ffff165f9081526016602052604090205460ff1660011490565b348015610516575f80fd5b50610394610c65565b34801561052a575f80fd5b506103bd610539366004613465565b610c6f565b348015610549575f80fd5b5060015461044d565b34801561055d575f80fd5b506011546001600160a01b03165b6040516001600160a01b0390911681526020016103a0565b34801561058e575f80fd5b506103bd610e5b565b3480156105a2575f80fd5b506103bd6105b136600461347c565b610ff4565b3480156105c1575f80fd5b50610394611279565b3480156105d5575f80fd5b506103bd6105e43660046134ed565b61128a565b3480156105f4575f80fd5b5060135461044d565b348015610608575f80fd5b506103bd6112cf565b34801561061c575f80fd5b507f000000000000000000000000000000000000000000000000000000000000000061044d565b34801561064e575f80fd5b5061044d6114c4565b348015610662575f80fd5b506103bd6114d4565b348015610676575f80fd5b5061039461164e565b34801561068a575f80fd5b5061039461069936600461344a565b611659565b3480156106a9575f80fd5b506103946116b8565b3480156106bd575f80fd5b506104a9611755565b3480156106d1575f80fd5b507f000000000000000000000000000000000000000000000000000000000000000061044d565b348015610703575f80fd5b50610717610712366004613530565b61179c565b6040805160ff909416845267ffffffffffffffff92831660208501529116908201526060016103a0565b34801561074c575f80fd5b506103946118b8565b348015610760575f80fd5b5061044d61076f366004613420565b6001600160a01b03165f9081526018602052604090205490565b348015610794575f80fd5b506103bd6118ef565b3480156107a8575f80fd5b506001610394565b3480156107bb575f80fd5b505f5461044d565b3480156107ce575f80fd5b506103bd6107dd36600461344a565b611900565b3480156107ed575f80fd5b506107f6611979565b60405161ffff90911681526020016103a0565b348015610814575f80fd5b5060035461010090046001600160a01b031661056b565b348015610836575f80fd5b5061044d6119e4565b34801561084a575f80fd5b506103bd611a2b565b34801561085e575f80fd5b506012546001600160a01b031661056b565b34801561087b575f80fd5b506103bd61088a36600461355c565b611ad6565b34801561089a575f80fd5b506103bd6108a9366004613585565b611b32565b3480156108b9575f80fd5b506107f6611b6d565b3480156108cd575f80fd5b5060035460ff16610394565b3480156108e4575f80fd5b5060145461ffff166107f6565b3480156108fc575f80fd5b50610394611bb4565b348015610910575f80fd5b50610394611bcc565b348015610924575f80fd5b50600f546001600160a01b031661056b565b6103bd6109443660046135a5565b611c31565b348015610954575f80fd5b506103bd61096336600461361e565b611c8f565b348015610973575f80fd5b50610394611cf2565b6103bd611d27565b34801561098f575f80fd5b506104a9611d41565b3480156109a3575f80fd5b50601b5461ffff166107f6565b3480156109bb575f80fd5b50600254600114610394565b3480156109d2575f80fd5b50335f908152601c602052604090205461ffff161515610394565b3480156109f8575f80fd5b506103bd610a07366004613420565b611d88565b348015610a17575f80fd5b506103bd610a263660046135a5565b611dc2565b5f610a3461164e565b610a51576040516345a5a96f60e11b815260040160405180910390fd5b610a59611de9565b610a61611e10565b905090565b610a6e611e19565b610a76611e4c565b610a7e611e76565b600f5f9054906101000a90046001600160a01b03166001600160a01b03166343d726d66040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610aca575f80fd5b505af1158015610adc573d5f803e3d5ffd5b50505050610aea6001600455565b565b610af4611e19565b610afc611e4c565b610b04611ea2565b6011546012546040516370a0823160e01b8152306004820152610b7c926001600160a01b039081169216906370a0823190602401602060405180830381865afa158015610b53573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b779190613658565b611edf565b610aea6001600455565b600f54604080516311f22fb160e11b815290515f926001600160a01b0316916323e45f629160048083019260209291908290030181865afa158015610bcd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a619190613658565b60105460408051631606240760e01b815290515f926001600160a01b03169163160624079160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a61919061366f565b5f610a616120b9565b5f610a61336120dd565b610c77611e4c565b6002610c816120b9565b1615610ca057604051636f312cbd60e01b815260040160405180910390fd5b335f610cab826120dd565b6001600160a01b0383165f90815260186020526040902054909150807f00000000000000000000000000000000000000000000000000000000000000008315610d8e57610cf6612155565b80831015610d81578215610d775760405162461bcd60e51b815260206004820152602a60248201527f50616e69633a2062616c616e6365203e20302026262062616c616e6365203c2060448201527f6d696e4465706f7369740000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b5050505050610e4e565b610d8b818361369e565b91505b81861115610d9a578195505b855f03610dab575050505050610e4e565b610db5858761217d565b8315610e48576001600160a01b0385165f90815260186020526040902054811115610e485760405162461bcd60e51b815260206004820152602560248201527f50616e69633a205f62616c616e6365735b6269646465725d203c206d696e446560448201527f706f7369740000000000000000000000000000000000000000000000000000006064820152608401610d6e565b50505050505b610e586001600455565b50565b610e63611e4c565b600254610e83576040516321c4e35760e21b815260040160405180910390fd5b600f5460408051634377536160e11b815290515f926001600160a01b0316916386eea6c29160048083019260209291908290030181865afa158015610eca573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610eee9190613658565b905080610f0e5760405163ce346a3560e01b815260040160405180910390fd5b610f188130612188565b610f8a5760405162461bcd60e51b815260206004820152603160248201527f50616e69633a20544648452e6973416c6c6f7765642870752c2061646472657360448201527f7328746869732929203d3d2066616c73650000000000000000000000000000006064820152608401610d6e565b6040805160018082528183019092525f916020808301908036833701905050905081815f81518110610fbe57610fbe6136b1565b6020908102919091010152610fe781634ee7230960e11b5f610fe14260646136c5565b5f61219a565b505050610aea6001600455565b610ffc611e19565b611004611e4c565b6001600160a01b038516158061108b5750306001600160a01b0316856001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561105b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107f91906136d8565b6001600160a01b031614155b156110b45760405163e9c5008f60e01b81526001600160a01b0386166004820152602401610d6e565b6001600160a01b0384166110e657604051631a3b45fd60e01b81526001600160a01b0385166004820152602401610d6e565b6001600160a01b03831661111857604051630db57ed560e01b81526001600160a01b0384166004820152602401610d6e565b815f0361113b57604051630ea0fe6d60e21b815260048101839052602401610d6e565b6111436122c4565b600f80546001600160a01b0387811673ffffffffffffffffffffffffffffffffffffffff199283168117909355601180548883169084161790556012805491871691909216179055604051631f29034760e21b81526004810184905261ffff83166024820152637ca40d1c906044015f604051808303815f87803b1580156111c9575f80fd5b505af11580156111db573d5f803e3d5ffd5b50505050846001600160a01b031663fddcc1486040518163ffffffff1660e01b8152600401602060405180830381865afa15801561121b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061123f91906136d8565b6010805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b039290921691909117905560016004555b5050505050565b5f60036112846120b9565b14905090565b611292611e19565b61129a611e4c565b6112a482826122ec565b6011546112c1906001600160a01b03166112bc6119e4565b61235b565b6112cb6001600455565b5050565b6112d7611e4c565b6112df61164e565b6112fc576040516345a5a96f60e11b815260040160405180910390fd5b600f546040516302f64cdf60e41b81523360048201819052915f916001600160a01b0390911690632f64cdf090602401602060405180830381865afa158015611347573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061136b91906136f3565b90508061ffff165f0361139b57604051626866c760e21b81526001600160a01b0383166004820152602401610d6e565b6113bf826001600160a01b03165f9081526015602052604090205460ff1660011490565b156113e857604051632058b6db60e01b81526001600160a01b0383166004820152602401610d6e565b6113f061253e565b6114185760405163096b647560e11b81526001600160a01b0383166004820152602401610d6e565b600f54604051630de7056b60e01b815261ffff831660048201525f9182916001600160a01b0390911690630de7056b906024016040805180830381865afa158015611465573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611489919061370e565b91509150805f036114b85760405163096b647560e11b81526001600160a01b0385166004820152602401610d6e565b610adc8484848461254f565b5f8054600154610a61919061369e565b6114dc611e4c565b6114e461164e565b611501576040516345a5a96f60e11b815260040160405180910390fd5b335f818152601c602052604081205461ffff1690819003611615575f61152f600f546001600160a01b031690565b6040516302f64cdf60e41b81526001600160a01b0385811660048301529190911690632f64cdf090602401602060405180830381865afa158015611575573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061159991906136f3565b90508061ffff165f036115c957604051626866c760e21b81526001600160a01b0384166004820152602401610d6e565b601b546115db9061ffff166001613730565b6001600160a01b0384165f908152601c60205260409020805461ffff831661ffff199182168117909255601b805490911690911790559150505b6116236104f0600183613752565b1561162f575050610b7c565b61164261163d600183613752565b612605565b5050610aea6001600455565b5f60076112846120b9565b5f61166261164e565b61167f576040516345a5a96f60e11b815260040160405180910390fd5b61169e8261ffff165f9081526016602052604090205460ff1660011490565b156116aa57505f919050565b6116b26126ce565b92915050565b5f6116c4600254151590565b6116e1576040516321c4e35760e21b815260040160405180910390fd5b600f5f9054906101000a90046001600160a01b03166001600160a01b0316635c94cb0c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611731573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a61919061376d565b601054604080516318ae19d560e21b815290515f926001600160a01b0316916362b867549160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b5f805f6117a761164e565b6117c4576040516345a5a96f60e11b815260040160405180910390fd5b6117cc611e4c565b600f5460405163b189087960e01b815267ffffffffffffffff8716600482015285151560248201526001600160a01b039091169063b1890879906044016060604051808303815f875af1158015611825573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118499190613788565b6040805167ffffffffffffffff8a8116825260ff861660208301528481168284015283166060820152905193965091945092507f443e8452f1c9d1c508dd3e09780601c68bb958bf63e7dfc2b9997c0424a31aab919081900360800190a16118b16001600455565b9250925092565b5f6118c161164e565b6118de576040516345a5a96f60e11b815260040160405180910390fd5b6118e6611de9565b610a613361274a565b6118f7611e19565b610aea5f612802565b611908611e4c565b61191061164e565b61192d576040516345a5a96f60e11b815260040160405180910390fd5b61194c8161ffff165f9081526016602052604090205460ff1660011490565b1561197057604051635a18208d60e11b815261ffff82166004820152602401610d6e565b610e4e81612605565b600f546040805163c15bd28f60e01b815290515f926001600160a01b03169163c15bd28f9160048083019260209291908290030181865afa1580156119c0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a6191906136f3565b600f546040805163630b7a0960e11b815290515f926001600160a01b03169163c616f4129160048083019260209291908290030181865afa158015610bcd573d5f803e3d5ffd5b611a33611e4c565b611a3b612155565b611a43611de9565b6040805180820182525f808252602080830182815233808452601790925291849020925183559051600190920191909155600f549151631a6c4ac160e31b815260048101919091526001600160a01b039091169063d3625608906024015f604051808303815f87803b158015611ab7575f80fd5b505af1158015611ac9573d5f803e3d5ffd5b50505050610b7c33612872565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611b0b575f80fd5b5f83815260196020526040902054611b2d906001600160a01b03168383612895565b505050565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611b67575f80fd5b60135550565b600f546040805163147b524560e11b815290515f926001600160a01b0316916328f6a48a9160048083019260209291908290030181865afa1580156119c0573d5f803e3d5ffd5b5f6003600254148015610a6157505060035460ff1690565b6002545f90801580611bde5750600981145b80611be95750600f81145b15611bf5575f91505090565b5f611bfe6120b9565b90506003811480611c0f5750600781145b15611c2857611c1c612bbe565b611c28575f9250505090565b60019250505090565b611c39612155565b611c41611e4c565b335f81815260186020526040812054611c5b9034906136c5565b9050611c6681612bf8565b611c708234612c62565b611c7d8287878787612c92565b5050611c896001600455565b50505050565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611cc4575f80fd5b5f848152601a6020526040902054611cdf9061ffff16612e2b565b611c89611ceb84612ec3565b8383612895565b335f908152601c602052604081205461ffff16808203611d13575f91505090565b611d216104f0600183613752565b91505090565b611d2f612155565b611d37611e4c565b610b7c3334612c62565b6010546040805163175068fb60e11b815290515f926001600160a01b031691632ea0d1f69160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b611d90611e19565b6001600160a01b038116611db957604051631e4fbdf760e01b81525f6004820152602401610d6e565b610e5881612802565b611dca611e4c565b611dd2612155565b611ddf3385858585612c92565b611c896001600455565b611df2336120dd565b610aea57604051626866c760e21b8152336004820152602401610d6e565b5f610a616126ce565b6003546001600160a01b03610100909104163314610aea5760405163118cdaa760e01b8152336004820152602401610d6e565b600260045403611e6f57604051633ee5aeb560e01b815260040160405180910390fd5b6002600455565b611e7e611bb4565b611e9b57604051632db668c360e01b815260040160405180910390fd5b6007600255565b611eaa611bcc565b611ec757604051633437b5dd60e11b815260040160405180910390fd5b600160025403611ed8576009600255565b600f600255565b805f03611eea575050565b6012546040516370a0823160e01b81526001600160a01b0384811660048301525f9216906370a0823190602401602060405180830381865afa158015611f32573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611f569190613658565b60125460405163a9059cbb60e01b81526001600160a01b0386811660048301526024820186905292935091169063a9059cbb906044016020604051808303815f875af1158015611fa8573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611fcc919061376d565b506012546040516370a0823160e01b81526001600160a01b0385811660048301525f9216906370a0823190602401602060405180830381865afa158015612015573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906120399190613658565b905082612046838361369e565b14611c895760405162461bcd60e51b815260206004820152602e60248201527f50616e69633a2862616c616e63654166746572202d2062616c616e636542656660448201527f6f72652920213d20616d6f756e740000000000000000000000000000000000006064820152608401610d6e565b6002545f9060021981016120d85760015442106120d857600417919050565b919050565b600f546040516302f64cdf60e41b81526001600160a01b0383811660048301525f921690632f64cdf090602401602060405180830381865afa158015612125573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061214991906136f3565b61ffff16151592915050565b600361215f6120b9565b14610aea57604051631bb5f5b360e31b815260040160405180910390fd5b6112cb828383612f31565b5f6121938383612f45565b9392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600805460405163155f840160e21b81525f92916001600160a01b03169063557e1004906121eb908a90600401613811565b5f604051808303815f87803b158015612202575f80fd5b505af1158015612214573d5f803e3d5ffd5b505050505f6122407f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70090565b8054604051634c0d927760e01b81529192506001600160a01b031690634c0d927790612278908b908b908b908b908b90600401613823565b6020604051808303815f875af1158015612294573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122b89190613658565b98975050505050505050565b600254156122e55760405163aed5959560e01b815260040160405180910390fd5b6001600255565b60025460011461230f576040516310d50e4f60e21b815260040160405180910390fd5b815f0361232f57604051637616640160e01b815260040160405180910390fd5b6003600255425f8190556123449083906136c5565b6001556003805460ff191691151591909117905550565b805f03612366575050565b6012546040516370a0823160e01b81523060048201526001600160a01b03909116905f9082906370a0823190602401602060405180830381865afa1580156123b0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906123d49190613658565b6040516323b872dd60e01b81526001600160a01b038681166004830152306024830152604482018690529192505f918416906323b872dd906064016020604051808303815f875af115801561242b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061244f919061376d565b9050806124895760405163603bb82760e01b81526001600160a01b0380851660048301528616602482015260448101859052606401610d6e565b6040516370a0823160e01b81523060048201525f906001600160a01b038516906370a0823190602401602060405180830381865afa1580156124cd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124f19190613658565b9050846124fe848361369e565b146125365760405163603bb82760e01b81526001600160a01b0380861660048301528716602482015260448101869052606401610d6e565b505050505050565b5f8061254960135490565b11905090565b6040805160028082526060820183525f9260208301908036833701905050905082815f81518110612582576125826136b1565b602090810291909101015281816001815181106125a1576125a16136b1565b60209081029190910101525f6125c582639b35700760e01b83610fe14260646136c5565b5f908152601960205260409020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0397909716969096179095555050505050565b61260d6126ce565b61262a576040516370930e2960e11b815260040160405180910390fd5b600f54604051634ed1b02560e11b815261ffff831660048201525f91829182916001600160a01b031690639da3604a90602401606060405180830381865afa158015612678573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061269c919061387d565b925092509250805f036126c2576040516370930e2960e11b815260040160405180910390fd5b611c8984848484612fe4565b600f5460408051630185af3960e21b815290515f926001600160a01b031691630616bce49160048083019260209291908290030181865afa158015612715573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612739919061376d565b61274257505f90565b610a6161253e565b5f61276f826001600160a01b03165f9081526015602052604090205460ff1660011490565b1561277b57505f919050565b600f5f9054906101000a90046001600160a01b03166001600160a01b0316636dc7a6276040518163ffffffff1660e01b8152600401602060405180830381865afa1580156127cb573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127ef919061376d565b6127fa57505f919050565b6116b261253e565b600380546001600160a01b038381166101008181027fffffffffffffffffffffff0000000000000000000000000000000000000000ff85161790945560405193909204169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b6001600160a01b0381165f90815260186020526040902054610e5890829061217d565b6001600160a01b0383166128eb5760405162461bcd60e51b815260206004820152601260248201527f50616e69633a20626964646572203d3d203000000000000000000000000000006044820152606401610d6e565b6128f4836130a4565b5f6128fe60135490565b90505f811161294f5760405162461bcd60e51b815260206004820152601860248201527f50616e69633a20756e69666f726d5072696365203d3d203000000000000000006044820152606401610d6e565b825f036129ca5781156129ca5760405162461bcd60e51b815260206004820152603860248201527f50616e69633a20636c65617256616c6964617465645072696365203d3d20302060448201527f262620636c656172576f6e5175616e7469747920213d203000000000000000006064820152608401610d6e565b8115612adb575f6129db83836138a8565b90505f8111612a2c5760405162461bcd60e51b815260206004820152601b60248201527f50616e69633a20626964646572447565416d6f756e74203d3d203000000000006044820152606401610d6e565b6001600160a01b0385165f90815260186020526040902054811115612ab95760405162461bcd60e51b815260206004820152602a60248201527f50616e69633a205f62616c616e6365735b6269646465725d203c20626964646560448201527f72447565416d6f756e74000000000000000000000000000000000000000000006064820152608401610d6e565b612ad585612acf6011546001600160a01b031690565b83612f31565b50612b21565b825f03612b21577f00000000000000000000000000000000000000000000000000000000000000008015612b1f57612b1f85612acf6011546001600160a01b031690565b505b6001600160a01b0384165f908152601860205260409020548015612b4957612b49858261217d565b6001600160a01b0385165f9081526018602052604090205415612bae5760405162461bcd60e51b815260206004820152601c60248201527f50616e69633a205f62616c616e6365735b6269646465725d203e2030000000006044820152606401610d6e565b8215611272576112728584611edf565b5f612bc7611b6d565b60145461ffff90811691161480610a615750612be1611b6d565b60145462010000900461ffff908116911614905090565b7f0000000000000000000000000000000000000000000000000000000000000000811015610e585760405163012479f760e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610d6e565b6001600160a01b0382165f9081526018602052604081208054839290612c899084906136c5565b90915550505050565b612c9b85613125565b5f6040518060400160405280612ce68786868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061314692505050565b8152602001612d2a8686868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061314692505050565b9052600f5481519192506001600160a01b031690612d489082613153565b612d56826020015182613153565b600f54825160208401516040516305ba01f160e21b81526001600160a01b038b81166004830152602482019390935260448101919091529116906316e807c4906064015f604051808303815f87803b158015612db0575f80fd5b505af1158015612dc2573d5f803e3d5ffd5b50505050612dd3825f01518861315d565b612de182602001518861315d565b8151612dec90613167565b612df98260200151613167565b506001600160a01b039095165f9081526017602090815260409091208651815595015160019095019490945550505050565b612e4a8161ffff165f9081526016602052604090205460ff1660011490565b15612e6e57604051635a18208d60e11b815261ffff82166004820152602401610d6e565b61ffff8082165f908152601660205260409020805460ff1916600117905560148054620100009004909116906002612ea5836138bf565b91906101000a81548161ffff021916908361ffff1602179055505050565b600f546040516321a6832960e21b815261ffff831660048201525f916001600160a01b03169063869a0ca490602401602060405180830381865afa158015612f0d573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116b291906136d8565b612f3b8382613171565b611b2d8282613198565b5f807fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6008054604051632fd514cd60e11b8152600481018790526001600160a01b038681166024830152929350911690635faa299a90604401602060405180830381865afa158015612fb8573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612fdc919061376d565b949350505050565b604080516003808252608082019092525f916020820160608036833701905050905083815f81518110613019576130196136b1565b60209081029190910101528281600181518110613038576130386136b1565b60209081029190910101528181600281518110613057576130576136b1565b60209081029190910101525f61307b82630cfc771b60e41b83610fe14260646136c5565b5f908152601a60205260409020805461ffff191661ffff97909716969096179095555050505050565b6130c8816001600160a01b03165f9081526015602052604090205460ff1660011490565b156130f157604051632058b6db60e01b81526001600160a01b0382166004820152602401610d6e565b6001600160a01b0381165f908152601560205260408120805460ff191660011790556014805461ffff1691612ea5836138bf565b6001600160a01b0381165f90815260186020526040902054610e5890612bf8565b5f61219383836008613208565b6112cb828261332c565b6112cb82826133b3565b610e5881306133b3565b6001600160a01b0382165f9081526018602052604081208054839290612c8990849061369e565b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f81146131e1576040519150601f19603f3d011682016040523d82523d5f602084013e6131e6565b606091505b5050905080611b2d57604051631d42c86760e21b815260040160405180910390fd5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516302e817ff60e41b81525f917fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600916001600160a01b0390911690632e817ff0906132859088903390899060f88a901b906004016138df565b6020604051808303815f875af11580156132a1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906132c59190613658565b81546040516346ce4e4960e11b8152600481018390523360248201529193506001600160a01b031690638d9c9c92906044015f604051808303815f87803b15801561330e575f80fd5b505af1158015613320573d5f803e3d5ffd5b50505050509392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546040516346ce4e4960e11b8152600481018590526001600160a01b03848116602483015290911690638d9c9c92906044015b5f604051808303815f87803b158015613398575f80fd5b505af11580156133aa573d5f803e3d5ffd5b50505050505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6008054604051631974142760e21b8152600481018590526001600160a01b038481166024830152909116906365d0509c90604401613381565b6001600160a01b0381168114610e58575f80fd5b5f60208284031215613430575f80fd5b81356121938161340c565b61ffff81168114610e58575f80fd5b5f6020828403121561345a575f80fd5b81356121938161343b565b5f60208284031215613475575f80fd5b5035919050565b5f805f805f60a08688031215613490575f80fd5b853561349b8161340c565b945060208601356134ab8161340c565b935060408601356134bb8161340c565b92506060860135915060808601356134d28161343b565b809150509295509295909350565b8015158114610e58575f80fd5b5f80604083850312156134fe575f80fd5b823591506020830135613510816134e0565b809150509250929050565b67ffffffffffffffff81168114610e58575f80fd5b5f8060408385031215613541575f80fd5b823561354c8161351b565b91506020830135613510816134e0565b5f805f6060848603121561356e575f80fd5b505081359360208301359350604090920135919050565b5f8060408385031215613596575f80fd5b50508035926020909101359150565b5f805f80606085870312156135b8575f80fd5b8435935060208501359250604085013567ffffffffffffffff808211156135dd575f80fd5b818701915087601f8301126135f0575f80fd5b8135818111156135fe575f80fd5b88602082850101111561360f575f80fd5b95989497505060200194505050565b5f805f8060808587031215613631575f80fd5b8435935060208501356136438161343b565b93969395505050506040820135916060013590565b5f60208284031215613668575f80fd5b5051919050565b5f6020828403121561367f575f80fd5b81516121938161351b565b634e487b7160e01b5f52601160045260245ffd5b818103818111156116b2576116b261368a565b634e487b7160e01b5f52603260045260245ffd5b808201808211156116b2576116b261368a565b5f602082840312156136e8575f80fd5b81516121938161340c565b5f60208284031215613703575f80fd5b81516121938161343b565b5f806040838503121561371f575f80fd5b505080516020909101519092909150565b61ffff81811683821601908082111561374b5761374b61368a565b5092915050565b61ffff82811682821603908082111561374b5761374b61368a565b5f6020828403121561377d575f80fd5b8151612193816134e0565b5f805f6060848603121561379a575f80fd5b835160ff811681146137aa575f80fd5b60208501519093506137bb8161351b565b60408501519092506137cc8161351b565b809150509250925092565b5f815180845260208085019450602084015f5b83811015613806578151875295820195908201906001016137ea565b509495945050505050565b602081525f61219360208301846137d7565b60a081525f61383560a08301886137d7565b7fffffffff0000000000000000000000000000000000000000000000000000000096909616602083015250604081019390935260608301919091521515608090910152919050565b5f805f6060848603121561388f575f80fd5b8351925060208401519150604084015190509250925092565b80820281158282048414176116b2576116b261368a565b5f61ffff8083168181036138d5576138d561368a565b6001019392505050565b8481525f60206001600160a01b03861660208401526080604084015284518060808501525f5b818110156139215786810183015185820160a001528201613905565b505f60a0828601015260a0601f19601f8301168501019250505060ff60f81b831660608301529594505050505056fea164736f6c6343000818000aa164736f6c6343000818000a",
  "deployedBytecode": "0x608060405234801562000010575f80fd5b5060043610620000c8575f3560e01c806379ba5097116200007b578063dd74b3c5116200005f578063dd74b3c51462000160578063e30c39781462000177578063f2fde38b1462000189575f80fd5b806379ba509714620001455780638da5cb5b146200014f575f80fd5b80632fd8a2cc11620000af5780632fd8a2cc1462000112578063715018a6146200012957806373cfc6b21462000135575f80fd5b806306661abd14620000cc5780632711e17e14620000e2575b5f80fd5b6004546040519081526020015b60405180910390f35b620000f9620000f336600462000984565b620001a0565b6040516001600160a01b039091168152602001620000d9565b620000f962000123366004620009d7565b62000235565b62000133620005b9565b005b60405160018152602001620000d9565b62000133620005d0565b5f546001600160a01b0316620000f9565b620000f96200017136600462000a7d565b62000618565b6001546001600160a01b0316620000f9565b620001336200019a36600462000ac1565b6200064e565b5f80620001af878787620006c1565b90505f620001bc62000711565b90505f8585604051602001620001dc929190918252602082015260400190565b60405160208183030381529060405290505f82826040516020016200020392919062000b0e565b6040516020818303038152906040529050620002278482805190602001206200073d565b9a9950505050505050505050565b5f805f620002458b8b8a620006c1565b5f818152600360205260409020549091506001600160a01b031615620002b25760405162461bcd60e51b815260206004820152601860248201527f61756374696f6e20616c7265616479206465706c6f796564000000000000000060448201526064015b60405180910390fd5b5f620002bd62000711565b90505f8686604051602001620002dd929190918252602082015260400190565b60405160208183030381529060405290505f82826040516020016200030492919062000b0e565b60405160208183030381529060405290505f620003298583805190602001206200073d565b905062000337858262000754565b620003445f8684620007fe565b9550806001600160a01b0316866001600160a01b031614620003cf5760405162461bcd60e51b815260206004820152602960248201527f50616e69633a2061756374696f6e4164647220213d20636f6d7075746564417560448201527f6374696f6e4164647200000000000000000000000000000000000000000000006064820152608401620002a9565b50505050505f620003f78660ff165f908152600260205260409020546001600160a01b031690565b6040516307e1c07160e41b81526001600160a01b0384811660048301529190911690637e1c0710906024016020604051808303815f875af11580156200043f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019062000465919062000b26565b60405163200bd8a760e11b81526001600160a01b0380831660048301528c811660248301528a81166044830152606482018c905261ffff8a1660848301529192508391821690634017b14e9060a4015f604051808303815f87803b158015620004cc575f80fd5b505af1158015620004df573d5f803e3d5ffd5b50505050806001600160a01b031663f2fde38b8e6040518263ffffffff1660e01b81526004016200051f91906001600160a01b0391909116815260200190565b5f604051808303815f87803b15801562000537575f80fd5b505af11580156200054a573d5f803e3d5ffd5b505050508b836001600160a01b03167f6d0657c00185a9844fd840f785fbf7c952fa429da72ae8962aa3fbf21e2d04a58d8c604051620005a09291906001600160a01b0392831681529116602082015260400190565b60405180910390a350909b9a5050505050505050505050565b620005c362000897565b620005ce5f620008c5565b565b60015433906001600160a01b031681146200060a5760405163118cdaa760e01b81526001600160a01b0382166004820152602401620002a9565b6200061581620008c5565b50565b5f620006446200062a858585620006c1565b5f908152600360205260409020546001600160a01b031690565b90505b9392505050565b6200065862000897565b600180546001600160a01b0383166001600160a01b03199091168117909155620006895f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f838383604051602001620006f2939291909283526001600160a01b03918216602084015216604082015260600190565b6040516020818303038152906040528051906020012090509392505050565b606060405180602001620007259062000961565b601f1982820381018352601f90910116604052919050565b5f6200074b838330620008e0565b90505b92915050565b5f828152600360205260409020546001600160a01b031615620007ba5760405162461bcd60e51b815260206004820152601860248201527f41756374696f6e20616c7265616479206465706c6f79656400000000000000006044820152606401620002a9565b5f82815260036020526040812080546001600160a01b0319166001600160a01b0384161790556004805460019290620007f590849062000b44565b90915550505050565b5f834710156200082b5760405163cf47918160e01b815247600482015260248101859052604401620002a9565b81515f036200084d57604051631328927760e21b815260040160405180910390fd5b8282516020840186f590503d1519811516156200086f576040513d5f823e3d81fd5b6001600160a01b038116620006475760405163b06ebf3d60e01b815260040160405180910390fd5b5f546001600160a01b03163314620005ce5760405163118cdaa760e01b8152336004820152602401620002a9565b600180546001600160a01b0319169055620006158162000912565b5f604051836040820152846020820152828152600b8101905060ff8153605590206001600160a01b0316949350505050565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b613c8d8062000b6583390190565b6001600160a01b038116811462000615575f80fd5b5f805f805f60a0868803121562000999575f80fd5b853594506020860135620009ad816200096f565b93506040860135620009bf816200096f565b94979396509394606081013594506080013592915050565b5f805f805f805f805f6101208a8c031215620009f1575f80fd5b8935620009fe816200096f565b985060208a0135975060408a013562000a17816200096f565b965060608a0135955060808a013562000a30816200096f565b945060a08a013561ffff8116811462000a47575f80fd5b935060c08a013560ff8116811462000a5d575f80fd5b8093505060e08a013591506101008a013590509295985092959850929598565b5f805f6060848603121562000a90575f80fd5b83359250602084013562000aa4816200096f565b9150604084013562000ab6816200096f565b809150509250925092565b5f6020828403121562000ad2575f80fd5b813562000647816200096f565b5f81515f5b8181101562000b00576020818501810151868301520162000ae4565b505f93019283525090919050565b5f6200064462000b1f838662000adf565b8462000adf565b5f6020828403121562000b37575f80fd5b815162000647816200096f565b808201808211156200074e57634e487b7160e01b5f52601160045260245ffdfe60c060405234801562000010575f80fd5b5060405162003c8d38038062003c8d8339810160408190526200003391620002cf565b818133620001b2620000d6604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b80517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70080546001600160a01b0319167333347831500f1e73f0cccbb95c9f86b94d7b11231790556001600160a01b0381166200022657604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b620002318162000276565b50600160045581811115620002645760405163c5e0e1ed60e01b815260048101839052602481018290526044016200021d565b60a09190915260805250620002f29050565b600380546001600160a01b03838116610100818102610100600160a81b031985161790945560405193909204169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f8060408385031215620002e1575f80fd5b505080516020909101519092909150565b60805160a05161395d620003305f395f81816106d401528181610cc901528181612bfa0152612c3601525f818161061f0152612ae4015261395d5ff3fe60806040526004361061037c575f3560e01c80636b22ce24116101d3578063bb4872de116100fd578063d0aecc3a1161009d578063ec3090381161006d578063ec309038146109b0578063ec4e2727146109c7578063f2fde38b146109ed578063f7decfcc14610a0c575f80fd5b8063d0aecc3a14610968578063d0e30db01461097c578063e0f0541214610984578063e70b279d14610998575f80fd5b8063c7c3b1c1116100d8578063c7c3b1c114610905578063c9d4623f14610919578063cc42175a14610936578063cfc771b014610949575f80fd5b8063bb4872de146108c2578063bbe457ac146108d9578063bbeee6d1146108f1575f80fd5b8063844dc1191161017357806399fdb3201161014357806399fdb320146108535780639b357007146108705780639dce46121461088f578063b40a5627146108ae575f80fd5b8063844dc119146107e25780638da5cb5b14610809578063938328361461082b5780639435c8871461083f575f80fd5b8063715018a6116101ae578063715018a61461078957806373cfc6b21461079d57806378e97925146107b057806381cee591146107c3575f80fd5b80636b22ce24146106f85780636dc7a6271461074157806370a0823114610755575f80fd5b806338af3eed116102b45780634e80b9e41161025457806359bc783f1161022457806359bc783f1461067f5780635c94cb0c1461069e57806362b86754146106b2578063636bfbab146106c6575f80fd5b80634e80b9e4146106115780634e8602bd146106435780634fef7c3314610657578063597e1fb51461066b575f80fd5b806347535d7b1161028f57806347535d7b146105b65780634b585d2d146105ca5780634e6719ac146105e95780634e71d92d146105fd575f80fd5b806338af3eed1461055257806339bf9a77146105835780634017b14e14610597575f80fd5b806326562dac1161031f57806329e9e72c116102fa57806329e9e72c146104d65780632de40ce31461050b5780632e1a7d4d1461051f5780633197cbb61461053e575f80fd5b806326562dac1461045b5780632743c6951461049557806327c1c21d146104c2575f80fd5b80630c08bf881161035a5780630c08bf88146103f6578063158ef93e1461040a578063194307bf1461042057806323e45f6214610439575f80fd5b806302dda9cf1461038057806307da68f5146103a9578063099a019d146103bf575b5f80fd5b34801561038b575f80fd5b50610394610a2b565b60405190151581526020015b60405180910390f35b3480156103b4575f80fd5b506103bd610a66565b005b3480156103ca575f80fd5b50335f9081526017602052604090208054600190910154604080519283526020830191909152016103a0565b348015610401575f80fd5b506103bd610aec565b348015610415575f80fd5b506002541515610394565b34801561042b575f80fd5b506002546008161515610394565b348015610444575f80fd5b5061044d610b86565b6040519081526020016103a0565b348015610466575f80fd5b50610394610475366004613420565b6001600160a01b03165f9081526015602052604090205460ff1660011490565b3480156104a0575f80fd5b506104a9610bf1565b60405167ffffffffffffffff90911681526020016103a0565b3480156104cd575f80fd5b5061044d610c5c565b3480156104e1575f80fd5b506103946104f036600461344a565b61ffff165f9081526016602052604090205460ff1660011490565b348015610516575f80fd5b50610394610c65565b34801561052a575f80fd5b506103bd610539366004613465565b610c6f565b348015610549575f80fd5b5060015461044d565b34801561055d575f80fd5b506011546001600160a01b03165b6040516001600160a01b0390911681526020016103a0565b34801561058e575f80fd5b506103bd610e5b565b3480156105a2575f80fd5b506103bd6105b136600461347c565b610ff4565b3480156105c1575f80fd5b50610394611279565b3480156105d5575f80fd5b506103bd6105e43660046134ed565b61128a565b3480156105f4575f80fd5b5060135461044d565b348015610608575f80fd5b506103bd6112cf565b34801561061c575f80fd5b507f000000000000000000000000000000000000000000000000000000000000000061044d565b34801561064e575f80fd5b5061044d6114c4565b348015610662575f80fd5b506103bd6114d4565b348015610676575f80fd5b5061039461164e565b34801561068a575f80fd5b5061039461069936600461344a565b611659565b3480156106a9575f80fd5b506103946116b8565b3480156106bd575f80fd5b506104a9611755565b3480156106d1575f80fd5b507f000000000000000000000000000000000000000000000000000000000000000061044d565b348015610703575f80fd5b50610717610712366004613530565b61179c565b6040805160ff909416845267ffffffffffffffff92831660208501529116908201526060016103a0565b34801561074c575f80fd5b506103946118b8565b348015610760575f80fd5b5061044d61076f366004613420565b6001600160a01b03165f9081526018602052604090205490565b348015610794575f80fd5b506103bd6118ef565b3480156107a8575f80fd5b506001610394565b3480156107bb575f80fd5b505f5461044d565b3480156107ce575f80fd5b506103bd6107dd36600461344a565b611900565b3480156107ed575f80fd5b506107f6611979565b60405161ffff90911681526020016103a0565b348015610814575f80fd5b5060035461010090046001600160a01b031661056b565b348015610836575f80fd5b5061044d6119e4565b34801561084a575f80fd5b506103bd611a2b565b34801561085e575f80fd5b506012546001600160a01b031661056b565b34801561087b575f80fd5b506103bd61088a36600461355c565b611ad6565b34801561089a575f80fd5b506103bd6108a9366004613585565b611b32565b3480156108b9575f80fd5b506107f6611b6d565b3480156108cd575f80fd5b5060035460ff16610394565b3480156108e4575f80fd5b5060145461ffff166107f6565b3480156108fc575f80fd5b50610394611bb4565b348015610910575f80fd5b50610394611bcc565b348015610924575f80fd5b50600f546001600160a01b031661056b565b6103bd6109443660046135a5565b611c31565b348015610954575f80fd5b506103bd61096336600461361e565b611c8f565b348015610973575f80fd5b50610394611cf2565b6103bd611d27565b34801561098f575f80fd5b506104a9611d41565b3480156109a3575f80fd5b50601b5461ffff166107f6565b3480156109bb575f80fd5b50600254600114610394565b3480156109d2575f80fd5b50335f908152601c602052604090205461ffff161515610394565b3480156109f8575f80fd5b506103bd610a07366004613420565b611d88565b348015610a17575f80fd5b506103bd610a263660046135a5565b611dc2565b5f610a3461164e565b610a51576040516345a5a96f60e11b815260040160405180910390fd5b610a59611de9565b610a61611e10565b905090565b610a6e611e19565b610a76611e4c565b610a7e611e76565b600f5f9054906101000a90046001600160a01b03166001600160a01b03166343d726d66040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610aca575f80fd5b505af1158015610adc573d5f803e3d5ffd5b50505050610aea6001600455565b565b610af4611e19565b610afc611e4c565b610b04611ea2565b6011546012546040516370a0823160e01b8152306004820152610b7c926001600160a01b039081169216906370a0823190602401602060405180830381865afa158015610b53573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610b779190613658565b611edf565b610aea6001600455565b600f54604080516311f22fb160e11b815290515f926001600160a01b0316916323e45f629160048083019260209291908290030181865afa158015610bcd573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a619190613658565b60105460408051631606240760e01b815290515f926001600160a01b03169163160624079160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a61919061366f565b5f610a616120b9565b5f610a61336120dd565b610c77611e4c565b6002610c816120b9565b1615610ca057604051636f312cbd60e01b815260040160405180910390fd5b335f610cab826120dd565b6001600160a01b0383165f90815260186020526040902054909150807f00000000000000000000000000000000000000000000000000000000000000008315610d8e57610cf6612155565b80831015610d81578215610d775760405162461bcd60e51b815260206004820152602a60248201527f50616e69633a2062616c616e6365203e20302026262062616c616e6365203c2060448201527f6d696e4465706f7369740000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b5050505050610e4e565b610d8b818361369e565b91505b81861115610d9a578195505b855f03610dab575050505050610e4e565b610db5858761217d565b8315610e48576001600160a01b0385165f90815260186020526040902054811115610e485760405162461bcd60e51b815260206004820152602560248201527f50616e69633a205f62616c616e6365735b6269646465725d203c206d696e446560448201527f706f7369740000000000000000000000000000000000000000000000000000006064820152608401610d6e565b50505050505b610e586001600455565b50565b610e63611e4c565b600254610e83576040516321c4e35760e21b815260040160405180910390fd5b600f5460408051634377536160e11b815290515f926001600160a01b0316916386eea6c29160048083019260209291908290030181865afa158015610eca573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610eee9190613658565b905080610f0e5760405163ce346a3560e01b815260040160405180910390fd5b610f188130612188565b610f8a5760405162461bcd60e51b815260206004820152603160248201527f50616e69633a20544648452e6973416c6c6f7765642870752c2061646472657360448201527f7328746869732929203d3d2066616c73650000000000000000000000000000006064820152608401610d6e565b6040805160018082528183019092525f916020808301908036833701905050905081815f81518110610fbe57610fbe6136b1565b6020908102919091010152610fe781634ee7230960e11b5f610fe14260646136c5565b5f61219a565b505050610aea6001600455565b610ffc611e19565b611004611e4c565b6001600160a01b038516158061108b5750306001600160a01b0316856001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561105b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061107f91906136d8565b6001600160a01b031614155b156110b45760405163e9c5008f60e01b81526001600160a01b0386166004820152602401610d6e565b6001600160a01b0384166110e657604051631a3b45fd60e01b81526001600160a01b0385166004820152602401610d6e565b6001600160a01b03831661111857604051630db57ed560e01b81526001600160a01b0384166004820152602401610d6e565b815f0361113b57604051630ea0fe6d60e21b815260048101839052602401610d6e565b6111436122c4565b600f80546001600160a01b0387811673ffffffffffffffffffffffffffffffffffffffff199283168117909355601180548883169084161790556012805491871691909216179055604051631f29034760e21b81526004810184905261ffff83166024820152637ca40d1c906044015f604051808303815f87803b1580156111c9575f80fd5b505af11580156111db573d5f803e3d5ffd5b50505050846001600160a01b031663fddcc1486040518163ffffffff1660e01b8152600401602060405180830381865afa15801561121b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061123f91906136d8565b6010805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b039290921691909117905560016004555b5050505050565b5f60036112846120b9565b14905090565b611292611e19565b61129a611e4c565b6112a482826122ec565b6011546112c1906001600160a01b03166112bc6119e4565b61235b565b6112cb6001600455565b5050565b6112d7611e4c565b6112df61164e565b6112fc576040516345a5a96f60e11b815260040160405180910390fd5b600f546040516302f64cdf60e41b81523360048201819052915f916001600160a01b0390911690632f64cdf090602401602060405180830381865afa158015611347573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061136b91906136f3565b90508061ffff165f0361139b57604051626866c760e21b81526001600160a01b0383166004820152602401610d6e565b6113bf826001600160a01b03165f9081526015602052604090205460ff1660011490565b156113e857604051632058b6db60e01b81526001600160a01b0383166004820152602401610d6e565b6113f061253e565b6114185760405163096b647560e11b81526001600160a01b0383166004820152602401610d6e565b600f54604051630de7056b60e01b815261ffff831660048201525f9182916001600160a01b0390911690630de7056b906024016040805180830381865afa158015611465573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611489919061370e565b91509150805f036114b85760405163096b647560e11b81526001600160a01b0385166004820152602401610d6e565b610adc8484848461254f565b5f8054600154610a61919061369e565b6114dc611e4c565b6114e461164e565b611501576040516345a5a96f60e11b815260040160405180910390fd5b335f818152601c602052604081205461ffff1690819003611615575f61152f600f546001600160a01b031690565b6040516302f64cdf60e41b81526001600160a01b0385811660048301529190911690632f64cdf090602401602060405180830381865afa158015611575573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061159991906136f3565b90508061ffff165f036115c957604051626866c760e21b81526001600160a01b0384166004820152602401610d6e565b601b546115db9061ffff166001613730565b6001600160a01b0384165f908152601c60205260409020805461ffff831661ffff199182168117909255601b805490911690911790559150505b6116236104f0600183613752565b1561162f575050610b7c565b61164261163d600183613752565b612605565b5050610aea6001600455565b5f60076112846120b9565b5f61166261164e565b61167f576040516345a5a96f60e11b815260040160405180910390fd5b61169e8261ffff165f9081526016602052604090205460ff1660011490565b156116aa57505f919050565b6116b26126ce565b92915050565b5f6116c4600254151590565b6116e1576040516321c4e35760e21b815260040160405180910390fd5b600f5f9054906101000a90046001600160a01b03166001600160a01b0316635c94cb0c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611731573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a61919061376d565b601054604080516318ae19d560e21b815290515f926001600160a01b0316916362b867549160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b5f805f6117a761164e565b6117c4576040516345a5a96f60e11b815260040160405180910390fd5b6117cc611e4c565b600f5460405163b189087960e01b815267ffffffffffffffff8716600482015285151560248201526001600160a01b039091169063b1890879906044016060604051808303815f875af1158015611825573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906118499190613788565b6040805167ffffffffffffffff8a8116825260ff861660208301528481168284015283166060820152905193965091945092507f443e8452f1c9d1c508dd3e09780601c68bb958bf63e7dfc2b9997c0424a31aab919081900360800190a16118b16001600455565b9250925092565b5f6118c161164e565b6118de576040516345a5a96f60e11b815260040160405180910390fd5b6118e6611de9565b610a613361274a565b6118f7611e19565b610aea5f612802565b611908611e4c565b61191061164e565b61192d576040516345a5a96f60e11b815260040160405180910390fd5b61194c8161ffff165f9081526016602052604090205460ff1660011490565b1561197057604051635a18208d60e11b815261ffff82166004820152602401610d6e565b610e4e81612605565b600f546040805163c15bd28f60e01b815290515f926001600160a01b03169163c15bd28f9160048083019260209291908290030181865afa1580156119c0573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a6191906136f3565b600f546040805163630b7a0960e11b815290515f926001600160a01b03169163c616f4129160048083019260209291908290030181865afa158015610bcd573d5f803e3d5ffd5b611a33611e4c565b611a3b612155565b611a43611de9565b6040805180820182525f808252602080830182815233808452601790925291849020925183559051600190920191909155600f549151631a6c4ac160e31b815260048101919091526001600160a01b039091169063d3625608906024015f604051808303815f87803b158015611ab7575f80fd5b505af1158015611ac9573d5f803e3d5ffd5b50505050610b7c33612872565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611b0b575f80fd5b5f83815260196020526040902054611b2d906001600160a01b03168383612895565b505050565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611b67575f80fd5b60135550565b600f546040805163147b524560e11b815290515f926001600160a01b0316916328f6a48a9160048083019260209291908290030181865afa1580156119c0573d5f803e3d5ffd5b5f6003600254148015610a6157505060035460ff1690565b6002545f90801580611bde5750600981145b80611be95750600f81145b15611bf5575f91505090565b5f611bfe6120b9565b90506003811480611c0f5750600781145b15611c2857611c1c612bbe565b611c28575f9250505090565b60019250505090565b611c39612155565b611c41611e4c565b335f81815260186020526040812054611c5b9034906136c5565b9050611c6681612bf8565b611c708234612c62565b611c7d8287878787612c92565b5050611c896001600455565b50505050565b7f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700546001600160a01b03163314611cc4575f80fd5b5f848152601a6020526040902054611cdf9061ffff16612e2b565b611c89611ceb84612ec3565b8383612895565b335f908152601c602052604081205461ffff16808203611d13575f91505090565b611d216104f0600183613752565b91505090565b611d2f612155565b611d37611e4c565b610b7c3334612c62565b6010546040805163175068fb60e11b815290515f926001600160a01b031691632ea0d1f69160048083019260209291908290030181865afa158015610c38573d5f803e3d5ffd5b611d90611e19565b6001600160a01b038116611db957604051631e4fbdf760e01b81525f6004820152602401610d6e565b610e5881612802565b611dca611e4c565b611dd2612155565b611ddf3385858585612c92565b611c896001600455565b611df2336120dd565b610aea57604051626866c760e21b8152336004820152602401610d6e565b5f610a616126ce565b6003546001600160a01b03610100909104163314610aea5760405163118cdaa760e01b8152336004820152602401610d6e565b600260045403611e6f57604051633ee5aeb560e01b815260040160405180910390fd5b6002600455565b611e7e611bb4565b611e9b57604051632db668c360e01b815260040160405180910390fd5b6007600255565b611eaa611bcc565b611ec757604051633437b5dd60e11b815260040160405180910390fd5b600160025403611ed8576009600255565b600f600255565b805f03611eea575050565b6012546040516370a0823160e01b81526001600160a01b0384811660048301525f9216906370a0823190602401602060405180830381865afa158015611f32573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611f569190613658565b60125460405163a9059cbb60e01b81526001600160a01b0386811660048301526024820186905292935091169063a9059cbb906044016020604051808303815f875af1158015611fa8573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611fcc919061376d565b506012546040516370a0823160e01b81526001600160a01b0385811660048301525f9216906370a0823190602401602060405180830381865afa158015612015573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906120399190613658565b905082612046838361369e565b14611c895760405162461bcd60e51b815260206004820152602e60248201527f50616e69633a2862616c616e63654166746572202d2062616c616e636542656660448201527f6f72652920213d20616d6f756e740000000000000000000000000000000000006064820152608401610d6e565b6002545f9060021981016120d85760015442106120d857600417919050565b919050565b600f546040516302f64cdf60e41b81526001600160a01b0383811660048301525f921690632f64cdf090602401602060405180830381865afa158015612125573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061214991906136f3565b61ffff16151592915050565b600361215f6120b9565b14610aea57604051631bb5f5b360e31b815260040160405180910390fd5b6112cb828383612f31565b5f6121938383612f45565b9392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600805460405163155f840160e21b81525f92916001600160a01b03169063557e1004906121eb908a90600401613811565b5f604051808303815f87803b158015612202575f80fd5b505af1158015612214573d5f803e3d5ffd5b505050505f6122407f93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e70090565b8054604051634c0d927760e01b81529192506001600160a01b031690634c0d927790612278908b908b908b908b908b90600401613823565b6020604051808303815f875af1158015612294573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906122b89190613658565b98975050505050505050565b600254156122e55760405163aed5959560e01b815260040160405180910390fd5b6001600255565b60025460011461230f576040516310d50e4f60e21b815260040160405180910390fd5b815f0361232f57604051637616640160e01b815260040160405180910390fd5b6003600255425f8190556123449083906136c5565b6001556003805460ff191691151591909117905550565b805f03612366575050565b6012546040516370a0823160e01b81523060048201526001600160a01b03909116905f9082906370a0823190602401602060405180830381865afa1580156123b0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906123d49190613658565b6040516323b872dd60e01b81526001600160a01b038681166004830152306024830152604482018690529192505f918416906323b872dd906064016020604051808303815f875af115801561242b573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061244f919061376d565b9050806124895760405163603bb82760e01b81526001600160a01b0380851660048301528616602482015260448101859052606401610d6e565b6040516370a0823160e01b81523060048201525f906001600160a01b038516906370a0823190602401602060405180830381865afa1580156124cd573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906124f19190613658565b9050846124fe848361369e565b146125365760405163603bb82760e01b81526001600160a01b0380861660048301528716602482015260448101869052606401610d6e565b505050505050565b5f8061254960135490565b11905090565b6040805160028082526060820183525f9260208301908036833701905050905082815f81518110612582576125826136b1565b602090810291909101015281816001815181106125a1576125a16136b1565b60209081029190910101525f6125c582639b35700760e01b83610fe14260646136c5565b5f908152601960205260409020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0397909716969096179095555050505050565b61260d6126ce565b61262a576040516370930e2960e11b815260040160405180910390fd5b600f54604051634ed1b02560e11b815261ffff831660048201525f91829182916001600160a01b031690639da3604a90602401606060405180830381865afa158015612678573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061269c919061387d565b925092509250805f036126c2576040516370930e2960e11b815260040160405180910390fd5b611c8984848484612fe4565b600f5460408051630185af3960e21b815290515f926001600160a01b031691630616bce49160048083019260209291908290030181865afa158015612715573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612739919061376d565b61274257505f90565b610a6161253e565b5f61276f826001600160a01b03165f9081526015602052604090205460ff1660011490565b1561277b57505f919050565b600f5f9054906101000a90046001600160a01b03166001600160a01b0316636dc7a6276040518163ffffffff1660e01b8152600401602060405180830381865afa1580156127cb573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906127ef919061376d565b6127fa57505f919050565b6116b261253e565b600380546001600160a01b038381166101008181027fffffffffffffffffffffff0000000000000000000000000000000000000000ff85161790945560405193909204169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b6001600160a01b0381165f90815260186020526040902054610e5890829061217d565b6001600160a01b0383166128eb5760405162461bcd60e51b815260206004820152601260248201527f50616e69633a20626964646572203d3d203000000000000000000000000000006044820152606401610d6e565b6128f4836130a4565b5f6128fe60135490565b90505f811161294f5760405162461bcd60e51b815260206004820152601860248201527f50616e69633a20756e69666f726d5072696365203d3d203000000000000000006044820152606401610d6e565b825f036129ca5781156129ca5760405162461bcd60e51b815260206004820152603860248201527f50616e69633a20636c65617256616c6964617465645072696365203d3d20302060448201527f262620636c656172576f6e5175616e7469747920213d203000000000000000006064820152608401610d6e565b8115612adb575f6129db83836138a8565b90505f8111612a2c5760405162461bcd60e51b815260206004820152601b60248201527f50616e69633a20626964646572447565416d6f756e74203d3d203000000000006044820152606401610d6e565b6001600160a01b0385165f90815260186020526040902054811115612ab95760405162461bcd60e51b815260206004820152602a60248201527f50616e69633a205f62616c616e6365735b6269646465725d203c20626964646560448201527f72447565416d6f756e74000000000000000000000000000000000000000000006064820152608401610d6e565b612ad585612acf6011546001600160a01b031690565b83612f31565b50612b21565b825f03612b21577f00000000000000000000000000000000000000000000000000000000000000008015612b1f57612b1f85612acf6011546001600160a01b031690565b505b6001600160a01b0384165f908152601860205260409020548015612b4957612b49858261217d565b6001600160a01b0385165f9081526018602052604090205415612bae5760405162461bcd60e51b815260206004820152601c60248201527f50616e69633a205f62616c616e6365735b6269646465725d203e2030000000006044820152606401610d6e565b8215611272576112728584611edf565b5f612bc7611b6d565b60145461ffff90811691161480610a615750612be1611b6d565b60145462010000900461ffff908116911614905090565b7f0000000000000000000000000000000000000000000000000000000000000000811015610e585760405163012479f760e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610d6e565b6001600160a01b0382165f9081526018602052604081208054839290612c899084906136c5565b90915550505050565b612c9b85613125565b5f6040518060400160405280612ce68786868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061314692505050565b8152602001612d2a8686868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061314692505050565b9052600f5481519192506001600160a01b031690612d489082613153565b612d56826020015182613153565b600f54825160208401516040516305ba01f160e21b81526001600160a01b038b81166004830152602482019390935260448101919091529116906316e807c4906064015f604051808303815f87803b158015612db0575f80fd5b505af1158015612dc2573d5f803e3d5ffd5b50505050612dd3825f01518861315d565b612de182602001518861315d565b8151612dec90613167565b612df98260200151613167565b506001600160a01b039095165f9081526017602090815260409091208651815595015160019095019490945550505050565b612e4a8161ffff165f9081526016602052604090205460ff1660011490565b15612e6e57604051635a18208d60e11b815261ffff82166004820152602401610d6e565b61ffff8082165f908152601660205260409020805460ff1916600117905560148054620100009004909116906002612ea5836138bf565b91906101000a81548161ffff021916908361ffff1602179055505050565b600f546040516321a6832960e21b815261ffff831660048201525f916001600160a01b03169063869a0ca490602401602060405180830381865afa158015612f0d573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906116b291906136d8565b612f3b8382613171565b611b2d8282613198565b5f807fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6008054604051632fd514cd60e11b8152600481018790526001600160a01b038681166024830152929350911690635faa299a90604401602060405180830381865afa158015612fb8573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190612fdc919061376d565b949350505050565b604080516003808252608082019092525f916020820160608036833701905050905083815f81518110613019576130196136b1565b60209081029190910101528281600181518110613038576130386136b1565b60209081029190910101528181600281518110613057576130576136b1565b60209081029190910101525f61307b82630cfc771b60e41b83610fe14260646136c5565b5f908152601a60205260409020805461ffff191661ffff97909716969096179095555050505050565b6130c8816001600160a01b03165f9081526015602052604090205460ff1660011490565b156130f157604051632058b6db60e01b81526001600160a01b0382166004820152602401610d6e565b6001600160a01b0381165f908152601560205260408120805460ff191660011790556014805461ffff1691612ea5836138bf565b6001600160a01b0381165f90815260186020526040902054610e5890612bf8565b5f61219383836008613208565b6112cb828261332c565b6112cb82826133b3565b610e5881306133b3565b6001600160a01b0382165f9081526018602052604081208054839290612c8990849061369e565b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f81146131e1576040519150601f19603f3d011682016040523d82523d5f602084013e6131e6565b606091505b5050905080611b2d57604051631d42c86760e21b815260040160405180910390fd5b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516302e817ff60e41b81525f917fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600916001600160a01b0390911690632e817ff0906132859088903390899060f88a901b906004016138df565b6020604051808303815f875af11580156132a1573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906132c59190613658565b81546040516346ce4e4960e11b8152600481018390523360248201529193506001600160a01b031690638d9c9c92906044015f604051808303815f87803b15801561330e575f80fd5b505af1158015613320573d5f803e3d5ffd5b50505050509392505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546040516346ce4e4960e11b8152600481018590526001600160a01b03848116602483015290911690638d9c9c92906044015b5f604051808303815f87803b158015613398575f80fd5b505af11580156133aa573d5f803e3d5ffd5b50505050505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6008054604051631974142760e21b8152600481018590526001600160a01b038481166024830152909116906365d0509c90604401613381565b6001600160a01b0381168114610e58575f80fd5b5f60208284031215613430575f80fd5b81356121938161340c565b61ffff81168114610e58575f80fd5b5f6020828403121561345a575f80fd5b81356121938161343b565b5f60208284031215613475575f80fd5b5035919050565b5f805f805f60a08688031215613490575f80fd5b853561349b8161340c565b945060208601356134ab8161340c565b935060408601356134bb8161340c565b92506060860135915060808601356134d28161343b565b809150509295509295909350565b8015158114610e58575f80fd5b5f80604083850312156134fe575f80fd5b823591506020830135613510816134e0565b809150509250929050565b67ffffffffffffffff81168114610e58575f80fd5b5f8060408385031215613541575f80fd5b823561354c8161351b565b91506020830135613510816134e0565b5f805f6060848603121561356e575f80fd5b505081359360208301359350604090920135919050565b5f8060408385031215613596575f80fd5b50508035926020909101359150565b5f805f80606085870312156135b8575f80fd5b8435935060208501359250604085013567ffffffffffffffff808211156135dd575f80fd5b818701915087601f8301126135f0575f80fd5b8135818111156135fe575f80fd5b88602082850101111561360f575f80fd5b95989497505060200194505050565b5f805f8060808587031215613631575f80fd5b8435935060208501356136438161343b565b93969395505050506040820135916060013590565b5f60208284031215613668575f80fd5b5051919050565b5f6020828403121561367f575f80fd5b81516121938161351b565b634e487b7160e01b5f52601160045260245ffd5b818103818111156116b2576116b261368a565b634e487b7160e01b5f52603260045260245ffd5b808201808211156116b2576116b261368a565b5f602082840312156136e8575f80fd5b81516121938161340c565b5f60208284031215613703575f80fd5b81516121938161343b565b5f806040838503121561371f575f80fd5b505080516020909101519092909150565b61ffff81811683821601908082111561374b5761374b61368a565b5092915050565b61ffff82811682821603908082111561374b5761374b61368a565b5f6020828403121561377d575f80fd5b8151612193816134e0565b5f805f6060848603121561379a575f80fd5b835160ff811681146137aa575f80fd5b60208501519093506137bb8161351b565b60408501519092506137cc8161351b565b809150509250925092565b5f815180845260208085019450602084015f5b83811015613806578151875295820195908201906001016137ea565b509495945050505050565b602081525f61219360208301846137d7565b60a081525f61383560a08301886137d7565b7fffffffff0000000000000000000000000000000000000000000000000000000096909616602083015250604081019390935260608301919091521515608090910152919050565b5f805f6060848603121561388f575f80fd5b8351925060208401519150604084015190509250925092565b80820281158282048414176116b2576116b261368a565b5f61ffff8083168181036138d5576138d561368a565b6001019392505050565b8481525f60206001600160a01b03861660208401526080604084015284518060808501525f5b818110156139215786810183015185820160a001528201613905565b505f60a0828601015260a0601f19601f8301168501019250505060ff60f81b831660608301529594505050505056fea164736f6c6343000818000aa164736f6c6343000818000a",
  "devdoc": {
    "errors": {
      "Create2EmptyBytecode()": [
        {
          "details": "There's no code to deploy."
        }
      ],
      "FailedDeployment()": [
        {
          "details": "The deployment failed."
        }
      ],
      "InsufficientBalance(uint256,uint256)": [
        {
          "details": "The ETH balance of the account is not enough to perform the operation."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8,
        "contract": "contracts/auctions/factories/FHEAuctionNativeFactory.sol:FHEAuctionNativeFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 156,
        "contract": "contracts/auctions/factories/FHEAuctionNativeFactory.sol:FHEAuctionNativeFactory",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 7690,
        "contract": "contracts/auctions/factories/FHEAuctionNativeFactory.sol:FHEAuctionNativeFactory",
        "label": "_engineFactories",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint8,t_contract(FHEAuctionEngineFactory)12062)"
      },
      {
        "astId": 7694,
        "contract": "contracts/auctions/factories/FHEAuctionNativeFactory.sol:FHEAuctionNativeFactory",
        "label": "_auctionDeployed",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_address)"
      },
      {
        "astId": 7696,
        "contract": "contracts/auctions/factories/FHEAuctionNativeFactory.sol:FHEAuctionNativeFactory",
        "label": "_auctionDeployedCount",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(FHEAuctionEngineFactory)12062": {
        "encoding": "inplace",
        "label": "contract FHEAuctionEngineFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint8,t_contract(FHEAuctionEngineFactory)12062)": {
        "encoding": "mapping",
        "key": "t_uint8",
        "label": "mapping(uint8 => contract FHEAuctionEngineFactory)",
        "numberOfBytes": "32",
        "value": "t_contract(FHEAuctionEngineFactory)12062"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}