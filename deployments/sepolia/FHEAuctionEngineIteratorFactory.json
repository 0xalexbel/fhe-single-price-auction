{
  "address": "0x8AcE8120A896Ee8DaE27159ea10065a85fbbe764",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialOwner",
          "type": "address"
        }
      ],
      "name": "createNewIterator",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5b1324be53c9b67d6019b17601f6269c0d347ca53923f5a4d1618ad31ba5e0b2",
  "receipt": {
    "to": null,
    "from": "0x37AC010c1c566696326813b840319B58Bb5840E4",
    "contractAddress": "0x8AcE8120A896Ee8DaE27159ea10065a85fbbe764",
    "transactionIndex": 150,
    "gasUsed": "1456607",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000040000000000000000000008000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000080000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000200000000000000000000000000000020010000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc5b6b5c2c620836e705a5edfb7d06e91f0da89b819f7414a4182462780500c77",
    "transactionHash": "0x5b1324be53c9b67d6019b17601f6269c0d347ca53923f5a4d1618ad31ba5e0b2",
    "logs": [
      {
        "transactionIndex": 150,
        "blockNumber": 7688384,
        "transactionHash": "0x5b1324be53c9b67d6019b17601f6269c0d347ca53923f5a4d1618ad31ba5e0b2",
        "address": "0x8AcE8120A896Ee8DaE27159ea10065a85fbbe764",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000037ac010c1c566696326813b840319b58bb5840e4"
        ],
        "data": "0x",
        "logIndex": 223,
        "blockHash": "0xc5b6b5c2c620836e705a5edfb7d06e91f0da89b819f7414a4182462780500c77"
      }
    ],
    "blockNumber": 7688384,
    "cumulativeGasUsed": "18287052",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "b4131e9528337a45f242293135657fca",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"name\":\"createNewIterator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol\":\"FHEAuctionEngineIteratorFactory\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     *\\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/FourStepsIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IFourStepsIterable {\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax) external returns (uint8, uint32);\\n}\\n\\n/*\\n * Return code, iterations were completed but the computation step is not finished\\n */\\nuint8 constant S_NOT_FINISHED = 0;\\n\\n/*\\n * Return code, iterations were completed and the computation step is finished \\n */\\nuint8 constant S_FINISHED = 1;\\n\\n/*\\n * Return code, iterations could not be completed due to insufficient gas.\\n */\\nuint8 constant E_NOT_ENOUGH_GAS = 2;\\n\\nabstract contract FourStepsIterator is Ownable {\\n    struct Step {\\n        uint32 size;\\n        uint8 nativeGasWeight;\\n        uint32 unitFheGasCost;\\n    }\\n\\n    uint64[] _cumulatives;\\n    Step[] _steps; // len = (4+1)\\n    uint8 _step; // 0 <= _step <= 4\\n    uint32 _stepProgress;\\n    uint64 _iterProgress;\\n\\n    error NullWeight();\\n    error UnauthorizedIterable();\\n    //18,992           | 21,952\\n\\n    constructor(address initialOwner) Ownable(initialOwner) {\\n        // _steps[4] should exist\\n        for (uint8 i = 0; i < 5; ++i) {\\n            _steps.push(Step({size: 0, nativeGasWeight: 0, unitFheGasCost: 0}));\\n            _cumulatives.push(0);\\n        }\\n    }\\n\\n    function _initializeFourSteps(Step[] memory fourSteps) internal {\\n        //Debug\\n        require(fourSteps.length <= 4);\\n\\n        uint64 max = 0;\\n        uint8 i;\\n        for (i = 0; i < fourSteps.length; ++i) {\\n            if (fourSteps[i].size > 0 && fourSteps[i].nativeGasWeight == 0) {\\n                revert NullWeight();\\n            }\\n            max += fourSteps[i].size * fourSteps[i].nativeGasWeight;\\n            Step storage s = _steps[i];\\n            s.size = fourSteps[i].size;\\n            s.nativeGasWeight = fourSteps[i].nativeGasWeight;\\n            s.unitFheGasCost = fourSteps[i].unitFheGasCost;\\n            _cumulatives[i] = max;\\n        }\\n\\n        while (i < 4) {\\n            _cumulatives[i] = max;\\n            i++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete step `s`\\n     */\\n    function _minIterProgressForStep(uint8 s) internal view returns (uint64) {\\n        return _cumulatives[s];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum number of completed iterations needed in order to complete the four steps\\n     */\\n    function iterProgressMax() public view returns (uint64) {\\n        return _cumulatives[3];\\n    }\\n\\n    /**\\n     * @dev Returns the number of completed iterations (`iterProgress()` <= `iterProgressMax()`).\\n     */\\n    function iterProgress() public view returns (uint64) {\\n        return _iterProgress;\\n    }\\n\\n    function getStepProgress(uint8 s) public view returns (uint32) {\\n        uint8 cur = _step;\\n        if (cur == s) {\\n            return _stepProgress;\\n        } else if (cur > s) {\\n            return _steps[s].size;\\n        }\\n        return 0;\\n    }\\n\\n    function getStepProgressMax(uint8 s) public view returns (uint32) {\\n        return _steps[s].size;\\n    }\\n\\n    function getStepIterProgressMax(uint8 s) public view returns (uint64) {\\n        return _steps[s].size * _steps[s].nativeGasWeight;\\n    }\\n\\n    function step() public view returns (uint8) {\\n        return _step;\\n    }\\n\\n    function stepProgress() public view returns (uint32) {\\n        return _stepProgress;\\n    }\\n\\n    function finished() public view returns (bool) {\\n        return _step == 4;\\n    }\\n\\n    /**\\n     * @dev Executes up to `iter` computation iterations, stopping early if step `maxStepCompleted` is fully processed.\\n     *\\n     * @param iter The maximum number of computation iterations to execute.\\n     * @param stopAfterStep The computation step at which execution should stop if it has been fully completed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of iterations completed before this function call.\\n     * @return endIterProgress The total number of iterations completed after this function call.\\n     *         The difference `(endIterProgress - startIterProgress)` represents the number of iterations executed in this call.\\n     */\\n    function _next(uint64 iter, uint8 stopAfterStep)\\n        internal\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        //uint8 s0 = _step;\\n        //uint8 s = s0;\\n        uint8 s = _step;\\n\\n        startIterProgress = _iterProgress;\\n        endIterProgress = startIterProgress;\\n\\n        code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n\\n        if (s > stopAfterStep) {\\n            return (code, startIterProgress, endIterProgress);\\n        }\\n\\n        //uint32 p0 = _stepProgress;\\n        //uint32 p = p0;\\n        uint32 fheGasLeft = 10_000_000;\\n        uint32 p = _stepProgress;\\n        uint64 actualIter = 0;\\n        IFourStepsIterable iterable = IFourStepsIterable(owner());\\n\\n        while (s < 4 && s <= stopAfterStep && fheGasLeft > 0) {\\n            Step memory theStep = _steps[s];\\n\\n            uint32 r = theStep.size - p;\\n\\n            // skip empty steps first.\\n            if (r == 0) {\\n                p = 0;\\n                s += 1;\\n                continue;\\n            }\\n\\n            // after having skipped empty steps\\n            if (iter == 0) {\\n                break;\\n            }\\n\\n            uint32 w = uint32(theStep.nativeGasWeight);\\n            uint32 i;\\n            if (iter < w) {\\n                // align\\n                i = 1;\\n                iter = w;\\n            } else {\\n                if (iter >= r * w) {\\n                    i = r;\\n                } else {\\n                    i = uint32(iter / w);\\n                }\\n            }\\n\\n            if (i * theStep.unitFheGasCost > fheGasLeft) {\\n                i = uint32(fheGasLeft / theStep.unitFheGasCost);\\n\\n                if (i == 0) {\\n                    fheGasLeft = 0;\\n                    break;\\n                }\\n            }\\n\\n            fheGasLeft -= uint32(i * theStep.unitFheGasCost);\\n\\n            uint32 j;\\n\\n            if (s == 0) {\\n                (code, j) = iterable.runStep1(p, i, theStep.size);\\n            } else if (s == 1) {\\n                (code, j) = iterable.runStep2(p, i, theStep.size);\\n            } else if (s == 2) {\\n                (code, j) = iterable.runStep3(p, i, theStep.size);\\n            } else if (s == 3) {\\n                (code, j) = iterable.runStep4(p, i, theStep.size);\\n            }\\n\\n            actualIter += j * w;\\n            iter -= j * w;\\n            p += j;\\n\\n            if (code == S_FINISHED) {\\n                //Debug\\n                require(p == theStep.size, \\\"Panic: p != theStep.size\\\");\\n                p = 0;\\n                s += 1;\\n            } else {\\n                //Debug\\n                require(p < theStep.size, \\\"Panic: p >= theStep.size\\\");\\n                if (code != S_NOT_FINISHED) {\\n                    //Debug\\n                    require(code == E_NOT_ENOUGH_GAS, \\\"Panic: code != E_NOT_ENOUGH_GAS\\\");\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (iter > 0 && fheGasLeft == 0) {\\n            code = E_NOT_ENOUGH_GAS;\\n        }\\n\\n        if (actualIter > 0) {\\n            endIterProgress = startIterProgress + actualIter;\\n            _iterProgress = endIterProgress;\\n        }\\n\\n        _stepProgress = p;\\n        _step = s;\\n\\n        if (code != E_NOT_ENOUGH_GAS) {\\n            code = (s == 4) ? S_FINISHED : S_NOT_FINISHED;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe546249b210236275a9940c5b040d58a5c1fd4e0c3a469d6d90c562d0f22e8bf\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/ITimedAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\ninterface ITimedAuction {\\n    function closed() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x172cc08b56e50a2c61499a088a105445b62de1350bf8ad10ada3c542b0e4e5f1\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuction.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {IFHEAuctionBase} from \\\"./IFHEAuctionBase.sol\\\";\\n\\ninterface IFHEAuction is IFHEAuctionBase {\\n    function balanceOf(address bidder) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea97d1fa958167d13730897a14fa6df3a6d4f03a43482c9d99a13f6fb73da673\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/auctions/IFHEAuctionBase.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {ITimedAuction} from \\\"../ITimedAuction.sol\\\";\\n\\ninterface IFHEAuctionBase is ITimedAuction {}\\n\",\"keccak256\":\"0x7fdc46ad5a85666ee01b04e640117a98a0848b4e27c84dc7a1ab3cf9c808ee67\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IFHEAuctionEngine} from \\\"./IFHEAuctionEngine.sol\\\";\\nimport {IFHEAuction} from \\\"../auctions/IFHEAuction.sol\\\";\\nimport {FHEAuctionEngineIterator} from \\\"./FHEAuctionEngineIterator.sol\\\";\\nimport {\\n    FourStepsIterator,\\n    IFourStepsIterable,\\n    S_FINISHED,\\n    S_NOT_FINISHED,\\n    E_NOT_ENOUGH_GAS\\n} from \\\"../FourStepsIterator.sol\\\";\\n\\n/**\\n * @notice ## Engine Architecture\\n *\\n * ### Incremental Computation\\n *\\n * - A uniform price auction requires an FHE-based sorting operation, which has a computational complexity\\n *   of O(N^2), where N is the number of bidders. As a result, the overall auction computation consumes\\n *   a significant amount of both native and FHE gas.\\n *\\n * - To overcome these gas cost limitations, the implementation adopts an incremental batch-processing mechanism,\\n *   allowing the full computation to be executed iteratively across multiple smaller transactions, rather\\n *   than in a single execution. This ensures computations remain gas-efficient and\\n *   prevents exceeding blockchain transaction limits as well as fhEVM limits.\\n *\\n * - Since the auction results cannot be determined in a single transaction, a dedicated contract,\\n *   {FHEAuctionEngineIterator}, is responsible for managing the paging mechanism. It orchestrates the\\n *   progressive execution of auction computation cycles until completion.\\n *\\n * - A drawback of such iterative approach is the extra native gas cost required to read/write additional state\\n *   variables required to save the computation status between two consecutive computation transactions.\\n *\\n * ### Contract Size Limit\\n *\\n * Due to the maximum contract size restrictions, the auction engine is modularized across multiple contracts:\\n *\\n * - Core Engine: `FHEAuctionEngine`, the base contract.\\n * - Tie-Breaking Implementations: Four specialized contracts inherit from `FHEAuctionEngine`, each\\n *   implementing a different tie-breaking rule:\\n *      - `FHEAuctionEnginePriceId`\\n *      - `FHEAuctionEnginePriceQuantityId`\\n *      - `FHEAuctionEnginePriceRandom`\\n *      - `FHEAuctionEngineProRata`\\n * - Computation Manager: `FHEAuctionEngineIterator`, responsible for orchestrating the incremental\\n *   computation process.\\n *\\n * @notice ## Algorithm for Bid Validation and Ranking\\n *\\n * ### Approach\\n *\\n * A bit-level strategy would have been optimal in terms of FHE cost; however, the resulting native gas cost\\n * would be overwhelming. The primary reason is that the current version of TFHE library lacks batch functions\\n * or high-level bitwise operations (such as array manipulations or tensor operations).\\n * As a result, a more \\\"brute force\\\" approach manipulating encrypted integers is necessary.\\n *\\n * The algorithm consists in 4 steps, with the last one beeing optional.\\n *\\n *  |  Steps                     |  Cost    |\\n *  |----------------------------|----------|\\n *  |  1. Bid validation         |  O(N)    |\\n *  |  2. Bid ranking            |  O(N^2)  |\\n *  |  3. Won Quantities by rank |  O(N)    |\\n *  |  4. Won Quantities by id   |  O(N^2)  |\\n *\\n * ### Step 1: Bid validation. O(N)\\n *\\n * The first step is to sanitize the list of registered bids by evaluating each one individually. If a bid fails to meet\\n * the engine's validation criteria, it is marked as invalid, with both the price and quantity set to zero\\n * (i.e., `price = 0` and `quantity = 0`).\\n *\\n * Registered bids are indexed starting from `1` up to `bidCount`. Therefore, an index of `0` indicates that no bid\\n * exists. For each valid bid at index `i` (where `1 <= i <= bidCount`), the following two conditions must always hold:\\n *\\n * 1. `0 < price(i) <= Maximum Price`\\n * 2. `0 < quantity(i) <= Total Quantity`\\n *\\n * ### Step 2: Bid ranking (sort). O(N^2)\\n *\\n * - In this step, we determine the price and quantity of the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`. The bid ranked at position `0` is the highest-ranked bid, which is determined based on the selected\\n * ranking criteria. The ranking is strict, meaning no two bids can share the same rank. To achieve this, the bid\\n * set is provided with a strict order relation, ensuring a clear distinction between each bid's position in the ranking.\\n *\\n * - The final list of ranked bids is constructed through an iterative process. Specifically, the bid at index `k+1` is\\n * inserted into an existing list of ranked bids of length `k`, resulting in a new list of length `k+1`. During each\\n * insertion, the bid is placed in its correct position, ensuring that the relationship `Bid(k) > Bid(k+1)` holds true\\n * according to the selected comparison criteria.\\n *\\n * - The comparison function used to rank bids depends on two factors: the bid price and the auction engine's specified\\n * tie-breaking rule. This ensures that bids are ranked in a consistent and predictable manner.\\n *\\n * - Finally, the computational complexity of this bid ranking operation is `N(N-1)/2 = O(N^2)`, where `N` represents the\\n * total number of bids. This complexity arises from the need to perform pairwise comparisons and insert each bid into the\\n * correct position within the sorted list.\\n *\\n * ### Step 3: Ranked bid won quantities and uniform price calculation. O(N)\\n *\\n * - In the third step, we determine the final quantity for the bid ranked at position `k`, where `k` ranges from `0` to\\n * `bidCount - 1`, as well as the auction's final uniform price. A winning bid will have a strictly positive quantity,\\n * while a losing bid will have a quantity of zero.\\n *\\n * - Since the bids are ranked in strict order, the quantity for each winning bid can be determined deterministically,\\n * without the need for tie-breaking.\\n *\\n * - The uniform price is calculated as the price of the lowest winning bid.\\n *\\n * - The computational complexity O(N), linear in the number of bids.\\n *\\n * ### Step 4 (Optional): Inverting ranking to index vector. O(N^2)\\n *\\n * - This step generates an index vector that maps the ranking of bids back to their original positions in the\\n * ranked list. Each position in the index vector corresponds to the original index of a bid in the ranked list.\\n *\\n * - The purpose of this step is to facilitate lookup or processing based on the original bid order.\\n *\\n * - This step is optional and can be skipped to minimize computation cost and if auction prizes can delivered directly\\n * based on ranking positions rather than requiring bidder addresses.\\n */\\nabstract contract FHEAuctionEngine is SepoliaZamaFHEVMConfig, Ownable, IFourStepsIterable, IFHEAuctionEngine {\\n    uint256 public constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint256 public constant MIN_GAS_PER_BV_CYCLE = 165_000;\\n    uint256 public constant MIN_GAS_PER_RB_CYCLE = 420_000;\\n    uint256 public constant MIN_GAS_PER_RWQ_CYCLE = 250_000;\\n    uint256 public constant MIN_GAS_PER_WQ_CYCLE = 160_000;\\n\\n    euint256 constant DUMMY_EUINT256_MEMORY = euint256.wrap(uint32(0xdeadbeef));\\n    euint16 constant DUMMY_EUINT16_MEMORY = euint16.wrap(uint32(0xdeadbeef));\\n\\n    enum TieBreakingRule {\\n        PriceId,\\n        PriceQuantityId,\\n        PriceRandom,\\n        ProRata\\n    }\\n\\n    struct ABid {\\n        euint256 price;\\n        euint256 quantity;\\n        euint256 rand;\\n        euint16 id;\\n    }\\n\\n    FHEAuctionEngineIterator _iterator;\\n\\n    uint256 private _totalQuantity;\\n    TieBreakingRule private _tieBreakingRule;\\n    bool private _auctionIsClosed;\\n\\n    uint16 private _maxBidCount;\\n    uint16 private _bidCount;\\n    uint16 private _nextId;\\n\\n    // 1 <= id < _nextId\\n    mapping(address bidder => uint16 id) private _bidderToId;\\n    mapping(uint16 id => address bidder) private _idToBidder;\\n\\n    // 1 <= idxPlusOne <= _bidCount\\n    mapping(uint16 idxPlusOne => uint16 id) private _indexPlusOneToId;\\n    mapping(uint16 id => uint16 idxPlusOne) private _idToIndexPlusOne;\\n\\n    // 1 <= id < _nextId\\n    mapping(uint16 id => ABid bid) private _idToBid;\\n\\n    euint256 private _cumulativeQuantity;\\n    euint256 private _uniformPrice;\\n\\n    ///@dev A precomputed zero euint256 to minimize the `TFHE.asEuint256(0)` calls\\n    euint256 private immutable _eZeroU256;\\n\\n    // Step 2: Bid ranking. O(N^2)\\n    // ===========================\\n\\n    ///@dev Index from which the computation of step #2 should resume.\\n    uint16 private _resumeIdxRB;\\n\\n    ///@dev Temporary saved did data required when the computation of step #2 should resume.\\n    ABid private _cursorRB;\\n\\n    ///@dev Total number of ranked bids that have been computed so far.\\n    ///@dev 0 <= _rankedBidCount <= _bidCount\\n    uint16 private _rankedBidCount;\\n\\n    ///@dev Array of bids sorted by rank order, where entry k contains the bid placed by bidder ranked at position k.\\n    ///@dev 0 <= rank < _rankedBidCount\\n    ABid[] private _rankedBids;\\n\\n    // Step 3: Ranked bid won quantity and uniform price calculation. O(N)\\n    // ===================================================================\\n\\n    ///@dev Array of final won quantities sorted by rank order, where entry k contains the won quantity for bidder\\n    /// ranked at position k.\\n    euint256[] private _rankedWonQuantities;\\n\\n    // Step 4: Inverting ranking to index vector. O(N)\\n    // ===============================================\\n\\n    ///@dev Index of the bidder whose final won quantity is being computed\\n    uint16 private _idxWQ;\\n\\n    ///@dev Index from which the computation of the final won quantity should resume\\n    uint16 private _resumeIdxWQ;\\n\\n    ///@dev `true` if all won quantities have been computed\\n    bool private _wonQuantitiesByIdReady;\\n\\n    ///@dev `true` if all ranked won quantities have been computed\\n    bool private _wonQuantitiesByRankReady;\\n\\n    ///@dev Current computed final won quantity for the bidder at index `_idxWQ`\\n    euint256 private _quantityWQ;\\n\\n    ///@dev Array of final won quantities, where entry k contains the won quantity for bidder with index = k + 1\\n    euint256[] private _wonQuantities;\\n\\n    error ExpectedNotClosed();\\n    error ExpectedClosed();\\n    error IndexOutOfBounds(uint16 idx, uint16 count);\\n    error RankOutOfBounds(uint16 rank, uint16 rankCount);\\n    error InvalidIterator();\\n    error InvalidId(uint16 id);\\n    error BidderAlreadyRegistered(address bidder);\\n    error TooManyBids();\\n    error WonQuantitiesByRankNotReady();\\n    error WonQuantitiesByIdNotReady();\\n    error NotEnoughGas(uint256 gasLeft, uint256 gasNeeded);\\n    error UnauthorizedIterator();\\n    // Debug\\n    error DebugEngineError(uint16 code);\\n\\n    /**\\n     * @dev Ensures the auction engine not closed before executing the function.\\n     */\\n    modifier whenNotClosed() {\\n        if (_auctionIsClosed) revert ExpectedNotClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Ensures the auction engine is closed before executing the function.\\n     */\\n    modifier whenClosed() {\\n        if (!_auctionIsClosed) revert ExpectedClosed();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the iterator.\\n     */\\n    modifier onlyIterator() {\\n        if (address(_iterator) != msg.sender) {\\n            revert UnauthorizedIterator();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @param auctionOrInitialOwner_ The address of the `FHEAuctionBase` contract that owns this auction engine or the\\n     * address of the initial owner. If the engine initial owner is not the auction contract, a transfer ownership must\\n     * be performed to give ownership to the auction contract.\\n     * @param tieBreakingRule_ The tie-breaking rule used by the auction engine to resolve ties.\\n     * @param iterator_ The addre.\\n     */\\n    constructor(address auctionOrInitialOwner_, uint8 tieBreakingRule_, address iterator_)\\n        Ownable(auctionOrInitialOwner_)\\n    {\\n        if (iterator_ == address(0) || Ownable(iterator_).owner() != auctionOrInitialOwner_) {\\n            revert InvalidIterator();\\n        }\\n\\n        _iterator = FHEAuctionEngineIterator(iterator_);\\n        _tieBreakingRule = TieBreakingRule(tieBreakingRule_);\\n\\n        euint256 eZero = TFHE.asEuint256(0);\\n        TFHE.allowThis(eZero);\\n\\n        _eZeroU256 = eZero;\\n        _cumulativeQuantity = eZero;\\n        _uniformPrice = eZero;\\n\\n        // A bit counter intuitive.\\n        // Mainly to ensure that computation iterations have a constant gas cost\\n        _cursorRB.price = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.quantity = DUMMY_EUINT256_MEMORY;\\n        _cursorRB.id = DUMMY_EUINT16_MEMORY;\\n        _resumeIdxRB = uint16(0xdead);\\n\\n        _quantityWQ = eZero;\\n        _nextId = 1;\\n        _maxBidCount = type(uint16).max;\\n    }\\n\\n    /**\\n     * @notice Initializes the auction engine with a specified quantity of items.\\n     * The `FHEAuctionEngine` contract is intended for internal use by its owner and is not designed to be\\n     * used by other contracts. It does not include protections against reentrancy or multiple initializations.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner (a contract of type `FHEAuctionBase`).\\n     * - The engine must not be in a closed state.\\n     *\\n     * @param totalQuantity_ The total quantity of items to be auctioned.\\n     */\\n    function initialize(uint256 totalQuantity_, uint16 maxBidCount_) external onlyOwner whenNotClosed {\\n        _totalQuantity = totalQuantity_;\\n        _maxBidCount = maxBidCount_;\\n    }\\n\\n    /**\\n     * @notice Returns the auction contract associated with this engine.\\n     * @dev The auction contract is required to be the owner of the engine.\\n     * @return The auction contract interface.\\n     */\\n    function _auction() internal view returns (IFHEAuction) {\\n        return IFHEAuction(owner());\\n    }\\n\\n    /**\\n     * @notice Returns the engine iterator address. The iterator's owner is the engine itself.\\n     */\\n    function iterator() public view returns (address) {\\n        return address(_iterator);\\n    }\\n\\n    /**\\n     * @notice Returns total quantity of items to be auctioned.\\n     */\\n    function totalQuantity() external view returns (uint256) {\\n        return _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum allowable price for each bid.\\n     * This value ensures that subsequent TFHE arithmetic operations will not overflow.\\n     */\\n    function maximumPrice() public view returns (uint256) {\\n        return MAX_UINT256 / _totalQuantity;\\n    }\\n\\n    /**\\n     * @notice Returns the tie-breaking rule used to resolve winning ties.\\n     */\\n    function tieBreakingRule() external view returns (uint8) {\\n        return uint8(_tieBreakingRule);\\n    }\\n\\n    /**\\n     * @notice Returns the total number of bids.\\n     */\\n    function getBidCount() public view returns (uint16) {\\n        return _bidCount;\\n    }\\n\\n    /**\\n     * @notice Returns the maximum number of bids.\\n     */\\n    function getMaximumBidCount() public view returns (uint16) {\\n        return _maxBidCount;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bid index. Reverts if the index is out of bounds.\\n     * @param index The zero-based index of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByIndex(uint16 index) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        if (index >= _bidCount) {\\n            revert IndexOutOfBounds(index, _bidCount);\\n        }\\n\\n        id = _indexPlusOneToId[index + 1];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid associated with the specified bidder address.\\n     * @param bidder The address of the bidder whose bid is being retrieved.\\n     * @return id The clear ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByBidder(address bidder) public view returns (uint16 id, euint256 price, euint256 quantity) {\\n        id = _bidderToId[bidder];\\n        price = _idToBid[id].price;\\n        quantity = _idToBid[id].quantity;\\n    }\\n\\n    /**\\n     * @notice Returns the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` is the highest-ranked (winning) bid. Reverts if `rank` is out of bounds.\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid.\\n     * @return price The encrypted price of the bid.\\n     * @return quantity The encrypted quantity of the bid.\\n     */\\n    function getBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (rank >= _rankedBidCount) {\\n            revert RankOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedBids[rank].quantity;\\n    }\\n\\n    /**\\n     * @notice Retrieves the bid ranked at the specified position `rank`.\\n     * The bid at rank `0` represents the highest-ranked (winning) bid.\\n     * The function reverts if:\\n     * - The ranked won quantities computation is not complete.\\n     * - The provided `rank` is out of bounds.\\n     *\\n     * @param rank The zero-based rank position of the bid to retrieve.\\n     * @return id The encrypted ID of the bid at the specified rank.\\n     * @return price The encrypted price of the bid at the specified rank.\\n     * @return quantity The encrypted quantity won by the bid at the specified rank.\\n     */\\n    function getWonBidByRank(uint16 rank) public view returns (euint16 id, euint256 price, euint256 quantity) {\\n        if (!_wonQuantitiesByRankReady) {\\n            // step #3 is not yet completed\\n            revert WonQuantitiesByRankNotReady();\\n        }\\n\\n        if (rank >= _rankedBidCount) {\\n            revert IndexOutOfBounds(rank, _rankedBidCount);\\n        }\\n\\n        id = _rankedBids[rank].id;\\n        price = _rankedBids[rank].price;\\n        quantity = _rankedWonQuantities[rank];\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the uniform price is ready for decryption.\\n     */\\n    function canDecryptUniformPrice() external view returns (bool) {\\n        // uniformPrice is computed during step #3\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns the encrypted uniform price if computations are complete;\\n     * otherwise, returns zero (uninitialized `euint256`).\\n     * @return price the encrypted uniform price. The engine owner has TFHE permissions to access `price`.\\n     */\\n    function getUniformPrice() public view returns (euint256 price) {\\n        // uniformPrice is computed during step #3\\n        if (_wonQuantitiesByRankReady) {\\n            price = _uniformPrice;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns `true` if the computation of all won quantities is complete (step #4),\\n     * allowing bidders to claim their auction prizes.\\n     */\\n    function canClaim() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function canAward() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #3),\\n     */\\n    function wonQuantitiesByRankReady() external view returns (bool) {\\n        return _wonQuantitiesByRankReady;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if all ranked won quantities have been computed (step #4),\\n     */\\n    function wonQuantitiesByIdReady() external view returns (bool) {\\n        return _wonQuantitiesByIdReady;\\n    }\\n\\n    /**\\n     * @notice Returns the validated price and the encrypted won quantity associated with the bid identified by `id`.\\n     *\\n     * @notice Requirements:\\n     * - The computation of all won quantities must be complete (step #4).\\n     * - `id` must be a valid ID.\\n     *\\n     * @param id The bid ID.\\n     * @return validatedPrice The encrypted validated price of the bid.\\n     * @return wonQuantity The encrypted won quantity of the bid.\\n     *\\n     * @dev The owning auction contract has TFHE access permissions on both `wonQuantity` and `validatedPrice`.\\n     */\\n    function validatedPriceAndWonQuantityById(uint16 id)\\n        external\\n        view\\n        returns (euint256 validatedPrice, euint256 wonQuantity)\\n    {\\n        if (_wonQuantitiesByIdReady) {\\n            uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n            if (idxPlusOne == 0 || idxPlusOne > _bidCount) {\\n                revert InvalidId(id);\\n            }\\n\\n            // owner has TFHE permissions.\\n            validatedPrice = _idToBid[id].price;\\n            wonQuantity = _wonQuantities[idxPlusOne - 1];\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the bid ID associated with the specified `bidder` address.\\n     */\\n    function bidderId(address bidder) external view returns (uint16) {\\n        return _bidderToId[bidder];\\n    }\\n\\n    /**\\n     * @notice Returns the bidder address associated with the specified `id`.\\n     */\\n    function getBidderById(uint16 id) external view returns (address) {\\n        return _idToBidder[id];\\n    }\\n\\n    /**\\n     * @notice Removes a bidder's bid from the list of bids\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not be closed. (ie still accepting new bids)\\n     */\\n    function removeBid(address bidder) external onlyOwner whenNotClosed {\\n        uint16 id = _bidderToId[bidder];\\n        if (id == 0) {\\n            return;\\n        }\\n\\n        // Debug\\n        if (!(_bidCount > 0)) revert DebugEngineError(4);\\n\\n        uint16 idxPlusOne = _idToIndexPlusOne[id];\\n\\n        // Debug\\n        if (!(idxPlusOne > 0)) revert DebugEngineError(5);\\n\\n        // remove bidder address\\n        _bidderToId[bidder] = 0;\\n        _idToBidder[id] = address(0);\\n\\n        // swap id with last id\\n        if (idxPlusOne < _bidCount) {\\n            uint16 lastId = _indexPlusOneToId[_bidCount];\\n\\n            // Debug\\n            if (!(lastId > 0)) revert DebugEngineError(6);\\n\\n            _indexPlusOneToId[idxPlusOne] = lastId;\\n            _idToIndexPlusOne[lastId] = idxPlusOne;\\n        }\\n\\n        // remove id\\n        _indexPlusOneToId[_bidCount] = 0;\\n        _idToIndexPlusOne[id] = 0;\\n        _idToBid[id] =\\n            ABid({price: euint256.wrap(0), quantity: euint256.wrap(0), id: euint16.wrap(0), rand: euint256.wrap(0)});\\n\\n        _bidCount--;\\n    }\\n\\n    /**\\n     * @notice Mark the auction engine as closed. When the engine is closed, it can no more accept new bids.\\n     *\\n     * @notice Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine should not already be closed.\\n     */\\n    function close() external onlyOwner whenNotClosed {\\n        _close(false);\\n    }\\n\\n    function _close(bool onlyBlindClaim) internal {\\n        _auctionIsClosed = true;\\n        _iterator.initializeFourSteps(_bidCount, 2_456_000, _rankFheGasCostPerIdx(), 1_469_000, 101_000, onlyBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Executes a batch of auction computation cycles, processing up to `iter` cycles in a single call.\\n     * This function allows incremental processing of the auction results until completion.\\n     *\\n     * @dev If the auction is not yet closed, it will be closed before starting the computation.\\n     *\\n     * @notice Requirements:\\n     * - Only the contract owner can call this function.\\n     *\\n     * @param iter The maximum number of computation cycles to execute in this call.\\n     * @param stopIfReadyForBlindClaim The computation should stop if `blindClaim` can be executed.\\n     * @return code A status code indicating the outcome of the computation:\\n     *      - `S_NOT_FINISHED` = 0 : More cycles are required to complete the computation.\\n     *      - `S_FINISHED` = 1 : The full auction computation successfully completed.\\n     *      - `E_NOT_ENOUGH_GAS` = 2 : Insufficient gas to continue processing.\\n     * @return startIterProgress The total number of computation cycles completed before this function call.\\n     * @return endIterProgress The total number of computation cycles completed after this function call.\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        if (!_auctionIsClosed) {\\n            _close(false);\\n        }\\n        (code, startIterProgress, endIterProgress) = _iterator.computeAuctionIterations(iter, stopIfReadyForBlindClaim);\\n    }\\n\\n    /**\\n     * @notice Adds a new bid to the list of bids.\\n     *\\n     * @dev Requirements:\\n     * - The caller must be the engine owner.\\n     * - The auction engine must not be closed.\\n     *\\n     * @param bidder The address of the bidder placing the new bid.\\n     * @param ePrice The encrypted price of the bid.\\n     * @param eQuantity The encrypted quantity of the bid.\\n     */\\n    function addBid(address bidder, euint256 ePrice, euint256 eQuantity) external onlyOwner whenNotClosed {\\n        if (_bidderToId[bidder] != 0) {\\n            revert BidderAlreadyRegistered(bidder);\\n        }\\n\\n        if (_bidCount == _maxBidCount) {\\n            revert TooManyBids();\\n        }\\n\\n        uint16 nextId = _nextId;\\n        _nextId = nextId + 1;\\n\\n        uint16 nextIdxPlusOne = _bidCount + 1;\\n        _bidCount = nextIdxPlusOne;\\n\\n        euint256 zero = _eZeroU256;\\n        ebool priceTooHigh = TFHE.gt(ePrice, maximumPrice());\\n        ePrice = TFHE.select(priceTooHigh, zero, ePrice);\\n        eQuantity = TFHE.min(eQuantity, _totalQuantity);\\n\\n        ebool ePriceIsZero = TFHE.eq(ePrice, zero);\\n        ebool eQuantityIsZero = TFHE.eq(eQuantity, zero);\\n\\n        ePrice = TFHE.select(eQuantityIsZero, zero, ePrice);\\n        eQuantity = TFHE.select(ePriceIsZero, zero, eQuantity);\\n\\n        euint256 eRand = euint256.wrap(0);\\n        euint16 eId = TFHE.asEuint16(nextId);\\n\\n        if (_tieBreakingRule == TieBreakingRule.PriceRandom) {\\n            eRand = TFHE.randEuint256();\\n            TFHE.allowThis(eRand);\\n        }\\n\\n        TFHE.allowThis(ePrice);\\n        TFHE.allowThis(eQuantity);\\n        TFHE.allowThis(eId);\\n\\n        _indexPlusOneToId[nextIdxPlusOne] = nextId;\\n        _idToIndexPlusOne[nextId] = nextIdxPlusOne;\\n\\n        _bidderToId[bidder] = nextId;\\n        _idToBidder[nextId] = bidder;\\n\\n        _idToBid[nextId] = ABid({price: ePrice, quantity: eQuantity, rand: eRand, id: eId});\\n\\n        // Bidder pays for memory allocation\\n        ABid memory _emptySortedBid;\\n        _emptySortedBid.price = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.quantity = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.rand = DUMMY_EUINT256_MEMORY;\\n        _emptySortedBid.id = eId;\\n\\n        _rankedBids.push(_emptySortedBid);\\n        _rankedWonQuantities.push(DUMMY_EUINT256_MEMORY);\\n        _wonQuantities.push(DUMMY_EUINT256_MEMORY);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //                  \\u2b50\\ufe0f Step 1/4: Bid Validation O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #1.\\n     *\\n     * - Returns `E_NOT_ENOUGH_GAS` if the `chunckSize` iterations could not be completed due to insufficient gas.\\n     * - Returns `S_NOT_FINISHED` if the iterations were completed but the computation step is not yet finished.\\n     * - Returns `S_FINISHED` if the iterations were completed (or fewer iterations were needed) and the bid ranking step has been completed.\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #1. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x mul(euint256, euint256) : 1 x 2_045_000\\n     * - 1x le(euint256, uint256)   : 1 x   231_000\\n     * - 2x select(euint256)        : 2 x    90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 2_456_000\\n     */\\n    function _runStep1(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Gas cost ~= 2_400\\n        uint16 toIdx = uint16(progress + iter);\\n\\n        euint256 ePrice;\\n        euint256 eQuantity;\\n\\n        IFHEAuction auction = _auction();\\n\\n        // From start to beginning of the loop : Gas cost ~= 2_600\\n        // 1x loop iter ~= 153_000 gas\\n        // After loop ~= 3_000 gas\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        for (uint16 idx = uint16(progress); idx < toIdx; ++idx) {\\n            uint16 bidId = _indexPlusOneToId[idx + 1];\\n\\n            // Debug\\n            if (!(bidId > 0)) revert DebugEngineError(7);\\n\\n            ABid storage b = _idToBid[bidId];\\n            ePrice = b.price;\\n            eQuantity = b.quantity;\\n            // ePrice = _idToBid[bidId].price;\\n            // eQuantity = _idToBid[bidId].quantity;\\n\\n            // Cannot overflow\\n            euint256 minBalance = TFHE.mul(ePrice, eQuantity);\\n\\n            ebool enoughBalance = TFHE.le(minBalance, auction.balanceOf(_idToBidder[bidId]));\\n\\n            ePrice = TFHE.select(enoughBalance, ePrice, _eZeroU256);\\n            eQuantity = TFHE.select(enoughBalance, eQuantity, _eZeroU256);\\n\\n            // _idToBid[bidId].price = ePrice;\\n            // _idToBid[bidId].quantity = eQuantity;\\n            b.price = ePrice;\\n            b.quantity = eQuantity;\\n\\n            TFHE.allowThis(ePrice);\\n            TFHE.allowThis(eQuantity);\\n            TFHE.allow(ePrice, address(auction));\\n            TFHE.allow(eQuantity, address(auction));\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_BV_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            code = S_FINISHED;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //             \\u2b50\\ufe0f Step 2/4: Sort Bids by Rank Order O(N^2) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @dev Returns the FHE Gas cost per iteration consumed by the `_rankFromIdxToIdx` function.\\n     */\\n    function _rankFheGasCostPerIdx() internal pure virtual returns (uint32);\\n\\n    /**\\n     * @dev Performs a ranking pass from index `fromIdx` to index `toIdx`. The FHE Gas cost can be evaluated using the\\n     * `_rankFheGasCostPerIdx` function.\\n     */\\n    function _rankFromIdxToIdx(uint16 fromIdx, uint16 toIdx, ABid memory cursor) internal virtual;\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #2.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The max progress value for the step #2. (`progress` + `iter` <= `progressMax`)\\n     * @return One of the following status code `S_FINISHED` or `S_NOT_FINISHED` or `E_NOT_ENOUGH_GAS`\\n     *\\n     * @dev Total FHE Gas Cost per iteration : `_rankFheGasCostPerIdx()`\\n     */\\n    function _runStep2(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < 2 * MIN_GAS_PER_RB_CYCLE) {\\n            // If we do not have enough gas left to perform `one TFHE cycle` + `one sort completion`\\n            // it is probably safe to interrupt at this point to avoid any accidental revert due to insufficient gas\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 rankedBidCount = _rankedBidCount;\\n        uint16 resumeIdx;\\n\\n        // We want to optimize the following calls:\\n        // - TFHE.allow(...) which cost about 25_000 gas\\n        // - SSTORE operations\\n        // We use the following 2 flags to minimize those calls.\\n        bool cursorAllowNeeded = false;\\n        bool cursorUpdateNeeded = false;\\n\\n        ABid memory cursor;\\n\\n        // We pick the first registered bid and store it at the first place of\\n        // the sorted bid list.\\n        if (rankedBidCount == 0) {\\n            // The first bid id is equal to `1`\\n            // (See the bid() function and the above remark (3))\\n            _rankedBids[0] = _idToBid[_indexPlusOneToId[1]];\\n\\n            // if there is only one single bidder, the sort is over\\n            if (_bidCount == 1) {\\n                _rankedBidCount = 1;\\n                return (S_FINISHED, 1);\\n            }\\n\\n            // if there are more than one bidder,\\n            // load the second unsorted bid into the cursor and setup the cursor position to zero\\n            rankedBidCount = 1;\\n            resumeIdx = 0;\\n            cursor = _idToBid[_indexPlusOneToId[2]];\\n            cursorUpdateNeeded = true;\\n        } else {\\n            // If the function is called to resume the sort operation, then\\n            // start from the last position stored in the cursor.\\n            resumeIdx = _resumeIdxRB;\\n            cursor = _cursorRB;\\n        }\\n\\n        uint8 code = S_NOT_FINISHED;\\n        uint32 count = 0;\\n\\n        while (count < iter) {\\n            uint32 toIdx = resumeIdx + uint16(iter - count);\\n            if (toIdx > rankedBidCount) {\\n                toIdx = rankedBidCount;\\n            }\\n\\n            // We want to make sure we have enough gas to compute the following:\\n            // - `toIdx - resumeIdxRB` cycles of TFHE operations\\n            // - 1 extra gas quantity to finish the current sort pass.\\n            if (gasleft() < (toIdx - resumeIdx + 1) * MIN_GAS_PER_RB_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            // since resumeIdx < toIdx, the cursor will always be modified\\n            // therefore we must invalidate the storage `_cursorRB` struct.\\n            _rankFromIdxToIdx(resumeIdx, uint16(toIdx), cursor);\\n\\n            count += (toIdx - resumeIdx);\\n\\n            // invalidate the storage `_cursorRB`\\n            cursorUpdateNeeded = true;\\n\\n            // We have reached the end of the currently sorted bids.\\n            // We must do the following:\\n            // 1. append the bid cursor to end of the sorted list.\\n            // 2. load the cursor with the next unsorted bid\\n            // 3. set the cursor position to zero.\\n            if (toIdx == rankedBidCount) {\\n                _rankedBids[rankedBidCount] = cursor;\\n                rankedBidCount++;\\n\\n                _allowBid(cursor);\\n\\n                // If all the registered bids have been sorted, then the sort operation\\n                // is completed.\\n                if (rankedBidCount == _bidCount) {\\n                    // Debug\\n                    if (!(progress + count == progressMax)) revert DebugEngineError(8);\\n\\n                    _rankedBidCount = rankedBidCount;\\n                    return (S_FINISHED, count);\\n                }\\n\\n                // restart from the beginning with the next unsorted bid.\\n                // The next unsorted bid index is equal to `rankedBidCount`\\n                resumeIdx = 0;\\n                cursor = _idToBid[_indexPlusOneToId[rankedBidCount + 1]];\\n\\n                // since the values stored in the cursor are already allowed, there\\n                // will be no need to perform any TFHE.allow() call.\\n                cursorAllowNeeded = false;\\n            } else {\\n                // Debug\\n                if (!(count == iter)) revert DebugEngineError(9);\\n\\n                resumeIdx = uint16(toIdx);\\n\\n                // a TFHE.allow call must be executed on the new cursor values\\n                cursorAllowNeeded = true;\\n            }\\n        }\\n\\n        // Debug\\n        if (!(progress + count < progressMax)) revert DebugEngineError(10);\\n\\n        // Perform TFHE.allow if needed\\n        if (cursorAllowNeeded) {\\n            _allowBid(cursor);\\n        }\\n\\n        // Save the new cursor if needed\\n        if (cursorUpdateNeeded) {\\n            _cursorRB = cursor;\\n        }\\n\\n        // Save the new _rankedBidCount value\\n        _rankedBidCount = rankedBidCount;\\n\\n        // Save the new cursor position\\n        _resumeIdxRB = resumeIdx;\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //            \\u2b50\\ufe0f Step 3/4: Compute Ranked Won Quantities O(N) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `chunckSize` iteration cycles for the step #3.\\n     * see function {computeValidation}\\n     * @param progress The current step progress.\\n     * @param iter The number of iterations to compute in a single call. (`iter` > 0)\\n     * @param progressMax The maximum progress value for the step #3 which is equal to `_bidCount`.\\n     * (`progress` + `iter` <= `progressMax`)\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x lt(euint256, euint256)  : 1 x 231_000\\n     * - 1x gt(euint256, euint256)  : 1 x 231_000\\n     * - 1x and                     : 1 x  44_000\\n     * - 1x sub(euint256, euint256) : 1 x 253_000\\n     * - 1x min(euint256, euint256) : 1 x 277_000\\n     * - 1x add(euint256, euint256) : 1 x 253_000\\n     * - 2x select(euint256)        : 2 x  90_000\\n     *\\n     * Total FHE Gas Cost per iteration : 1_469_000\\n     */\\n    function _runStep3(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        // Average gas cost:\\n        // - first iteration : 113_000 gas\\n        // - single iteration : 225_000 gas\\n        if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        // Debug\\n        if (!(_rankedBidCount == _bidCount && _rankedBids.length >= _bidCount)) revert DebugEngineError(11);\\n\\n        uint16 from = uint16(progress);\\n        uint16 to = uint16(from + iter);\\n\\n        address auctionAddr = address(_auction());\\n        euint256 cumulativeQuantity;\\n        euint256 uniformPrice;\\n\\n        uint16 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n\\n        if (from == 0) {\\n            cumulativeQuantity = _rankedBids[0].quantity;\\n            uniformPrice = _rankedBids[0].price;\\n\\n            euint256 wonQuantity = TFHE.min(cumulativeQuantity, _totalQuantity);\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[0].id, auctionAddr);\\n            TFHE.allow(_rankedBids[0].price, auctionAddr);\\n\\n            _rankedWonQuantities[0] = wonQuantity;\\n\\n            if (to == 1) {\\n                _cumulativeQuantity = cumulativeQuantity;\\n                _uniformPrice = uniformPrice;\\n\\n                if (to == progressMax) {\\n                    TFHE.allow(uniformPrice, auctionAddr);\\n                    code = S_FINISHED;\\n                    _wonQuantitiesByRankReady = true;\\n                }\\n\\n                return (code, 1);\\n            }\\n\\n            from = 1;\\n            count = 1;\\n        } else {\\n            // Gas cost ~= 4_000\\n            cumulativeQuantity = _cumulativeQuantity;\\n            uniformPrice = _uniformPrice;\\n        }\\n\\n        // Here: 1 <= from < to\\n\\n        // Possible gas cost from start up to this point:\\n        //   - Branch #1 : 13_000 gas (from != 0)\\n        //   - Branch #2 : 73_000 gas (from == 0 && to != 1)\\n        //\\n        // 1x loop iter ~= 155_000 gas\\n        // After loop ~= 60_000 gas\\n        for (uint16 k = from; k < to; ++k) {\\n            if (gasleft() < MIN_GAS_PER_RWQ_CYCLE) {\\n                // Not enough gas to iter one more time and be sure to complete\\n                // the function without beeing out-of-gas\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n\\n            euint256 bidQuantity = _rankedBids[k].quantity;\\n            euint256 bidPrice = _rankedBids[k].price;\\n\\n            // Formula:\\n            // Wk = (C(k-1) < Q) ? min(Q - C(k-1), q_k) : 0\\n            ebool isValid = TFHE.lt(cumulativeQuantity, _totalQuantity);\\n\\n            // Price = 0 means the bid is invalid\\n            // pk = 0 => qk = 0\\n            isValid = TFHE.and(isValid, TFHE.gt(bidPrice, _eZeroU256));\\n\\n            euint256 remainingQuantity = TFHE.sub(_totalQuantity, cumulativeQuantity);\\n            euint256 wonQuantity = TFHE.select(isValid, TFHE.min(remainingQuantity, bidQuantity), _eZeroU256);\\n\\n            cumulativeQuantity = TFHE.add(cumulativeQuantity, bidQuantity);\\n            uniformPrice = TFHE.select(isValid, bidPrice, uniformPrice);\\n\\n            TFHE.allowThis(wonQuantity);\\n\\n            // Additional allowance, required when using blind claim\\n            TFHE.allow(wonQuantity, auctionAddr);\\n            TFHE.allow(_rankedBids[k].id, auctionAddr);\\n            TFHE.allow(_rankedBids[k].price, auctionAddr);\\n\\n            _rankedWonQuantities[k] = wonQuantity;\\n\\n            count++;\\n        }\\n\\n        // Allow cost ~= 48_000 gas\\n        if (count > 0) {\\n            TFHE.allowThis(cumulativeQuantity);\\n            TFHE.allowThis(uniformPrice);\\n        }\\n\\n        // Storage cost ~= 9_000 gas\\n        _cumulativeQuantity = cumulativeQuantity;\\n        _uniformPrice = uniformPrice;\\n\\n        // Debug\\n        if (!(progress + count <= progressMax)) revert DebugEngineError(13);\\n\\n        if (progress + count == progressMax) {\\n            TFHE.allow(uniformPrice, auctionAddr);\\n            code = S_FINISHED;\\n            _wonQuantitiesByRankReady = true;\\n        }\\n\\n        return (code, count);\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //        \\u2b50\\ufe0f Step 4/4: Compute Won Quantities O(N^2) (Optional) \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    /**\\n     * @notice Computes a set of `iter` iteration cycles for the step #4.\\n     * see function {computeValidation}\\n     *\\n     * @dev FHE Gas Cost per iteration:\\n     * - 1x eq(euint16, euint16)  : 1 x 54_000\\n     * - 1x select(euint16)       : 1 x 47_000\\n     *\\n     * Total FHE Gas Cost per iteration : 101_000\\n     */\\n    function _runStep4(uint32 progress, uint32 iter, uint32 progressMax) internal returns (uint8, uint32) {\\n        if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n            return (E_NOT_ENOUGH_GAS, 0);\\n        }\\n\\n        uint16 idxWQ = _idxWQ;\\n        uint16 resumeIdxWQ = _resumeIdxWQ;\\n        euint256 quantity = _quantityWQ;\\n\\n        // Debug\\n        if (\\n            !(\\n                idxWQ < _bidCount && resumeIdxWQ < _bidCount\\n                    && (idxWQ * _bidCount + resumeIdxWQ + iter <= _bidCount * _bidCount)\\n            )\\n        ) {\\n            revert DebugEngineError(14);\\n        }\\n        // Debug\\n        if (!(progress == idxWQ * _bidCount + resumeIdxWQ)) revert DebugEngineError(15);\\n\\n        uint16 idx = idxWQ;\\n        uint16 resumeIdx = resumeIdxWQ;\\n        uint32 count = 0;\\n        uint8 code = S_NOT_FINISHED;\\n        address auctionAddr = address(_auction());\\n\\n        while (count < iter) {\\n            ebool eq_id = TFHE.eq(_rankedBids[resumeIdx].id, _indexPlusOneToId[idx + 1]);\\n            quantity = TFHE.select(eq_id, _rankedWonQuantities[resumeIdx], quantity);\\n\\n            resumeIdx++;\\n\\n            if (resumeIdx == _bidCount) {\\n                // store won quantity\\n                _wonQuantities[idx] = quantity;\\n                TFHE.allowThis(quantity);\\n                TFHE.allow(quantity, auctionAddr);\\n\\n                // reset cursor\\n                idx += 1;\\n                resumeIdx = 0;\\n                quantity = _eZeroU256;\\n            }\\n\\n            count++;\\n\\n            if (gasleft() < MIN_GAS_PER_WQ_CYCLE) {\\n                code = E_NOT_ENOUGH_GAS;\\n                break;\\n            }\\n        }\\n\\n        if (progress + count == progressMax) {\\n            // Debug\\n            if (!(idx == _bidCount && resumeIdx == 0)) revert DebugEngineError(18);\\n\\n            //could be removed\\n            _idxWQ = _bidCount;\\n            //not necessary ?\\n            //_resumeIdxWQ = 0;\\n            _wonQuantitiesByIdReady = true;\\n\\n            return (S_FINISHED, count);\\n        }\\n\\n        // Debug\\n        if (!(idx < _bidCount)) revert DebugEngineError(19);\\n\\n        if (resumeIdx != resumeIdxWQ) {\\n            _resumeIdxWQ = resumeIdx;\\n        }\\n\\n        if (idx != idxWQ) {\\n            _idxWQ = idx;\\n        }\\n\\n        _quantityWQ = quantity;\\n        TFHE.allowThis(quantity);\\n\\n        return (code, count);\\n    }\\n\\n    /**\\n     * @dev Returns the encrypted bid ranked at position `rank`.\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _rankedBidAt(uint16 rank) internal view returns (ABid storage bid) {\\n        bid = _rankedBids[rank];\\n    }\\n\\n    /**\\n     * @dev Sets the encrypted bid ranked at position `rank`\\n     * This function is meant be called by derived contracts.\\n     */\\n    function _setRankedBidAt(uint16 rank, ABid memory newBid) internal {\\n        _rankedBids[rank] = newBid;\\n        _allowBid(newBid);\\n    }\\n\\n    /**\\n     * @dev Grants the engine permission to access the encrypted bid values (`price`, `quantity`, `id`, `rand`).\\n     */\\n    function _allowBid(ABid memory bid_) private {\\n        TFHE.allowThis(bid_.price);\\n        TFHE.allowThis(bid_.quantity);\\n        TFHE.allowThis(bid_.id);\\n        if (TFHE.isInitialized(bid_.rand)) {\\n            TFHE.allowThis(bid_.rand);\\n        }\\n    }\\n\\n    // ====================================================================== //\\n    //\\n    //               \\u2b50\\ufe0f IFourStepsIterable implementation \\u2b50\\ufe0f\\n    //\\n    // ====================================================================== //\\n\\n    function runStep1(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep1(progress, iter, progressMax);\\n    }\\n\\n    function runStep2(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep2(progress, iter, progressMax);\\n    }\\n\\n    function runStep3(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep3(progress, iter, progressMax);\\n    }\\n\\n    function runStep4(uint32 progress, uint32 iter, uint32 progressMax)\\n        external\\n        virtual\\n        override\\n        onlyIterator\\n        returns (uint8, uint32)\\n    {\\n        return _runStep4(progress, iter, progressMax);\\n    }\\n}\\n\",\"keccak256\":\"0x9626d0da8f56de96a981fd9d57f69df68d4b6dab26e1a9aef31e369e5452e929\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/FHEAuctionEngineIterator.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FourStepsIterator, IFourStepsIterable} from \\\"../FourStepsIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"./FHEAuctionEngine.sol\\\";\\n\\n// For better readability, steps are named using a one-based index.\\nuint8 constant STEP_1_VALIDATION = 0;\\nuint8 constant STEP_2_SORT = 1;\\nuint8 constant STEP_3_WON_QUANTITIES_BY_RANK = 2;\\nuint8 constant STEP_4_WON_QUANTITIES_BY_ID = 3;\\n\\ncontract FHEAuctionEngineIterator is FourStepsIterator {\\n    constructor(address initialOwner) FourStepsIterator(initialOwner) {}\\n\\n    function initializeFourSteps(\\n        uint16 bidCount,\\n        uint32 step1UnitFheGasCost,\\n        uint32 step2UnitFheGasCost,\\n        uint32 step3UnitFheGasCost,\\n        uint32 step4UnitFheGasCost,\\n        bool onlyAward\\n    ) external onlyOwner {\\n        FourStepsIterator.Step[] memory fourSteps = new FourStepsIterator.Step[](4);\\n\\n        fourSteps[0].size = bidCount;\\n        fourSteps[0].nativeGasWeight = 1;\\n        fourSteps[0].unitFheGasCost = step1UnitFheGasCost;\\n\\n        fourSteps[1].size = (bidCount == 0) ? 0 : ((bidCount < 3) ? 1 : bidCount * (bidCount - 1) / 2);\\n        fourSteps[1].nativeGasWeight = 2;\\n        fourSteps[1].unitFheGasCost = step2UnitFheGasCost;\\n\\n        fourSteps[2].size = bidCount;\\n        fourSteps[2].nativeGasWeight = 1;\\n        fourSteps[2].unitFheGasCost = step3UnitFheGasCost;\\n\\n        if (!onlyAward) {\\n            fourSteps[3].size = bidCount * bidCount;\\n            fourSteps[3].nativeGasWeight = 1;\\n            fourSteps[3].unitFheGasCost = step4UnitFheGasCost;\\n        }\\n\\n        _initializeFourSteps(fourSteps);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to award a prize to a winning bidder.\\n     */\\n    function minIterationsForPrizeAward() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum number of computation iterations required to finalize the auction uniform price.\\n     */\\n    function minIterationsForUniformPrice() external view returns (uint64) {\\n        // steps #1 to #3 must be completed. See {FHEAuctionEngine} for more details.\\n        return _minIterProgressForStep(STEP_3_WON_QUANTITIES_BY_RANK);\\n    }\\n\\n    /**\\n     * @notice see {FHEAuctionEngine-computeAuctionIterations}\\n     */\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        onlyOwner\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress)\\n    {\\n        (code, startIterProgress, endIterProgress) =\\n            _next(iter, (stopIfReadyForBlindClaim) ? STEP_3_WON_QUANTITIES_BY_RANK : STEP_4_WON_QUANTITIES_BY_ID);\\n    }\\n}\\n\",\"keccak256\":\"0xfd70821f0ffa0b950485edec665316326625b6341b26eb8909512f09a39955a8\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/IFHEAuctionEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {euint16, euint256} from \\\"fhevm/lib/TFHE.sol\\\";\\n\\ninterface IFHEAuctionEngine {\\n    function canClaim() external view returns (bool);\\n    function canAward() external view returns (bool);\\n    function initialize(uint256 totalQuantity, uint16 maxBidCount) external;\\n    function close() external;\\n    function bidderId(address bidder) external view returns (uint16);\\n    function getBidderById(uint16 id) external view returns (address);\\n    function addBid(address bidder, euint256 inPrice, euint256 inQuantity) external;\\n    function removeBid(address bidder) external;\\n    function canDecryptUniformPrice() external view returns (bool);\\n    function getUniformPrice() external view returns (euint256);\\n    function validatedPriceAndWonQuantityById(uint16 id) external view returns (euint256, euint256);\\n    function totalQuantity() external view returns (uint256);\\n    function maximumPrice() external view returns (uint256);\\n    function getBidCount() external view returns (uint16);\\n    function getMaximumBidCount() external view returns (uint16);\\n    function getBidByBidder(address bidder) external view returns (uint16 id, euint256 price, euint256 quantity);\\n    function getWonBidByRank(uint16 rank) external view returns (euint16 id, euint256 price, euint256 quantity);\\n    function iterator() external view returns (address);\\n    function computeAuctionIterations(uint64 iter, bool stopIfReadyForBlindClaim)\\n        external\\n        returns (uint8 code, uint64 startIterProgress, uint64 endIterProgress);\\n}\\n\",\"keccak256\":\"0x2c97e02f19538cd99254accab76d90494135f7d91aa6b6cdf2d08ae2d62802fe\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {FHEAuctionEngineIterator} from \\\"../FHEAuctionEngineIterator.sol\\\";\\nimport {FHEAuctionEngine} from \\\"../FHEAuctionEngine.sol\\\";\\n\\ncontract FHEAuctionEngineIteratorFactory is Ownable2Step {\\n    constructor() Ownable(msg.sender) {}\\n\\n    function createNewIterator(address initialOwner) public virtual returns (address) {\\n        FHEAuctionEngineIterator iterator = new FHEAuctionEngineIterator(initialOwner);\\n        return address(iterator);\\n    }\\n}\\n\",\"keccak256\":\"0x542e17a2f1034da6fcc4749ec1d65e8036db67cea3ae4ed27fda6029e915cf42\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x89d4968cd956a8931f1a8a177b3bef1c6cf88a03665083db74430add50b88f21\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f80fd5b50338061003557604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61003e81610044565b506100af565b600180546001600160a01b031916905561005d81610060565b50565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6118dc806100bc5f395ff3fe608060405234801561000f575f80fd5b506004361061006f575f3560e01c80638da5cb5b1161004d5780638da5cb5b146100b4578063e30c3978146100c4578063f2fde38b146100d5575f80fd5b8063715018a61461007357806379ba50971461007d5780637ef77a8414610085575b5f80fd5b61007b6100e8565b005b61007b6100fb565b6100986100933660046102b7565b610144565b6040516001600160a01b03909116815260200160405180910390f35b5f546001600160a01b0316610098565b6001546001600160a01b0316610098565b61007b6100e33660046102b7565b610184565b6100f0610201565b6100f95f61022d565b565b60015433906001600160a01b031681146101385760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6101418161022d565b50565b5f8082604051610153906102aa565b6001600160a01b039091168152602001604051809103905ff08015801561017c573d5f803e3d5ffd5b509392505050565b61018c610201565b600180546001600160a01b03831673ffffffffffffffffffffffffffffffffffffffff1990911681179091556101c95f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b031633146100f95760405163118cdaa760e01b815233600482015260240161012f565b6001805473ffffffffffffffffffffffffffffffffffffffff19169055610141815f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6115eb806102e583390190565b5f602082840312156102c7575f80fd5b81356001600160a01b03811681146102dd575f80fd5b939250505056fe608060405234801561000f575f80fd5b50604051620015eb380380620015eb833981016040819052610030916101c1565b80806001600160a01b03811661005f57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61006881610172565b505f5b60058160ff16101561016a57604080516060810182525f80825260208201818152928201818152600280546001808201835591845293517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace90940180549551925163ffffffff95861664ffffffffff199097169690961764010000000060ff909416939093029290921763ffffffff60281b19166501000000000094909516939093029390931790925580548082018255918190527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf66004830401805460039093166008026101000a6001600160401b0302199092169091550161006b565b5050506101ee565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f602082840312156101d1575f80fd5b81516001600160a01b03811681146101e7575f80fd5b9392505050565b6113ef80620001fc5f395ff3fe608060405234801561000f575f80fd5b50600436106100f0575f3560e01c8063715018a611610093578063bef4876b11610063578063bef4876b146101fb578063c4ef91f214610214578063e25fe17514610227578063f2fde38b1461023c575f80fd5b8063715018a61461018757806378b4321f146101915780638da5cb5b146101a4578063b1890879146101be575f80fd5b80635b96d860116100ce5780635b96d8601461015957806362b867541461016c578063698c0649146101745780636bc2982d1461016c575f80fd5b806306debb0e146100f4578063160624071461011d5780632ea0d1f61461013e575b5f80fd5b600354610100900463ffffffff165b60405163ffffffff90911681526020015b60405180910390f35b61012561024f565b60405167ffffffffffffffff9091168152602001610114565b60035465010000000000900467ffffffffffffffff16610125565b6101036101673660046110d1565b610291565b6101256102bf565b6101036101823660046110d1565b6102cf565b61018f61033b565b005b61012561019f3660046110d1565b61034e565b5f546040516001600160a01b039091168152602001610114565b6101d16101cc366004611107565b6103ba565b6040805160ff909416845267ffffffffffffffff9283166020850152911690820152606001610114565b60035460ff166004146040519015158152602001610114565b61018f610222366004611157565b6103ea565b60035460405160ff9091168152602001610114565b61018f61024a3660046111d7565b6106e3565b5f6001600381548110610264576102646111fd565b905f5260205f2090600491828204019190066008029054906101000a900467ffffffffffffffff16905090565b5f60028260ff16815481106102a8576102a86111fd565b5f9182526020909120015463ffffffff1692915050565b5f6102ca6002610725565b905090565b6003545f9060ff90811690831681036102f7575050600354610100900463ffffffff16919050565b8260ff168160ff1611156103335760028360ff168154811061031b5761031b6111fd565b5f9182526020909120015463ffffffff169392505050565b505f92915050565b61034361076b565b61034c5f610797565b565b5f60028260ff1681548110610365576103656111fd565b5f918252602090912001546002805460ff6401000000009093048316928516908110610393576103936111fd565b5f918252602090912001546103ae919063ffffffff16611225565b63ffffffff1692915050565b5f805f6103c561076b565b6103dc85856103d55760036107fe565b60026107fe565b919790965090945092505050565b6103f261076b565b60408051600480825260a082019092525f91816020015b604080516060810182525f80825260208083018290529282015282525f199092019101816104095790505090508661ffff16815f8151811061044d5761044d6111fd565b60200260200101515f019063ffffffff16908163ffffffff16815250506001815f8151811061047e5761047e6111fd565b60200260200101516020019060ff16908160ff168152505085815f815181106104a9576104a96111fd565b602090810291909101015163ffffffff90911660409091015261ffff8716156105055760038761ffff16106104fe5760026104e560018961124d565b6104ef908961126f565b6104f991906112a1565b610507565b6001610507565b5f5b61ffff168160018151811061051e5761051e6111fd565b60200260200101515f019063ffffffff16908163ffffffff1681525050600281600181518110610550576105506111fd565b60200260200101516020019060ff16908160ff1681525050848160018151811061057c5761057c6111fd565b60200260200101516040019063ffffffff16908163ffffffff16815250508661ffff16816002815181106105b2576105b26111fd565b60200260200101515f019063ffffffff16908163ffffffff16815250506001816002815181106105e4576105e46111fd565b60200260200101516020019060ff16908160ff16815250508381600281518110610610576106106111fd565b60200260200101516040019063ffffffff16908163ffffffff1681525050816106d15761063d878061126f565b61ffff1681600381518110610654576106546111fd565b60200260200101515f019063ffffffff16908163ffffffff1681525050600181600381518110610686576106866111fd565b60200260200101516020019060ff16908160ff168152505082816003815181106106b2576106b26111fd565b60200260200101516040019063ffffffff16908163ffffffff16815250505b6106da81610e26565b50505050505050565b6106eb61076b565b6001600160a01b03811661071957604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b61072281610797565b50565b5f60018260ff168154811061073c5761073c6111fd565b905f5260205f2090600491828204019190066008029054906101000a900467ffffffffffffffff169050919050565b5f546001600160a01b0316331461034c5760405163118cdaa760e01b8152336004820152602401610710565b5f80546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6003545f9067ffffffffffffffff6501000000000082041690819060ff166004811461082a575f61082d565b60015b93508460ff168160ff1611156108435750610e1f565b600354629896809063ffffffff610100909104165f8061086a5f546001600160a01b031690565b90505b60048560ff1610801561088657508860ff168560ff1611155b801561089757505f8463ffffffff16115b15610d62575f60028660ff16815481106108b3576108b36111fd565b5f918252602080832060408051606081018252939091015463ffffffff808216808652640100000000830460ff16948601949094526501000000000090910416908301529092506109059086906112c1565b90508063ffffffff165f0361092b575f94506109226001886112de565b9650505061086d565b8b67ffffffffffffffff165f03610943575050610d62565b602082015160ff165f67ffffffffffffffff8e1682111561096f575063ffffffff81169c5060016109a9565b6109798284611225565b63ffffffff168e67ffffffffffffffff16106109965750816109a9565b6109a663ffffffff83168f6112fd565b90505b8763ffffffff168460400151826109c09190611225565b63ffffffff1611156109f65760408401516109db9089611317565b90508063ffffffff165f036109f6575f975050505050610d62565b6040840151610a059082611225565b610a0f90896112c1565b97505f8960ff165f03610aa657845160405163e8f5858160e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063e8f58581906064015b60408051808303815f875af1158015610a78573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a9c919061132d565b909d509050610bd6565b8960ff16600103610af657845160405163285bb39360e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063285bb39390606401610a5d565b8960ff16600203610b465784516040516306e62f6960e51b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063dcc5ed2090606401610a5d565b8960ff16600303610bd6578451604051637562fa0b60e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b03871690637562fa0b9060640160408051808303815f875af1158015610bac573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd0919061132d565b909d5090505b610be08382611225565b610bf09063ffffffff1688611365565b9650610bfc8382611225565b63ffffffff168f610c0d9190611386565b9e50610c1981896113a7565b97505f1960ff8e1601610c9457845163ffffffff898116911614610c7f5760405162461bcd60e51b815260206004820152601860248201527f50616e69633a207020213d20746865537465702e73697a6500000000000000006044820152606401610710565b5f9750610c8d60018b6112de565b9950610d58565b845f015163ffffffff168863ffffffff1610610cf25760405162461bcd60e51b815260206004820152601860248201527f50616e69633a2070203e3d20746865537465702e73697a6500000000000000006044820152606401610710565b60ff8d1615610d585760ff8d16600214610d4e5760405162461bcd60e51b815260206004820152601f60248201527f50616e69633a20636f646520213d20455f4e4f545f454e4f5547485f474153006044820152606401610710565b5050505050610d62565b505050505061086d565b5f8a67ffffffffffffffff16118015610d7f575063ffffffff8416155b15610d8957600297505b67ffffffffffffffff821615610dd057610da38288611365565b600380546cffffffffffffffff000000000019166501000000000067ffffffffffffffff84160217905595505b6003805464ffffffffff191661010063ffffffff86160260ff19161760ff87811691909117909155600290891614610e19578460ff16600414610e13575f610e16565b60015b97505b50505050505b9250925092565b600481511115610e34575f80fd5b5f805b82518160ff16101561104f575f838260ff1681518110610e5957610e596111fd565b60200260200101515f015163ffffffff16118015610e995750828160ff1681518110610e8757610e876111fd565b60200260200101516020015160ff165f145b15610eb75760405163efa7e62960e01b815260040160405180910390fd5b828160ff1681518110610ecc57610ecc6111fd565b60200260200101516020015160ff16838260ff1681518110610ef057610ef06111fd565b60200260200101515f0151610f059190611225565b610f159063ffffffff1683611365565b91505f60028260ff1681548110610f2e57610f2e6111fd565b905f5260205f20019050838260ff1681518110610f4d57610f4d6111fd565b602090810291909101015151815463ffffffff191663ffffffff9091161781558351849060ff8416908110610f8457610f846111fd565b6020908102919091018101510151815464ff00000000191664010000000060ff92831602178255845185918416908110610fc057610fc06111fd565b602002602001015160400151815f0160056101000a81548163ffffffff021916908363ffffffff1602179055508260018360ff1681548110611004576110046111fd565b905f5260205f2090600491828204019190066008026101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505080611048906113c4565b9050610e37565b60048160ff1610156110be578160018260ff1681548110611072576110726111fd565b905f5260205f2090600491828204019190066008026101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555080806110b6906113c4565b91505061104f565b505050565b60ff81168114610722575f80fd5b5f602082840312156110e1575f80fd5b81356110ec816110c3565b9392505050565b80358015158114611102575f80fd5b919050565b5f8060408385031215611118575f80fd5b823567ffffffffffffffff8116811461112f575f80fd5b915061113d602084016110f3565b90509250929050565b63ffffffff81168114610722575f80fd5b5f805f805f8060c0878903121561116c575f80fd5b863561ffff8116811461117d575f80fd5b9550602087013561118d81611146565b9450604087013561119d81611146565b935060608701356111ad81611146565b925060808701356111bd81611146565b91506111cb60a088016110f3565b90509295509295509295565b5f602082840312156111e7575f80fd5b81356001600160a01b03811681146110ec575f80fd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b63ffffffff81811683821602808216919082811461124557611245611211565b505092915050565b61ffff82811682821603908082111561126857611268611211565b5092915050565b61ffff81811683821602808216919082811461124557611245611211565b634e487b7160e01b5f52601260045260245ffd5b5f61ffff808416806112b5576112b561128d565b92169190910492915050565b63ffffffff82811682821603908082111561126857611268611211565b60ff81811683821601908111156112f7576112f7611211565b92915050565b5f67ffffffffffffffff808416806112b5576112b561128d565b5f63ffffffff808416806112b5576112b561128d565b5f806040838503121561133e575f80fd5b8251611349816110c3565b602084015190925061135a81611146565b809150509250929050565b67ffffffffffffffff81811683821601908082111561126857611268611211565b67ffffffffffffffff82811682821603908082111561126857611268611211565b63ffffffff81811683821601908082111561126857611268611211565b5f60ff821660ff81036113d9576113d9611211565b6001019291505056fea164736f6c6343000818000aa164736f6c6343000818000a",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b506004361061006f575f3560e01c80638da5cb5b1161004d5780638da5cb5b146100b4578063e30c3978146100c4578063f2fde38b146100d5575f80fd5b8063715018a61461007357806379ba50971461007d5780637ef77a8414610085575b5f80fd5b61007b6100e8565b005b61007b6100fb565b6100986100933660046102b7565b610144565b6040516001600160a01b03909116815260200160405180910390f35b5f546001600160a01b0316610098565b6001546001600160a01b0316610098565b61007b6100e33660046102b7565b610184565b6100f0610201565b6100f95f61022d565b565b60015433906001600160a01b031681146101385760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6101418161022d565b50565b5f8082604051610153906102aa565b6001600160a01b039091168152602001604051809103905ff08015801561017c573d5f803e3d5ffd5b509392505050565b61018c610201565b600180546001600160a01b03831673ffffffffffffffffffffffffffffffffffffffff1990911681179091556101c95f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b031633146100f95760405163118cdaa760e01b815233600482015260240161012f565b6001805473ffffffffffffffffffffffffffffffffffffffff19169055610141815f80546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6115eb806102e583390190565b5f602082840312156102c7575f80fd5b81356001600160a01b03811681146102dd575f80fd5b939250505056fe608060405234801561000f575f80fd5b50604051620015eb380380620015eb833981016040819052610030916101c1565b80806001600160a01b03811661005f57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61006881610172565b505f5b60058160ff16101561016a57604080516060810182525f80825260208201818152928201818152600280546001808201835591845293517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace90940180549551925163ffffffff95861664ffffffffff199097169690961764010000000060ff909416939093029290921763ffffffff60281b19166501000000000094909516939093029390931790925580548082018255918190527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf66004830401805460039093166008026101000a6001600160401b0302199092169091550161006b565b5050506101ee565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f602082840312156101d1575f80fd5b81516001600160a01b03811681146101e7575f80fd5b9392505050565b6113ef80620001fc5f395ff3fe608060405234801561000f575f80fd5b50600436106100f0575f3560e01c8063715018a611610093578063bef4876b11610063578063bef4876b146101fb578063c4ef91f214610214578063e25fe17514610227578063f2fde38b1461023c575f80fd5b8063715018a61461018757806378b4321f146101915780638da5cb5b146101a4578063b1890879146101be575f80fd5b80635b96d860116100ce5780635b96d8601461015957806362b867541461016c578063698c0649146101745780636bc2982d1461016c575f80fd5b806306debb0e146100f4578063160624071461011d5780632ea0d1f61461013e575b5f80fd5b600354610100900463ffffffff165b60405163ffffffff90911681526020015b60405180910390f35b61012561024f565b60405167ffffffffffffffff9091168152602001610114565b60035465010000000000900467ffffffffffffffff16610125565b6101036101673660046110d1565b610291565b6101256102bf565b6101036101823660046110d1565b6102cf565b61018f61033b565b005b61012561019f3660046110d1565b61034e565b5f546040516001600160a01b039091168152602001610114565b6101d16101cc366004611107565b6103ba565b6040805160ff909416845267ffffffffffffffff9283166020850152911690820152606001610114565b60035460ff166004146040519015158152602001610114565b61018f610222366004611157565b6103ea565b60035460405160ff9091168152602001610114565b61018f61024a3660046111d7565b6106e3565b5f6001600381548110610264576102646111fd565b905f5260205f2090600491828204019190066008029054906101000a900467ffffffffffffffff16905090565b5f60028260ff16815481106102a8576102a86111fd565b5f9182526020909120015463ffffffff1692915050565b5f6102ca6002610725565b905090565b6003545f9060ff90811690831681036102f7575050600354610100900463ffffffff16919050565b8260ff168160ff1611156103335760028360ff168154811061031b5761031b6111fd565b5f9182526020909120015463ffffffff169392505050565b505f92915050565b61034361076b565b61034c5f610797565b565b5f60028260ff1681548110610365576103656111fd565b5f918252602090912001546002805460ff6401000000009093048316928516908110610393576103936111fd565b5f918252602090912001546103ae919063ffffffff16611225565b63ffffffff1692915050565b5f805f6103c561076b565b6103dc85856103d55760036107fe565b60026107fe565b919790965090945092505050565b6103f261076b565b60408051600480825260a082019092525f91816020015b604080516060810182525f80825260208083018290529282015282525f199092019101816104095790505090508661ffff16815f8151811061044d5761044d6111fd565b60200260200101515f019063ffffffff16908163ffffffff16815250506001815f8151811061047e5761047e6111fd565b60200260200101516020019060ff16908160ff168152505085815f815181106104a9576104a96111fd565b602090810291909101015163ffffffff90911660409091015261ffff8716156105055760038761ffff16106104fe5760026104e560018961124d565b6104ef908961126f565b6104f991906112a1565b610507565b6001610507565b5f5b61ffff168160018151811061051e5761051e6111fd565b60200260200101515f019063ffffffff16908163ffffffff1681525050600281600181518110610550576105506111fd565b60200260200101516020019060ff16908160ff1681525050848160018151811061057c5761057c6111fd565b60200260200101516040019063ffffffff16908163ffffffff16815250508661ffff16816002815181106105b2576105b26111fd565b60200260200101515f019063ffffffff16908163ffffffff16815250506001816002815181106105e4576105e46111fd565b60200260200101516020019060ff16908160ff16815250508381600281518110610610576106106111fd565b60200260200101516040019063ffffffff16908163ffffffff1681525050816106d15761063d878061126f565b61ffff1681600381518110610654576106546111fd565b60200260200101515f019063ffffffff16908163ffffffff1681525050600181600381518110610686576106866111fd565b60200260200101516020019060ff16908160ff168152505082816003815181106106b2576106b26111fd565b60200260200101516040019063ffffffff16908163ffffffff16815250505b6106da81610e26565b50505050505050565b6106eb61076b565b6001600160a01b03811661071957604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b61072281610797565b50565b5f60018260ff168154811061073c5761073c6111fd565b905f5260205f2090600491828204019190066008029054906101000a900467ffffffffffffffff169050919050565b5f546001600160a01b0316331461034c5760405163118cdaa760e01b8152336004820152602401610710565b5f80546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6003545f9067ffffffffffffffff6501000000000082041690819060ff166004811461082a575f61082d565b60015b93508460ff168160ff1611156108435750610e1f565b600354629896809063ffffffff610100909104165f8061086a5f546001600160a01b031690565b90505b60048560ff1610801561088657508860ff168560ff1611155b801561089757505f8463ffffffff16115b15610d62575f60028660ff16815481106108b3576108b36111fd565b5f918252602080832060408051606081018252939091015463ffffffff808216808652640100000000830460ff16948601949094526501000000000090910416908301529092506109059086906112c1565b90508063ffffffff165f0361092b575f94506109226001886112de565b9650505061086d565b8b67ffffffffffffffff165f03610943575050610d62565b602082015160ff165f67ffffffffffffffff8e1682111561096f575063ffffffff81169c5060016109a9565b6109798284611225565b63ffffffff168e67ffffffffffffffff16106109965750816109a9565b6109a663ffffffff83168f6112fd565b90505b8763ffffffff168460400151826109c09190611225565b63ffffffff1611156109f65760408401516109db9089611317565b90508063ffffffff165f036109f6575f975050505050610d62565b6040840151610a059082611225565b610a0f90896112c1565b97505f8960ff165f03610aa657845160405163e8f5858160e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063e8f58581906064015b60408051808303815f875af1158015610a78573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a9c919061132d565b909d509050610bd6565b8960ff16600103610af657845160405163285bb39360e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063285bb39390606401610a5d565b8960ff16600203610b465784516040516306e62f6960e51b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b0387169063dcc5ed2090606401610a5d565b8960ff16600303610bd6578451604051637562fa0b60e01b815263ffffffff808b166004830152808516602483015290911660448201526001600160a01b03871690637562fa0b9060640160408051808303815f875af1158015610bac573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bd0919061132d565b909d5090505b610be08382611225565b610bf09063ffffffff1688611365565b9650610bfc8382611225565b63ffffffff168f610c0d9190611386565b9e50610c1981896113a7565b97505f1960ff8e1601610c9457845163ffffffff898116911614610c7f5760405162461bcd60e51b815260206004820152601860248201527f50616e69633a207020213d20746865537465702e73697a6500000000000000006044820152606401610710565b5f9750610c8d60018b6112de565b9950610d58565b845f015163ffffffff168863ffffffff1610610cf25760405162461bcd60e51b815260206004820152601860248201527f50616e69633a2070203e3d20746865537465702e73697a6500000000000000006044820152606401610710565b60ff8d1615610d585760ff8d16600214610d4e5760405162461bcd60e51b815260206004820152601f60248201527f50616e69633a20636f646520213d20455f4e4f545f454e4f5547485f474153006044820152606401610710565b5050505050610d62565b505050505061086d565b5f8a67ffffffffffffffff16118015610d7f575063ffffffff8416155b15610d8957600297505b67ffffffffffffffff821615610dd057610da38288611365565b600380546cffffffffffffffff000000000019166501000000000067ffffffffffffffff84160217905595505b6003805464ffffffffff191661010063ffffffff86160260ff19161760ff87811691909117909155600290891614610e19578460ff16600414610e13575f610e16565b60015b97505b50505050505b9250925092565b600481511115610e34575f80fd5b5f805b82518160ff16101561104f575f838260ff1681518110610e5957610e596111fd565b60200260200101515f015163ffffffff16118015610e995750828160ff1681518110610e8757610e876111fd565b60200260200101516020015160ff165f145b15610eb75760405163efa7e62960e01b815260040160405180910390fd5b828160ff1681518110610ecc57610ecc6111fd565b60200260200101516020015160ff16838260ff1681518110610ef057610ef06111fd565b60200260200101515f0151610f059190611225565b610f159063ffffffff1683611365565b91505f60028260ff1681548110610f2e57610f2e6111fd565b905f5260205f20019050838260ff1681518110610f4d57610f4d6111fd565b602090810291909101015151815463ffffffff191663ffffffff9091161781558351849060ff8416908110610f8457610f846111fd565b6020908102919091018101510151815464ff00000000191664010000000060ff92831602178255845185918416908110610fc057610fc06111fd565b602002602001015160400151815f0160056101000a81548163ffffffff021916908363ffffffff1602179055508260018360ff1681548110611004576110046111fd565b905f5260205f2090600491828204019190066008026101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055505080611048906113c4565b9050610e37565b60048160ff1610156110be578160018260ff1681548110611072576110726111fd565b905f5260205f2090600491828204019190066008026101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555080806110b6906113c4565b91505061104f565b505050565b60ff81168114610722575f80fd5b5f602082840312156110e1575f80fd5b81356110ec816110c3565b9392505050565b80358015158114611102575f80fd5b919050565b5f8060408385031215611118575f80fd5b823567ffffffffffffffff8116811461112f575f80fd5b915061113d602084016110f3565b90509250929050565b63ffffffff81168114610722575f80fd5b5f805f805f8060c0878903121561116c575f80fd5b863561ffff8116811461117d575f80fd5b9550602087013561118d81611146565b9450604087013561119d81611146565b935060608701356111ad81611146565b925060808701356111bd81611146565b91506111cb60a088016110f3565b90509295509295509295565b5f602082840312156111e7575f80fd5b81356001600160a01b03811681146110ec575f80fd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b63ffffffff81811683821602808216919082811461124557611245611211565b505092915050565b61ffff82811682821603908082111561126857611268611211565b5092915050565b61ffff81811683821602808216919082811461124557611245611211565b634e487b7160e01b5f52601260045260245ffd5b5f61ffff808416806112b5576112b561128d565b92169190910492915050565b63ffffffff82811682821603908082111561126857611268611211565b60ff81811683821601908111156112f7576112f7611211565b92915050565b5f67ffffffffffffffff808416806112b5576112b561128d565b5f63ffffffff808416806112b5576112b561128d565b5f806040838503121561133e575f80fd5b8251611349816110c3565b602084015190925061135a81611146565b809150509250929050565b67ffffffffffffffff81811683821601908082111561126857611268611211565b67ffffffffffffffff82811682821603908082111561126857611268611211565b63ffffffff81811683821601908082111561126857611268611211565b5f60ff821660ff81036113d9576113d9611211565b6001019291505056fea164736f6c6343000818000aa164736f6c6343000818000a",
  "devdoc": {
    "errors": {
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8,
        "contract": "contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol:FHEAuctionEngineIteratorFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 156,
        "contract": "contracts/engines/factories/FHEAuctionEngineIteratorFactory.sol:FHEAuctionEngineIteratorFactory",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}